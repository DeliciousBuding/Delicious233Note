{"path":"01 数据结构和算法/PPT/第09章课件-不相交集.pdf","text":"数据结构 计算机领域本科教育教学改革试点 工作计划（“101计划”）研究成果 授课教师： 湖南大学 信息科学与工程学院 不相交集 第 9 章 9.1 问题引入 9.2 等价关系、等价类和不相交集 9.3 不相交集的存储实现 9.4 不相交集的基本运算实现 9.5 不相交集的应用 9.6 拓展延伸 9.7 应用场景 4 9.1 问题引入：Kruskal算法的高效实现 9.1 问题引入 数据结构 • 求最小生成树的Kruskal算法： • 按权重递增顺序考虑每条边 • 并把连接不同连通分量的边𝑒 = 𝑢, 𝑣 加入生成 树。 • 这需要动态地维护图的连通性 • 需要支持下列三种操作： • （初始化）初始化一个无向图𝐺 = 𝑉, 𝐸 ， 其中𝐸 = ∅（空集），即每个顶点分属于不 同的连通分量。 • （加边）在图中加入一条边 𝑢, 𝑣 ：𝐸 ← 𝐸 ∪ { 𝑢, 𝑣 }。 • （连通性查询）查询顶点𝑢和顶点𝑣是否属于 同一连通分量，即查询两顶点之间是否有路 径相连。 B C FA D G E 10 8 12 37 6 16 5 14 9 2 4 第1步： 选取<E,F> B C FA D G E 10 8 12 37 6 16 5 14 9 2 4 B C FA D G E 10 8 12 37 6 16 5 14 9 2 4 第2步： 选取<C,D> B C FA D G E 10 8 12 37 6 16 5 14 9 2 4 第3步： 选取<D,E> B C FA D G E 10 8 12 37 6 16 5 14 9 2 4 第4步： 选取<B,F> B C FA D G E 10 8 12 37 6 16 5 14 9 2 4 第5步： 选取<E,G> B C FA D G E 10 8 12 37 6 16 5 14 9 2 4 第6步： 选取<A,B> 5 9.1 问题引入：Kruskal算法的高效实现 9.1 问题引入 数据结构 • 直接做法：利用无向图实现 • 加边操作只需𝑂 1 时间； • 连通性查询可以通过图的遍历实现，在𝑛 = 𝑉 个顶点的图中，每次查询最坏需 要𝑂 𝑛 。 • 在Kruskal算法中，对每条边均需要进行一次连通性查询，因此m=|E|次查询的 总时间复杂度为𝑂 𝑛𝑚 。 6 9.1 问题引入：Kruskal算法的高效实现 9.1 问题引入 数据结构 • 注意：只需要查询顶点之间是否连通，不关心它们具体通过哪条路径连通 • 此外，只需要支持加边操作，而不需要支持删边操作。 • 这种情况下，与其完整地维护无向图的结构，不如直接维护连通分量构成的集合 • 每个连通分量用其中顶点的集合表示。 连通性查询问题变成了维护若干不相交的集合，并动态地合并、查找的问题。 初始时，每个顶点都是独 立的连通分量，此时有𝑛 个仅包含单一顶点的集合： {𝑣_1},{𝑣_2},…,{𝑣_𝑛} 1 每加入一条边(𝑢,𝑣)， 就将𝑢所属的集合和𝑣 所属的集合合并 2 对于连通性查询 (𝑢,𝑣)，只需查询𝑢和 𝑣是否在同一集合中 3 7 9.1 问题引入：Kruskal算法的高效实现 9.1 问题引入 数据结构 • 利用不相交集的数据结构，这些集合操作仅需每操作𝑂 𝛼(𝑛) 的时间复杂 度，其中𝛼(⋅)是一个增长极其缓慢的函数，一般可以认为𝛼(𝑛) ≤ 4 。该时 间复杂度仅略高于𝑂(1) ，而大大低于图的遍历所需的𝑶(𝒏) 。 8 9.2 等价关系、等价类和不相交集 9.2 等价关系、等价类和不相交集 数据结构 • 不相交集与数学中等价关系、等价类的概念密切相关 • 元素之间的等价关系自然地定义了若干不相交集的集合 • 因此，不相交集常常用于处理等价性查询的问题 • 例如，两个顶点在同一连通分量中就可以看做一种等价性 9 9.2 等价关系、等价类和不相交集 9.2 等价关系、等价类和不相交集 数据结构 等价性查询的一般定义： 定义 9-1. （等价关系）称在集合X上的二元关系∼为一个等价关 系，若其满足： • （自反性）∀a ∈ X，有a ∼ a； • （对称性）∀a, b ∈ X，若a ∼ b，则b ∼ a； • （传递性）∀a, b, c ∈ X，若a ∼ b，b ∼ c，则a ∼ c。 10 9.2 等价关系、等价类和不相交集 9.2 等价关系、等价类和不相交集 数据结构 • 一个最常见的等价关系是定义在整数集ℤ上的相等关系=。不难验证，该关系 满足定义9-1中的三条性质。 • 等价关系将“相等”的概念推广到了一般的集合。 例 9.1. 不同问题中的等价关系： ✓ 对于平面上全部三角形构成的集合R6，三角形之间的全等关系≌以及相似关系∼均 为等价关系 ✓ 对于无向图G=(V,E)中顶点构成的结合V,定义代表∼顶点间的连通性，即∀u, v ∈ X， u∼v当且仅当u、v连通，则顶点间的连通性是一个等价关系。 ✓ 对于所有生物构成的集合，两种生物是否属于同一科构成一个等价关系。 11 9.2 等价关系、等价类和不相交集 9.2 等价关系、等价类和不相交集 数据结构 ⚫ 定义 9-3. （商集）集合X关于等价关系∼的商集记作X/∼，定义为: • X/∼ : = {{x ∈ X，x ∼ a}, a ∈ X}. ⚫ 定义 9-2. （等价类）给定集合X和等价关系∼，定义某一元素a ∈ X的等 价类为{x ∈ X，x ∼ a}。 对集合中的任意元素，称所有与其等价的元素为一个等价类： 等价关系把集合划分成若干个不相交的等价类，每个等价类中的元素互相等价。 称所有等价类构成的集合为一个商集。 商集是一系列集合，这些集合彼此不相交，并且其并集是全集X。这与不相交集 的概念恰好对应。 12 9.2 等价关系、等价类和不相交集 9.2 等价关系、等价类和不相交集 数据结构 • 例 9.2. 在下图所示的无向图G = V, E 中，考虑顶点间的连通关系∼（见例9.1）。 • 该连通关系将点集V划分为了三个等价类，分别为{1,2,3,4,5}、{6,7}和{8}。这些等价 类彼此不相交，且它们的并集为全集V。本例中，每个等价类是一个无向图中的连通 分量。 无向图𝑮 = 𝑽, 𝑬 中连通性等价关系定义的等价类 13 9.2 等价关系、等价类和不相交集 9.2 等价关系、等价类和不相交集 数据结构 • 不相交集可以用于等价性的动态查询。 • 等价性的查询在计算机科学中有广泛应用。例如，在编译器的设计中，用于 判断符号地址的等价性。 等价关系的增加对应Union操作，即将两个等价类合并 14 9.3 不相交集的存储实现 9.3 不相交集的存储实现 数据结构 • 不相交集数据结构定义： • • 例：考虑集合X={1, 2, 3, 4, 5, 6, 7, 8}。 • 合法的划分： {{1, 2, 3, 4, 5}, {6, 7}, {8}}或{{1} {2}, {3}, {4}, {5}, {6}, {7}, {8}}； • 以下不是集合X的划分: {{1, 2, 3, 4, 5}, {6, 7}}和{{1, 2, 3}, {3, 4, 5}, {5, 6, 7, 8}} 。 给定𝑛个元素组成的集合𝑋。不失一般性，令𝑋 = {1,2, … , 𝑛}。 不相交集的数据结构动态维护了集合𝑋的一组划分，即若干个不相交的集合 𝑋1, … , 𝑋𝑚，满足: • ∀𝑖 ≠ 𝑗, 𝑋𝑖 ∩ 𝑋𝑗 = ∅； • ∪𝑖=1 𝑚 𝑋𝑖 = 𝑋。 15 9.3 不相交集的存储实现 9.3 不相交集的存储实现 数据结构 不相交集的数据结构需要动态处理集合的合并和查询操作，其ADT定义如下： —————————————————————— 代码 9-1 不相交集的抽象数据类型定义 —————————————————————— ADT DisjointSet { 数据对象： 𝑛个元素构成的全集𝑋。 数据关系： {< 𝑖, 𝑗 > |𝑖, 𝑗 ∈ 𝑋}表示𝑖、𝑗属于同一个集合。 基本操作: InitSet(set, n)： 建立𝑛个不相交的集合𝑋1, … , 𝑋𝑛，其中每个集合初始只有一个元素：𝑋𝑖 = {𝑖}, ∀𝑖 = 1, … , 𝑛。 DestorySet(set)： 释放不相交集set所占用的所有空间。 Find(set, x)：查询元素x所在的集合。 Union(set, x, y)：合并元素x和元素y所在的集合。 } 16 9.3 不相交集的存储实现 9.3 不相交集的存储实现 数据结构 • 思考：Find操作查询元素所在的集合，输入是一个元素，输出是一个集合…… • 如何表示一个集合？ • 由于集合是动态变化的，难以实时给集合从1开始按顺序编号 • 技巧：规定每个集合中𝑋需要有一个“代表”元素𝑎 ∈ 𝑋，该元素的编号即为集 合编号，即 • 𝐅𝐢𝐧𝐝 𝒙 = 𝒂, ∀𝒙 ∈ 𝑿 • 例：对于划分{{1, 2, 3, 4, 5}, {6, 7}, {8}}，可规定集合{1, 2, 3, 4, 5}代表元素为1， 则Find(2)=Find(3)=Find(4)=Find(5)=1。 17 9.4 不相交集的基本运算实现 9.4 不相交集的基本运算实现 数据结构 • 不相交集可利用森林的数据结构实现： • 每个元素x只需维护其父亲结点x.parent。 • 特别地，规定根结点的父亲结点是其本身，即x.parent=x。 • 规定森林中的每棵树代表一个不相交集的集合，且其“代表”元素是 其根结点。 • InitSet操作只需定义𝑛棵仅含根结点的树，Find操作只需找到要查询的 元素x对应的根结点。而Union操作只需将x和y元素各自对应的根结点 合并。 18 9.4 不相交集的基本运算实现 9.4 不相交集的基本运算实现 数据结构 ————————————————— 算法9-1: 初始化不相交集InitSet(set, 𝑛) ————————————————— 输入：元素的数量n，不相交集set={1, 2, ..., n}。 输出：初始化后的集合set。 ————————————————— 1. for 每个元素 x∈ 𝑠𝑒𝑡 do 2. | x.parent ← x 3. end —————————————————————————————————— 算法9-2: 查找元素所在的集合Find(set, x) ————————————————— 输入：不相交集set中待查找的元素x。 输出：元素x所在树的根顶点。 ————————————————— 1. while x ≠ x.parent do 2. | x ← x.parent 3. end 4. return x ————————————————— —————————————————— 算法9-3: 合并两个元素所在的集合Union(set, x, y) —————————————————— 输入：不相交集set中的两个元素x和y。 输出：合并x和y各自所在集合后的不相交集set。 —————————————————— 1. 𝑖 ← Find 𝑠𝑒𝑡, 𝑥 2. 𝑗 ← Find 𝑠𝑒𝑡, 𝑦 3. i.parent ← j —————————————————— 19 9.4 不相交集的基本运算实现 9.4 不相交集的基本运算实现 数据结构 • 问题：在上述实现中，InitSet、Find、Union的操作时间复杂度均可达𝑂 𝑛 • 考虑森林退化成一条链的情况：𝑖. 𝑝𝑎𝑟𝑒𝑛𝑡 = 𝑖 − 1, ∀𝑖 = 2,3, … , 𝑛。 • 这种情况下，每次Find(set, 𝑛)均需要𝑂 𝑛 的时间复杂度，而每次Union(set, 𝑛 − 1, 𝑛)也需要𝑂 𝑛 的时间复杂度。 朴素的不相交集实现的最坏情况 1 2 n 3…… 20 9.4.1 按秩合并 9.4 不相交集的基本运算实现 数据结构 • 按秩合并策略为每个根结点x引入一个秩x.rank，根结点的秩反映了以该结点为根 的子树“大小”，考虑利用树的高度作为树的秩： • 对每个根节点𝑥，定义其秩𝑥. 𝑟𝑎𝑛𝑘为以𝒙为根的树的高度减一。 • 特别地，仅由单个结点构成的树的根结点秩为0。 • 在合并时总是把秩小的树根合并到秩大的树根：增加树的“宽度”而非“高度” • 在这种情况下，可保证树的“平衡性” ： • 深度为𝑙的子树至少有 𝟐𝒍 − 𝟏个结点。 21 9.4.1 按秩合并 9.4 不相交集的基本运算实现 数据结构 • 采取按秩合并策略后，InitSet和 Union操作的实现调整为算法9-4、 算法9-5： —————————————————— 算法9-4: 初始化采用按秩合并策略的不相 交集InitSet(set, 𝑛) —————————————————— 输入：元素的数量n，不相交集set={1, 2, ..., n}。 输出：初始化后的集合set。 —————————————————— 1. for 每个元素 x∈ 𝑠𝑒𝑡 do 2. | x.parent ← x 3. | x.rank ← 0 4. End —————————————————— —————————————————— 算法9-5: 利用按秩合并策略合并两个元素所 在的集合Union(set, x, y) —————————————————— 输入：不相交集set中的两个元素x和y。 输出：合并x和y各自所在集合后的不相交集set。 ————————————————— 1. 𝑖 ← Find 𝑠𝑒𝑡, 𝑥 2. 𝑗 ← Find 𝑠𝑒𝑡, 𝑦 3. if i. 𝑟𝑎𝑛𝑘 > 𝑗. 𝑟𝑎𝑛𝑘 then 4. | 𝑗. 𝑝𝑎𝑟𝑒𝑛𝑡 ← 𝑖 5. else if i. 𝑟𝑎𝑛𝑘 < 𝑗. 𝑟𝑎𝑛𝑘 then 6. | 𝑖. 𝑝𝑎𝑟𝑒𝑛𝑡 ← 𝑗 7. else //i. 𝑟𝑎𝑛𝑘 = 𝑗. 𝑟𝑎𝑛𝑘 8. | 𝑖. 𝑝𝑎𝑟𝑒𝑛𝑡 ← 𝑗 9. | 𝑗. 𝑟𝑎𝑛𝑘 ← 𝑗. 𝑟𝑎𝑛𝑘 + 1 10.end —————————————————— 22 9.4.1 按秩合并 9.4 不相交集的基本运算实现 数据结构 • 引理 9-1. 在采用按秩合并策略的不相交集算法运行过程中，对于任意子树，若 其根结点秩为r，则该子树中至少有2r个结点。 证明.利用归纳法，对子树根结点的秩r 进行归纳: 1. r = 0时子树中仅含一个结点， 命题成立。 2. 假设命题对所有不超过r − 1的 秩成立。考虑根结点root的秩为r > 0 的子树: 由于 𝐫 = 𝐫𝐨𝐨𝐭. 𝐫𝐚𝐧𝐤 > 𝟎，根结点 root的秩必然是与另一棵根为root' 的 树进行Union操作时设置而来。 不失一般性，设该次Union前有: root. 𝐫𝐚𝐧𝐤 = 𝒓𝒐𝒐𝒕 ′. 𝐫𝐚𝐧𝐤 = 𝐫 − 𝟏 否则该次Union前一定存在某次 Union(root, root’’)，且 root. 𝐫𝐚𝐧𝐤 = 𝐫𝐨𝐨𝐭’’. 𝐫𝐚𝐧𝐤 = 𝐫 −1； 而Union操作不会令树中的结点数目减 少。3. 由归纳假设，可知此时以root和root' 为根的子树中都各有至少𝟐 𝐫−𝟏个结点，故合 并后的子树中至少有𝟐 𝒓个结点。 4. 由归纳法，命题对所有r ∈ ℕ成立。 23 9.4.1 按秩合并 9.4 不相交集的基本运算实现 数据结构 • 每次Find、Union操作的时间复杂度取决于查找链的长度，即Find操作 找到的根结点的秩加一。 最坏情况下，全部的𝑛个结点构成一棵树。根据 引理9-1，该树根的秩不超过log 𝑛。因此，不相交集每次Find、Union操 作的时间复杂度为𝑂 log 𝑛 。 引理 9-1. 在采用按秩合并策略的不相交集算法运行过程中，对于 任意子树，若其根结点秩为r，则该子树中至少有2r个结点。 24 路径压缩 9.4.2 路径压缩 9.4 不相交集的基本运算实现 数据结构 • 假设某次查找时，路径深度过大，导致该次查找的时间成本很高。我们只需 调整森林的结构，将查找路径上的所有结点直接连接至根。 • 这样，下次查找这条路径上的结点时只需𝑂 1 时间即可完成。这个技巧称为 路径压缩（Path Compression）。 25 9.4.2 路径压缩 9.4 不相交集的基本运算实现 数据结构 利用路径压缩技巧，不相交集的查找可以重写成为算法9-6。该算法首先递归地查 找到根𝑟，之后逐层返回，并将路径上所有结点的父结点均设为𝑟。 路径压缩 —————————————————— 算法9-6: 以路径压缩策略查找元素所在的集 合Find(set, x) —————————————————— 输入：不相交集set中待查找的元素x。 输出：元素x所在树的根结点。 ————————————————— 1. if x ≠ x.parent then 2. | x.parent ← Find(set, x.parent) 3. end 4. return x.parent —————————————————— 26 9.4.2 路径压缩 9.4 不相交集的基本运算实现 数据结构 • 下图演示了同时采用按秩合并和路径压缩策略时，8个元素构成的不相交集的合并过程。 (*图中ir表示编号为i， 秩为𝑟的顶点) InitSet(8) {1}{2}{3}{4}{5}{6}{7}{8} 10 2 0 30 40 50 60 70 80 Union(6,2) {1,5}{2,6}{3}{4}{7}{8} 1 1 21 3 0 4 0 50 60 70 80 Union(5,1) {1,5}{2}{3}{4}{6}{7}{8} 1 1 2 0 3 0 4 0 5 0 6 0 7 0 8 0 {1,5} {2,6}{3}{4}{7}{8} 1 1 2 1 3 0 4 0 5 0 6 0 70 8 0 Union(6,5) {1,2,5,6}{3}{4}{7}{8} 1 2 21 3 0 4 0 5 0 6 0 7 0 80 {1,2,5,6}{3}{4}{7}{8} 1 2 2 1 3 0 4 0 50 6 0 70 80 {1,2,5,6}{3}{4}{7}{8} 1 2 2 1 30 70 5 0 60 4 0 8 0 {1,2,5,6}{3}{4}{7}{8} 1 2 21 3 0 7 0 50 6 0 40 80 Union(4,3) {1,2,5,6}{3,4}{7}{8} 12 21 31 70 5 0 6 0 4 0 8 0 Union(8,7) {1,2,5,6}{3,4}{7,8} 1 2 2 1 3 1 7 1 5 0 6 0 4 0 8 0 {1,2,5,6}{3,4}{7,8} 1 2 21 3 1 7 15 0 6 0 4 0 8 0 {1,2,5,6}{3,4,7,8} 1 2 2 1 3 2 7 15 0 6 0 4 0 8 0 Union(7,3) {1,2,3,4,5,6,7,8} 1 3 2 1 3 2 7 1 5 0 6 0 40 80 Union(3,6) {1,2,3,4,5,6,7,8} 13 6 0 3 2 7 1 5 0 2 1 4 0 8 0 采用了按秩合并和路径压缩的 不相交集运行示例 {1,2,5,6}{3,4,7,8} 12 2 1 3 2 7 1 5 0 6 0 4 0 8 0 初始时，所有结 点均不相连，结 点的秩均为0 Union(5, 1)时，两 结点具有相同的秩， 此时将5合并到1， 并将结点的秩置为1 Union(6, 5)时， 两棵秩为1的树 合并成为一棵秩 为2的树 Union(3, 6)时， 首先执行的 Find(6)进行了路 径压缩，将6直 接连接至1 合并操作将两 棵秩为2的树合 并成一棵秩为3 的树 树有𝟐^𝟑=𝟖个结点， 在可能出现的秩为3 的树中是结点数目最 少的 *此时2成为叶子结点， 但其秩未发生改变。 结点1的秩也仍是2 27 9.4.2 路径压缩 9.4 不相交集的基本运算实现 数据结构 • 实现不相交集非常简单，但分析其时间复杂度却非常困难。虽然单个操作 的时间复杂度较高，最坏可达 𝑶 𝒍𝒐𝒈 𝒏 。然而，由于路径压缩策略的存在， 每次访问完一条路径后，下次访问该路径上结点的时间复杂度就会降低， 因此算法整体的时间复杂度仍然较低。 28 9.4.2 路径压缩 9.4 不相交集的基本运算实现 数据结构 • 使用均摊分析技巧，考虑连续的𝑚个操作的总时间复杂度。 • 可证明,同时使用按秩合并和路径压缩后，𝑛个元素组成的不相交集上进 行𝑚次Find/Union操作的时间复杂度为𝑶 𝒎𝜶 𝒏 ，即每次操作的均摊时间 复杂度为𝑶 𝜶 𝒏 。其中： • 𝛼 𝑛 是增长非常缓慢的函数，对𝒏 < 𝟏𝟎𝟖𝟎均有𝜶 𝒏 ≤ 𝟒。 • 1080与可观测的宇宙中原子的数目具有相当的数量级。 • 因此，Find/Union操作几乎具有常数时间复杂度。 • 尽管如此，不能称Find/Union具有𝑂 1 的时间复杂度，因为 • 𝑛 → ∞时, 仍有𝛼 𝑛 → ∞ • 可证明𝑶 𝜶 𝒏 时间复杂度上界是紧的，即不相交集不存在𝑂 1 时间复 杂度的算法。 29 9.5 不相交集的应用：最近公共祖先问题 9.5 不相交集的应用 数据结构 • 在一棵树中，结点𝑢与结点𝑣的公共祖先是所有同 时是 𝑢 和 𝑣 祖先的结点，而其中深度最大（即离根最远） 的结点称为最近公共祖先。 • 给定任意两个结点u和v，公共祖先构成一条以根 结点为起点的链，而其中最近公共祖先是唯一的。 • 最近公共祖先LCA（Lowest Common Ancestor） 问题考虑𝑚个形如 𝑢, 𝑣 的查询，每次需要查询树𝑇中 结点𝑢和𝑣的最近公共祖先。 最近公共祖先问题蛮力算法的坏情况 30 9.5 不相交集的应用：最近公共祖先问题 9.5 不相交集的应用 数据结构 • LCA问题可用蛮力算法求解： • 首先，从结点𝑢回溯至根，将路径上每个结点 均做标记； • 然后，从结点𝑣回溯至根，路径上遇到的第一 个有标记的结点即为结点𝑢、𝑣的最近公共祖先。 • 然而，该蛮力算法的时间复杂度较高。 • 如图，若树𝑇中有𝑛个结点，则蛮力算法在最坏情 况下每次查询的时间复杂度可达𝑶 𝒏 。 最近公共祖先问题蛮力算法的坏情况 31 9.5 不相交集的应用：最近公共祖先问题 9.5 不相交集的应用 数据结构 • 求解最近公共祖先问题的离线算法（Tarjan算法） • 一次性返回所有𝑚个查询的结果，总时间复杂度仅为𝑂 𝑚𝛼 𝑛 + 𝑛 。 • Tarjan算法对树进行深度优先遍历，并按遍历的顺序处理询问。 • 若在遍历某结点𝑣时，关于该结点的询问 𝑢, 𝑣 的另一端点𝑢已被访问过(“闭询问”）， 则Tarjan算法立即处理该询问 • 否则，若𝑢尚未被访问（“开询问”），则将此询问留待访问𝑢时完成。 32 9.5 不相交集的应用：最近公共祖先问题 9.5 不相交集的应用 数据结构 • 记号：结点r的左子树记为L，右子树记为R。 • 基本事实：L中的结点u与R中的结点v，最近公共祖先一定是r。 • 关键：对于一批查询，如何批量地找到每一个查询(u, v)的最近公共祖先r的两个 子树？ • 答案：DFS! • 在DFS中，搜索过程对每个结点r有三次“接触”： • 第一次：访问该节点r • 第二次：该节点的左子树L访问完毕后，第一次回溯到该节点 • 第三次：该节点的右子树R访问完毕后，第二次回溯到该节点 33 9.5 不相交集的应用：最近公共祖先问题 9.5 不相交集的应用 数据结构 • 设算法已经访问完了根为 r 的子树 T1 ∈ T ，并且处理完毕了所有关于 T1 闭询问。 • 需要保留哪些信息以在未来处理T1的开询问呢？ • 不失一般性，考虑开询问 u, v ，其中u ∈ T1已经被访问，而v尚未被访问。 • 因为v不是子树T1中的结点（否则 u, v 应该是闭询问），所以 u, v 的LCA必然 不会是子树T1中的结点，最多只能是子树根r的父亲𝐫.parent。 • 因此，对于后续所有关于T1的开询问，保留子树的结构已无意义，我们可以 将子树中的所有结点合并到结点r.parent上。 • 在后续遍历中，r.parent代表子树T1中的所有结点，无需再考虑子树T1的具体 结构。 该合并操作可以用不相交集实现，如算法9-7。 34 9.5 不相交集的应用：最近公共祖先问题 9.5 不相交集的应用 数据结构 • 在DFS中，搜索过程对每个结点r有三次接触： • 第一次：访问该节点r • 第二次：该节点的左子树L访问完毕后，第一次回溯到该节点 • 第三次：该节点的右子树R访问完毕后，第二次回溯到该节点 • 观察访问次序：第二次结束时，可以得知L的所有元素！第二次和第三次之间，访问的结点都在 R中。 • 如果我们在第二次结束时，把所有L中的元素都合并到r中，然后在访问R期间，对于查询(𝑢 ∈ 𝐿, 𝑣 ∈ 𝑅)，都可以知道它们的最近公共祖先为r！ • Tarjan算法如何实现上述思想： • 第一次回溯到某个节点时，将它的左子树都合并到该节点上 • 第二次回溯到某个节点时，将它的右子树也合并到该节点上。 • 输出LCA(u,v)的时机：若u与v的最近公共祖先是r。1. u已经访问过，2. u所在r的左子树L已经被合并到了r 上。3. v的所有子树刚刚合并到v上，此时正好第三次接触到v。4. 尚未第三次接触到r，此时正在访问r的右 子树R。 35 9.5 不相交集的应用：最近公共祖先问题 9.5 不相交集的应用 数据结构 ——————————————————————— 算法9-7: Tarjan算法求解最近公共祖先 LCA(tree, P, u) ——————————————————————— 输入：树tree，查询集𝑃 = { 𝑢, 𝑣 }，当前结点𝑢。 输出：查询结果LCA。 ——————————————————————— 1. set←InitSet(n) // 初始化不相交集 2. ancestor[Find(set, 𝑢)]← u //初始化 3. for u的每个孩子v do 4. | LCA(set, tr𝑒𝑒, 𝑃, 𝑣) //深度优先遍历u的所有子树 5. | Union(set, 𝑢, 𝑣) //将子树并到根结点u 6. | ancestor[Find(set, 𝑢)]← u //记录这棵树的根是u 7. end 8. visited[𝑢]←true 9. for 𝑢, 𝑣 ∈ 𝑃的每个结点v do 10. | if visited[v] then 11. | | print ancestor[Find(set, 𝑣)] //输出u 和v的LCA 12. | end 13.End • 算法的执行过程中，我们维护了 两个数组visited和ancestor。 • 其中visited表示结点是否访问完 成，用以判断询问是否可完成。 • ancestor表示结点集合（子树） 的根。这是因为在采用了按秩合 并策略后，Find找到的“根”并 不一定是子树实际的根，因此需 要额外记录实际的根。 36 9.5 不相交集的应用：最近公共祖先问题 9.5 不相交集的应用 数据结构 • 右图是算法运行过程的示意图。 • 本例中有4个询问：分别为LCA(4,5)、 LCA(4,6)、 LCA(4,2)和LCA(4,7)。 • 右图中依次展示了结点4, 5, 3, 6, 2, 7的孩子访问完 成，即将输出LCA时刻的场景，对应算法9-7第7行。 调用栈 1 2 7 3 6 4 5 LCA(1) 调用栈 1 2 7 3 6 4 5 LCA(2) LCA(1) 调用栈 1 2 7 3 6 4 5 LCA(3) LCA(2) LCA(1) 调用栈 1 2 7 3 6 4 5 LCA(4) LCA(3) LCA(2) LCA(1) 调用栈 1 2 7 3 6 4 5 LCA(4) LCA(3) LCA(2) LCA(1) 调用栈 1 2 7 6 5 LCA(4) LCA(3) LCA(2) LCA(1) Ancestor=3 （3,4） 调用栈 1 2 7 3 6 4 5 LCA(4) LCA(3) LCA(2) LCA(1) 调用栈 1 2 7 6 5 LCA(3) LCA(2) LCA(1) Ancestor=3 （3,4） 调用栈 1 2 7 6 5 LCA(5) LCA(3) LCA(2) LCA(1) Ancestor=3 （3,4） 调用栈 1 2 7 6 LCA(3) LCA(2) LCA(1) Ancestor=3 （3,4,5） 调用栈 1 2 7 6 LCA(5) LCA(3) LCA(2) LCA(1) Ancestor=3 （3,4,5） 输出LCA(4,5)=3 调用栈 1 2 7 6 LCA(3) LCA(2) LCA(1) Ancestor=3 （3,4,5） 调用栈 1 7 6 LCA(3) LCA(2) LCA(1) Ancestor=2 （2,3,4,5） 调用栈 1 7 6LCA(2) LCA(1) Ancestor=2 （2,3,4,5） 调用栈 1 7 6 LCA(6) LCA(2) LCA(1) Ancestor=2 （2,3,4,5） 调用栈 1 7 LCA(6) LCA(2) LCA(1) Ancestor=2 （2,3,4,5,6） 输出LCA(4,6)=2 调用栈 1 7 LCA(2) LCA(1) Ancestor=2 （2,3,4,5,6） 输出LCA(4,2)=2 调用栈 1 7 LCA(2) LCA(1) Ancestor=2 （2,3,4,5,6） 调用栈 1 7 LCA(2) LCA(1) Ancestor=2 （2,3,4,5,6） 调用栈 7 LCA(2) LCA(1) Ancestor=1 （1,2,3,4,5,6） 调用栈 7 LCA(1) Ancestor=1 （1,2,3,4,5,6） 输出LCA(4,7)=1 调用栈 7 LCA(7) LCA(1) Ancestor=1 （1,2,3,4,5,6） 算法首先从根结点 开始遍历经过结点 1, 2, 3, 4 在结点4遍历完成 后，将其合并至父 亲3。此时结点3、 4同属于一个集合。 以此类推，算法不 断合并遍历路径上 的结点，并正确计 算LCA。 *取决于不相交集的实现，3、4均可能 是该集合的代表元素。不失一般性设 Find(3)=Find(4)=3，则此时 ancestor[3]=3。 *算法输出(4, 5)的LCA为 ancestor[Find(4)]=ancestor[3]=3 37 9.7 应用场景:面向对象的编程语言 9.7 应用场景 数据结构 不相交集在许多计算机科学的真实问题上有应 用。如离线最小值查询，求控制流图的支配树，类 型推断，实现属性文法（Property Grammar）等。 近年来，该数据结构在图像处理，数据库和量子计 算等领域也有应用。 这里介绍不相交集在面向对象的编程语言中的 应用。 三个类间的继承关系 38 9.7 应用场景:面向对象的编程语言 9.7 应用场景 数据结构 面向对象的编程语言中，变量的类型可以是用 户定义的类（class），类之间可以有继承关系。 例如说，下列C++代码定义了People、Teacher、 Student三个类，其继承关系如图。 class Person { ... }; class Teacher : public Person { ... }; class Student : public Person { ... }; 三个类间的继承关系 39 9.7 应用场景:面向对象的编程语言 9.7 应用场景 数据结构 假如我们定义了如下二元运算Talk： string talk(Person a, Person b); string talk(Teacher a, Teacher b); string talk(Student a, Student b); 不同类别之间的Talk函数可以有不同行为。 例如，任意两个Person都可以谈论天气，而只有 两个Student才会讨论功课。 三个类间的继承关系 40 9.7 应用场景:面向对象的编程语言 9.7 应用场景 数据结构 注意，这里我们没有定义两个参数分别是 Teacher和Student的Talk函数。 假如有一个Teacher类型的变量alice和一个 Student类型的变量bob，此时若调用talk(alice, bob)会发生什么呢？ 实际上，编译器会寻找两个类的最近公共祖 先，来调用两个People之间的Talk函数。而最近 公共祖先问题又可以用不相交集来解决。 三个类间的继承关系","libVersion":"0.5.0","langs":""}