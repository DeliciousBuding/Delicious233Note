{"path":"01 数据结构和算法/2025春季学期/PPT/第11章-查找.pdf","text":"数据结构 计算机领域本科教育教学改革试点 工作计划（“101计划”）研究成果 授课教师：张羽丰 湖南大学 信息科学与工程学院 查找 第 11 章 11.1 问题引入：收集通讯录 11.2 查找的定义 11.3 静态查找表 11.4 动态查找表 11.5 散列方法 11.6 查找的应用 11.8 应用场景：词频统计 4 • 在手机通信录中查找联系人的信息 ▪ 当联系人较多时如何提高查找效率。 11.1 问题引入 11.1 问题引入 5 11.2 查找的定义 11.2 查找的定义 • 查找是数据结构中最基本的操作 • 用于查找的数据结构称为查找表 • 查找就是确定指定关键字值的数据元素或记录在查找表中是否存在 • 查找表 • 静态查找表：表中数据元素的个数和值均不变 • 如字典 • 动态查找表：表中数据元素的个数和值会发生变化 • 如手机通讯录，不仅要求查找迅速，插入、删除操作也续效率高 6 11.2 查找的定义 查找的定义 • 查找的分类 • 内查找：被查找的元素全部存放在内存中的查找 • 一般以关键字的比较次数作为衡量时间性能的标准 • 外查找：数据元素太多，部分数据元素存放在外存中的查找 • 与外存访问相比，比较的时间微不足道 • 一般以外存的访问次数作为衡量标准 7 11.2 查找的定义 内查找算法效率评价 • 检索运算的主要操作：关键码的比较 • 效率评价：平均检索长度（Average Search Length） – 检索过程中对关键码的平均比较次数 – 衡量检索算法优劣的时间标准 • ASL成功——成功情况下的平均查找长度 • ASL不成功——不成功情况（失败）下的平均查找长度  = = n i iiCPA SL 1 • n是查找表中元素的个数。 • pi是查找第i个元素的概率，一般地，认为每个 元素的查找概率相等，即pi=1/n(1≤i≤n)。 • ci是找到第i个元素所需进行的比较次数。 8 11.2 查找的定义 平均查找长度 • ASL成功：找到T中任一元素平均需要的关键字比较次数 • 例：n=9，采用顺序表存储，每个元素查找的概率相等 关键字 5 1 4 8 7 9 2 4 3 找到时的比 较次数 1 2 3 4 5 6 7 8 9 ASL成功= 1+2+3+4+5+6+7+8+9 9 = 5 9 11.2 查找的定义 平均查找长度 • ASL不成功：查找失败时（在T中未查找到）平均需要的关键 字比较次数。 • 例：n=9，采用顺序表存储，每个元素查找的概率相等 x  T 通过关键字比较后确定不在T中 平均关键字比较次数 关键字 5 1 4 8 7 9 2 4 3 找不到时的 比较次数 9 9 9 9 9 9 9 9 9 • 按顺序查找， ASL不成功= n = 9 10 11.2 查找的定义 平均查找长度 ⚫ 例：假设线性表为（a, b, c）检索a、b、c的概率分别为0.4、 0.1、0.5，顺序检索算法的平均检索长度为？ 0.4×1+0.1×2+0.5×3 = 2.1 – 即平均需要2.1次给定值与表中关键码值的比较才能找到待查元素 11 11.3 静态查找表 11.3 静态查找表 • 典型的静态查找技术 • 采用线性结构作为查找表的查找算法 • 顺序查找 • 索引查找 • 二分查找 12 11.3 静态查找表 11.3.1 顺序查找 • 针对线性表里的所有记录，逐个进行关键码和给定值的比较 。 • 若某个记录的关键码和给定值比较相等，则检索成功 ； • 否则检索失败(找遍了仍找不到)。 • 存储 • 顺序表（数组）或链接 • 排序要求 • 无 13 11.3 静态查找表 示例 • 检索key=64 60 21 37 88 19 92 05 56 80 75 13 0 1 2 3 4 5 6 7 8 9 10 11 Key=64找到 64 14 11.3 静态查找表 顺序检索的伪代码描述 • 伪代码描述 // Return true if K is in list bool find(List<int> & L, int K) { for (L.moveToStart(); L.currPos() != L.length(); L.next()) { int it = L.getValue(); if (K == it) return true; // found it } return false; // not found } 15 11.3 静态查找表 顺序查找的时间性能 • 检索成功 • 假设检索每个关键码是等概率的，即Pi = 1/n，则该线性表的检索代 价为：𝑪𝒏 = 𝟏 𝒏 σ𝒊=𝟏 𝒏 𝒊 = 𝒏+𝟏 𝟐 • 检索失败 • 检索失败时都需要比较n次 • 顺序检索平均检索长度ASL • 假设检索失败的概率为p，检索成功的概率为q=(1-p)，则： • ASL = pn + (1-p)(n+1)/2 = (n+1+p(n-1))/2 • (n+1)/2 <= ASL <=n 16 11.3 静态查找表 顺序查找的特点 • 优点 • 采用线性结构存储，非常简单 • 无有序要求，不需要排序 • 缺点 • 平均查找长度大，时间复杂度为O(n) • 不适用与元素较多的查找 17 11.3 静态查找表 11.3.2 二分查找 • 二分查找，又称折半查找 • 要求查找表中的数据按关键字值有序排列 • 待检索值K，每次与中间记录的关键码Key进行比较 • K = Key，检索成功，返回 • K < Key, 一定在前半部分 • K > Key，一定在后半部分 • 每次缩小一半的搜索空间 18 11.3 静态查找表 二分法查找图示 • 查找关键码=18，low=1, high=9 35 1 2 3 4 5 6 7 8 9 15 22 51 60 88 93 low mid high 1817 第一次：l=1, h=9, mid=5; array[5]=35>18 第二次：l=1, h=4, mid=2; array[2]=17<18 第三次：l=3, h=4, mid=3; array[3]=18＝18 19 11.3 静态查找表 二分法查找——递归 template <typename Type> int BinSearch (vector<Type>& dataList, Type k, int low, int high){ if (low > high) //检索失败，返回-1 return -1 mid=(low+high)/2; if (k == dataList[mid]) //成功返回位置 return mid; else if (k < dataList[mid]) //左半部分 return BinSearch(dataList, k, low, mid - 1); else //右半部分 return BinSearch(dataList, k, mid + 1, high) } 20 11.3 静态查找表 二分法查找——循环 template <typename Type> int BinSearch (vector<Type>& dataList, Type k){ int low=0, high=dataList.size() - 1, mid; while (low<=high) { mid=(low+high)/2; if (k < dataList[mid]) high = mid-1; //左半部分 else if (k > dataList[mid]) low = mid+1; //右半部分 else return mid; //成功返回位置 } return -1; //检索失败，返回-1 } 21 11.3 静态查找表 二分查找的平均查找长度 • 假设： n=11 6 3 9 1 4 2 5 7 8 10 11 判定树 12 23 3 3 34 4 4 4 i 1 2 3 4 5 6 7 8 9 10 11 Ci 1 2 3 4 22 11.3 静态查找表 二分查找的平均查找长度 • 表长为n的二分查找的判定树的深度和含有n个结点的完全 二叉树的深度相同。 • 假设n=2h-1 并且查找概率相等,则 • 在n>50时，可得近似结果  )1(logh 2 += n 1)1(log 1 2 11 2 1 1 1 −+ + =      ==  = − = n n n j n C n ASL h j j n i ibs 1)1(log 2 −+ nASLbs 23 11.3 静态查找表 二分查找的特点 • 要求 • 必须采用顺序存储结构 • 必须按关键字大小有序排列 • 适用于不经常变动而查找频繁的有序列表 • 优点 • 比较次数少，查找速度快，平均性能好 • 时间复杂度为O(logn) 24 11.3 静态查找表 11.3.3 索引查找 • 动机 • 大规模集合的顺序查找效率低 • 二分查找不适用于未排序文件的查找 • 索引查找，又称分块查找 • 把一个大的线性表分解成若干块，块内元素可以无序，但块与块 之间必须有序 • 然后，构建一个有序的索引表 • 查找时，先通过索引表查找合适的块，然后在该块中进行顺序查 找 25 11.3 静态查找表 索引查找 • 索引表的构建 • 抽取各块中的最大关键字及其起始位置构成一个索引表 • 由于表R是分块有序的，所以索引表是一个递增有序表 14 31 8 22 18 43 62 49 35 52 88 78 71 83 101 2 3 4 5 6 7 8 9 11 12 13 14 1 6 11 31 62 88 查找表 索引表 指针字段（起始地址） 关键码字段（块内最大值） 块内最小值 是否可以 26 11.3 静态查找表 索引查找 • 查找过程 • （1）首先查找索引表 • 索引表是有序表，可采用二分查找或顺序查找，以确定待查的结点在哪一块 • （2）在已确定的块中进行顺序查找 • 由于块内无序，只能用顺序查找 14 31 8 22 18 43 62 49 35 52 88 78 71 83 查找52 101 2 3 4 5 6 7 8 9 11 12 13 14 1 6 11 31 62 88 查找表 索引表 指针字段（起始地址） 关键码字段（块内最大值） 27 11.3 静态查找表 分块查找的性能分析 • 时间开销 • 查找的时间开销包括：索引表的查找和块内查找 • 设表长为n，每块s个元素，共分成b个块，即b=ceil(n/s) • 如果索引表中采用顺序查找，则： ASL = （n/s + 1) / 2 + (s + 1）/ 2 =(n/s + s)/2 + 1 • 如果索引表中采用二分查找，则： ASL = log2(n/s +1)-1+(s+1)/2= log2(n/s + 1) + (s - 1)/2 • 空间开销 • 需要存储索引的辅助数组 28 11.4 动态查找表 11.4 动态查找表 • 动态查找表：查找表结构在查找过程中动态变化 • 二叉查找树 • AVL树 29 11.4 动态查找表 二叉查找树（Binary Search Tree） • 定义：二叉检索树或者为空，或者满足下列条件的非空二叉树 • （1）若它的左子树非空, 则左子树上所有结点的值均小于根结点的 值 • （2）若它的右子树非空, 则右子树上所有结点的值均大于或等于根 结点的值 • （3）左右子树本身又各是一棵二叉检索树 78 54 82 37 65 87 85 9423 45 30 11.4 动态查找表 二叉查找树（Binary Search Tree） • 性质 • 中序遍历，将得到按照从小到大的排列 78 54 82 37 65 87 85 9423 45 中序遍历序列： 23, 37, 45, 54, 65, 78, 82, 85, 87, 94 31 11.4 动态查找表 查找 • 查找key = 32 • 查找key = 38 37 24 7 32 2 40 42 42 80 32 11.4 动态查找表 查找 template <typename Key, typename E> E BST<Key, E>::findhelp (BSTNode<Key, E>* root, const Key& k) const { if (root == NULL) return NULL; // Empty tree if (k < root->key()) return findhelp(root->left(), k); // Check left else if (k > root->key()) return findhelp(root->right(), k); // Check right else return root->element(); // Found it } • 通过递归实现 33 11.4 动态查找表 查找 • 通过循环实现 template <typename Key, typename E> E BST<Key, E>::findhelp (BSTNode<Key, E>* root, const Key& k) const { while (root != NULL) { if (k < root->key()) root = root->left(); // Check left else if (k > root->key()) root = root->right() // Check right else return root->element(); // Found it } } 34 11.4 动态查找表 插入 • 插入新结点要符合二叉检索树的定义 • 插入操作在查找不成功时才进行 • 将新结点的关键码值key与树根的关键码值比较 • 若新结点的key小于树根的key，则进入左子树； • 否则，进入右子树； • 在子树中又与子树根的key进行比较，依此类推，直至把新结 点插入到二叉树中作为一个新的叶结点。 35 11.4 动态查找表 插入 • 插入key=35 37 24 7 32 2 40 42 42 8035 新插入的 节点一定 是叶结点 36 11.4 动态查找表 插入--递归 template <typename Key, typename E> BSTNode<Key, E>* BST<Key, E>::inserthelp (BSTNode<Key, E>* root, const Key& k, const E& it) { if (root == NULL) // Empty tree: create node return new BSTNode<Key, E>(k, it, NULL, NULL); if (k < root->key()) { BSTNode<Key, E> *node = inserthelp (root->left(), k, it); root->setLeft(node); } else { BSTNode<Key, E> *node = inserthelp (root->right(), k, it); root->setRight(node); } return root; // Return tree with node inserted } 37 11.4 动态查找表 插入 -- 非递归 template <typename Key, typename E> BSTNode<Key, E>* BST<Key, E>::inserthelp (BSTNode<Key, E>* root, const Key& k, const E& it) { if (root == NULL) // Empty tree: create node return new BSTNode<Key, E>(k, it, NULL, NULL); BSTNode<Key, E>* parent = root， *node = root; while (node!= NULL) { parent = node; if (k < root->key()) node = node->left(); // Check left else if (k > root->key()) node = node->right() // Check right } node = new BSTNode<Key, E>(k, it, NULL, NULL); if (k < parent->key()) parent->setLeft(node); else parent->setRight(node); return root; // Return tree with node inserted } 38 11.4 动态查找表 删除 • 删除一个结点R，首先必须找到R，接着将它从二叉树中删除 • 分三种情况： • （1）被删除的结点是叶子 • （2）被删除的结点只有左子树或者只有右子树 • （3）被删除的结点既有左子树，也有右子树 39 11.4 动态查找表 删除 • 被删除的结点R是叶子结点 • 将R的父结点指向它的指针改为NULL 其双亲结点中相应指针域的值改为“空” 37 24 7 32 2 40 42 41 80 40 11.4 动态查找表 删除 • 被删除的结点R只有左子树或者只有右子树 • 将R的父节点指向它的指针改为指向R的子节点 37 24 7 32 2 40 42 41 80 41 11.4 动态查找表 删除 • 被删除的结点R既有左子树，又有右子树 • 以结点R的前驱或后继结点替代之，再删除该前驱或后继结点 • 前驱：左子树的最大值，后继：右子树的最小值 37 24 7 32 28 40 44 41 43 以后继结点替代以前驱结点替代 42 11.4 动态查找表 删除的伪代码 template <typename Key, typename E> BSTNode<Key, E>* BST<Key, E>::remove (BSTNode<Key, E>* rt, const Key& k) { if (rt == NULL) return NULL; // k is not in tree if (k < rt->key( ) ) rt->setLeft ( remove(rt->left( ), k)); else if (k > rt->key()) rt->setRight ( remove(rt->right( ), k)); else { // Found: remove it rt = _removehelp( rt ); } return rt; } 递归调用，从当前rt为根的 子树上删除元素k，并返回 删除元素后的树根 43 11.4 动态查找表 删除的伪代码 template <typename Key, typename E> BSTNode<Key, E>* BST<Key, E>::_removehelp (BSTNode<Key, E>* rt) { BSTNode<Key, E>* temp = rt; if (rt->left( ) == NULL) { rt = rt->right(); } else if (rt->right() == NULL) { rt = rt->left(); } else { // Both children are non-empty temp = getmin(rt->right( )); rt->setElement ( temp->element() ); rt->setKey (temp->key()); rt->setRight ( deletemin(rt->right())); } delete temp; return rt; } 删除根节点rt，调整元 素，并返回新的根节点 44 11.4 动态查找表 删除的伪代码 • getmin：查找子树中的最小元素结点（往左下方走到最后） template <typename Key, typename E> BSTNode<Key, E>* BST<Key, E>::getmin(BSTNode<Key, E>* rt) { if (rt->left() == NULL) return rt; else return getmin(rt->left( ) ); } template <typename Key, typename E> BSTNode<Key, E>* BST<Key, E>::getmin(BSTNode<Key, E>* rt) { while(rt->left() != nullptr) rt = rt->left(); return rt; } 递归 非递归 45 11.4 动态查找表 删除的伪代码 • deletemin：删除子树中的最小值 • 递归实现 template <typename Key, typename E> BSTNode<Key, E>* BST<Key, E>:: deletemin (BSTNode<Key, E>* rt) { if (rt->left() == NULL) // Found min return rt->right( ); else { // Continue left rt->setLeft( deletemin(rt->left( ) ) ); return rt; } } 删除rt为根的子树上的 最小值，并返回删除后 的子树的根节点指针 46 11.4 动态查找表 删除的伪代码 • deletemin：删除子树中的最小值 • 非递归实现 template <typename Key, typename E> BSTNode<Key, E>* BST<Key, E>:: deletemin (BSTNode<Key, E>* rt) { if (rt->left() == nullptr) //no left child, found min return rt->right(); BSTNode<Key, E>* temp = rt->left(), *parent = rt; while (temp->left() != NULL) { // Found min parent = temp; temp = temp->left(); } parent->setLeft(temp->right()); return rt; } temp parent 删除rt为根的子树上的最 小值，最小值一定没有 左子树，比较容易删除 47 11.4 动态查找表 删除 • 如何将getmin和deletemin 在一次遍历中实现？ • 在结点中维护parent指针 • 在getmin函数中返回parent结点 48 11.4 动态查找表 查找性能分析 • 查找性能分析 • 比较的次数依赖于树的高度 • 当左右子树的高度差别不大（平衡）时，平均查找复杂度为 O(logn) • 若二叉查找树不平衡时，如只存在一个子树，二叉查找树退化成 一个链表，此时，时间复杂度为O(n) 2 1 3 4 5 49 11.4 动态查找表 11.4.2 AVL树 • AVL树是平衡二叉树的一种 50 11.4 动态查找表 AVL树的定义 • AVL树的定义 • 一棵AVL树或者是空树，或者是具有下列性质的二叉搜索树 • 它的左子树和右子树都是AVL树， • 且左子树和右子树的高度之差的绝对值不超过1。 63 73 70 55 67 42 85 7210 45 58 (a) 平衡二叉树 (b) 非平衡二叉树 -1 1 0 00 00 0 0 80 87 0 -1 -1 1 86 0 63 7355 42 85 10 45 -1 2 0 0 0 87 -3 -2 1 86 0 AVL树 非AVL树 51 11.4 动态查找表 平衡因子（Balance Factor） • 平衡因子 • 各结点左子树的高度 - 右子树的高度 • 根据AVL树的定义 • AVL树的任一结点的平衡因子只能为：1，-1， 0 • 如果一棵AVL树有n个结点，其高度可保持在O(log2n)， 平均搜索长度也可保持在O(log2n) 52 11.4 动态查找表 AVL树结点的实现 template<typename Elem> class AVLNode { // AVL树结点的定义 …… // 除balance外，其它同前面的定义 int _height; // 树的高度, default = 1 void setHeight(int height) { _height = height; } void updateHeight() {// 根据两颗子树的高度，更新根节点高度，局部更新，非递归调用！ int lh = left() ? left()->height(): 0; int rh = right()? right()->height(): 0; _height = max(lh, rh) + 1; } void balance() {// 计算平衡因子 int lh = left() ? left()->height(): 0; int rh = right()? right()->height(): 0; return lh - rh; } }; 53 11.4 动态查找表 AVL树查找 • AVL的查找与二叉检索树BST完全一致 • 若查找的值 < 根结点的值，则递归的查找左子树 • 若左子树为空，则查找失败 • 若查找的值 > 根结点的值，则递归的查找右子树 • 若右子树为空，则查找失败 • 若查找的值 == 根结点的值，则查找成功 54 11.4 动态查找表 AVL树插入 • 按照二叉查找树的插入过程进行 • 若新插入的结点，造成了二叉查找树的不平衡，必须调整树的结 构，使之平衡化 • 插入元素后，从下到上更新高度 • 找到最深的不平衡的节点 • 确定不平衡的种类 • 左子树的左孩子 • 右子树的右孩子 • 左子树的左孩子 • 右子树的右孩子 左子树的左孩子 右子树的右孩子 左子树的右孩子 右子树的左孩子 最深的不平衡节点 55 11.4 动态查找表 平衡化旋转 • 针对不平衡结点进行平衡化旋转 • 1. 左子树的左孩子：右单旋转，或称LL单旋 h+1 h h h+1 h h 56 11.4 动态查找表 LL单旋算法 • LL单旋 AVLNode<Type> * AVLTree<Type>::LLSingleRotation( AVLNode<Type> *root) { //LL单旋转的算法 auto new_root = root->left(); root->setLeft(new_root->right()); new_root->setRight(root); //更新结点的高度 root->updateHeight(); newroot->updateHeight(); return new_root; } new_root root new_root root 57 11.4 动态查找表 平衡化旋转 • 针对不平衡结点进行平衡化旋转 • 2. 右子树的右孩子：左单旋转，或称RR单旋 k1 k2 Z YX k1 k2 Z Y X RR单旋转 h+1 h h h+1 h h 58 11.4 动态查找表 RR单旋算法 • RR单旋 AVLNode<Type> * AVLTree<Type>::RRSingleRotation(AVLNode<Type> *root) { //RR单旋转的算法 auto new_root = root->right(); root->setRight(new_root->left()); new_root->setLeft(root); //更新结点高度 root->updateHeight(); newroot->updateHeight(); return new_root; } c p Z Y X RR单旋转 c p Z YX new_root root new_root root 59 11.4 动态查找表 平衡化旋转 • 针对不平衡结点进行平衡化旋转 • 3. 左子树的右孩子：先RR单旋，后LL单旋，或称LR双旋 以k2为中心左旋 以k2为中心右旋 60 11.4 动态查找表 LR双旋算法 • LR双旋 AVLNode<Type> *AVLTree<Type>::LRDoubleRotation( AVLNode<Type> *root) { //LR双旋的算法 auto temp = RRSingleRotation(root->left()); root->setLeft(temp); auto new_root = LLSingleRotation(root); return new_root; } 61 11.4 动态查找表 平衡化旋转 • 针对不平衡结点进行平衡化旋转 • 4. 右子树的左孩子：先LL单旋，后RR单旋，或称RL双旋 以k2为中心右旋 以k2为中心左旋 62 11.4 动态查找表 RL双旋算法 • RL双旋 AVLNode<Type> *AVLTree<Type>::RLDoubleRotation(AVLNode<Type> *root) { //RL双旋的算法 auto temp = LLSingleRotation(root->right()); root->setRight(temp); auto new_root = RRSingleRotation(root); return new_root; } 63 11.4 动态查找表 例子 • 输入关键码序列为 { 16, 3, 7, 11, 9, 26, 18, 14, 15 }，插入和调整 过程如下 0 012 16 0-1 3 70 0-1-2 左右双旋 7 3 012 16 0 0 9 0 1 右单旋 -1 3 -2 7 0-1 169 0 -1 26 11 0 11 0 16 7 3 64 11.4 动态查找表 例子 1 01 18 0 -2 3 16 01 0 16 右左双旋 7 3 9 0 0 18 26 1 11 7 3 0-1 26 16 11 9 左单旋 9 14 0 -1 7 11 26 18 0 -1 3 -2 7 0-1 169 0 -1 26 11 0 0 65 11.4 动态查找表 例子 15 18 -2 3 18 16 2 左右双旋 7 3 0 0 0 11 7 14 9 1 16 15 0 -1 11 26 26 14 -1 2 9 14 3 18 16 7 15 9 11 26 66 11.4 动态查找表 AVL树的插入 bool AVLTree::Insert(const Elem& value) { // 1. 按照二叉搜索树的规则插入新节点 if (nullptr == _root) { // 空树 _root = new AVLNode(value); } else { // 非空，按照二叉搜索树的特性查找待插入节点在树中的位置 AVLNode* cur = _root, *parent = nullptr; while (cur) { // 找到应该插入的位置 parent = cur; if (value < cur->_value) cur = cur->left(); else if (value > cur->_value) cur = cur->right(); else return false; // 存在相同的key } cur = new AVLNode(value); // 插入新节点 if (value < parent->_value) parent->setLeft(cur); else parent->setRight(cur); // 2. 调整，从而满足平衡性 AVLNode* p = checkBalance(cur); // get non-balance node && update balance if (p != nullptr) adjustBalance(p); // 调整，从而满足平衡性 }} 67 11.4 动态查找表 AVL树的插入 AVLNode *AvlTree::adjustBalance(AVLNode *root) { AVLNode* new_root = nullptr; if (root->balance() > 1) { AVLNode* c = root->left(); if (c->balance() >= 0) // LL new_root = LLSingleRotation(root); else // LR new_root = LRDoubleRotation(root); } else { AVLNode* c = root->right(); if (c->balance() <= 0) // RR new_root = RRSingleRotation(root); else // RL new_root = RLDoubleRotation(root); } return new_root; } 68 11.4 动态查找表 AVL树的插入 AVLNode* AvlTree::checkBalance(AVLNode *curr) { while (curr) { auto p = curr->parent(); if (!p) break; // new inserted node is root p->updateHeight();//根据子树高度，局部更新当前节点高度 int balance = p->balance(); if (balance == 0) // height of subtree is not changed break; if (abs(balance) > 1) { // the first non-balance node return p; } curr = p; } return nullptr; } 0 3 -1 01 -1 7 0 169 10 11 0 0 2 69 11.4 动态查找表 AVL树的删除 • 1. 按照BST的删除方式进行删除：删除一个结点R，首先必须找 到R，接着将它从二叉树中删除 • 如果R是一个叶子结点 • 那么只要将R的父结点指向它的指针改为NULL就可以了 • 如果R只有一个子结点 • 将R的父结点指向它的指针改为指向R的子结点 • 如果R有两个子结点 • 用右子树的最小值来代替它 • 2. 调整删除后结点的平衡性 70 11.4 动态查找表 AVL树的删除 • 2. 调整删除后结点的平衡性 • 删除叶子结点后的不平衡情况，有四种情况 • 左子树的左孩子 • 右子树的右孩子 • 左子树的左孩子 • 右子树的右孩子 左子树的左孩子（LL） 右子树的右孩子（RR） 左子树的右孩子（LR） 右子树的左孩子（RL） × × × × 71 11.4 动态查找表 AVL树的删除 • 删除叶子结点 删除叶子节点后无需调整的情况 删除叶子节点后需要调整的情况 72 11.4 动态查找表 AVL树的删除 • 删除带有一个子节点的结点 2015 8 25 17 16 RL双旋 平衡因子<0：右 20 17 10 8 25 15 16 1 20 17 8 25 15 16 1删除结点后 -2 平衡因子>0：左 20 178 25 15 16 无需调整的情况 需要调整的情况 73 11.4 动态查找表 AVL树的删除 • 删除带有两个子节点的结点 • 选择右子树的最小值替换待删除节点后，等价于删除带 有一个子节点的结点 74 11.4 动态查找表 AVL树的删除 • 删除节点，并进行一次调整后，可能依然不平衡，需递归 的调整AVL树的平衡性 8 2515 30 20 17 16 23 22 26 40 35 2516 15 30 20 17 23 22 26 40 35 RL双旋 -2 1 -2 -1 75 11.4 动态查找表 AVL树的删除 • 删除节点，并进行一次调整后，可能依然不平衡，需递归 的调整AVL树的平衡性 2516 15 30 20 17 23 22 26 40 35 25 16 15 3020 17 23 22 26 40 35 RR单旋 -1 -2 76 11.4 动态查找表 AVL树的删除 Elem AVLTree::Remove(const Key& key) { AVLNode* node = BSTree::find(key); // 1. 按照二叉搜索树的规则查找 if (node) { // 查找成功 Elem it = node->element(); if (node->left() && node->right()) { // case 3: 两个非空孩子结点 auto minNode=getMin(node->right()); // minimum node in right subtree node->setElement(minNode->element()); node->setKey(minNode->key()); // convert to case 1 and 2: at least one child is empty node = minNode; } //case1 and 2: at least one child is empty removeHelp(node); delete node; return it; } return Elem(); // 查找失败 } 77 11.4 动态查找表 AVL树的删除 void AVLTree::removeHelp(AVLNode *rt) { AVLNode* temp = rt; // at least one children is empty if (rt->left() == nullptr || rt->right() == nullptr) { auto p = rt->parent(); if (rt->left() == nullptr) //获取非空子节点 rt = rt->right(); else if (rt->right() == nullptr) rt = rt->left(); if(!p) setRoot(rt) else //删除的为根结点，设置rt为新的根结点 temp == p->left() ? p->setLeft(rt) : p->setRight(rt); //调整父子关系 auto node = p; while (node) { //adjust in recursive mode node->updateHeight(); node = adjustBalance(node); if (node) node = node->parent(); }} 78 11.4 动态查找表 代码实现 • 可视化 • https://www.cs.usfca.edu/~galles /visualization/Algorithms.html 79 11.5 散列方法 11.5 散列方法 • 前述检索方法：给定值依次和集合中各个关键字比较 • 查找效率取决于和给定值进行关键字比较的次数 • 平均查找长度依赖于数据的个数n • 原因：记录在表中的存储位置和它的关键字之间不存在一个确定 的关系 • 能否做到平均查找长度ASL=1？ • 构建关键字与存储位置之间的对应关系 关键字 存储地址 映射关系 80 11.5 散列方法 11.5.2 散列函数 • 散列函数 • 构建关键码与记录的存储位置的映射关系，使每个关键码与结构 中一个唯一的存储位置相对应 • Address ＝ Hash ( key ) 关键字集合A m 地址空间D n 哈希函数 H(key) 81 11.5 散列方法 散列函数性质 • 散列函数是一个映射，即： • 将关键字的集合映射到某个地址集合上，它的设置灵活，只要这个 地址集合的大小不超出允许范围即可 • 散列函数是一个压缩映射，因此，在一般情况下，很容易 产生冲突现象 • key1 key2，而f(key1)=f(key2) • 很难找到一个不产生冲突的散列函数。 • 一般情况下，只能选择恰当的散列函数，使冲突尽可能少地产生。 • 拟定解决冲突的方案 82 11.5 散列方法 散列表 • 散列表 • 根据设定的散列函数 H(key) 和提供的处理冲突的方法，将一组 关键字映象到一个地址连续的地址空间上，并以关键字在地址空 间中的“象”作为相应记录在表中的存储位置，如此构造所得的 查找表称之为散列表。 关键字集合A m 地址空间D n 哈希函数 H(key) 冲突处理C(key) 散列表 地址空间存储的数 据集合称为散列表 83 11.5 散列方法 常见的散列函数 • 一般来说，一个好的散列函数应满足： • （1）计算简单 • （2）冲突少 • 常见的散列函数 • 直接散列函数 • 数字分析法 • 平方取中法 • 折叠法 • 除留余数法 • 随机数法 84 11.5 散列方法 （1）直接散列函数 • 直接散列函数 • 取关键字本身或关键字的某个线性函数值作为散列地址 • H(key) = key 或者 • H(key) = a * key + b (a, b 为常数) 散列地址 01 02 03 …… 22 …… 出生年份 1949 1950 1951 …… 1970 …… 出生人数 ×××× ×××× ×××× …… ×××× …… H（key）=key +（-1948） 解放后每年出生人数的统计： 85 11.5 散列方法 （1）直接散列函数 • 特点 • 这类函数是一一映射，一般不会产生冲突 • 散列地址空间的大小 == 关键码集合的大小 • 适用要求：事先知道关键字的分布情况 86 11.5 散列方法 （2）数字分析法 • 数字分析法：key中数字均匀分布的s位作为散列地址 • 设ｎ个ｄ位数的关键字，由ｒ个不同的符号组成，此ｒ个符号在 关键字各位出现的频率不一定相同，可能在某些位上均匀分布， 即每个符号出现的次数都接近于ｎ／ｒ次，而在另一些位上分布 不均匀。 • 选择其中分布均匀的s位作为散列地址，即H（key）=“key中 数字均匀分布的s位” 87 11.5 散列方法 （2）数字分析法 • 选择其中分布均匀的s位作为散列地址 n=80,d=8,r=10,s=2 1，2，3，8位分布不均匀，不能取。可取第4、6 两位组成的2位十进制数作为每个数据的散列地址， 则图中列出的关键字的散列地址分别为： 45，72，84，03，28，39，51，65，13 如果用前两位，则都是81，不合适！ 88 11.5 散列方法 （3）平方取中法 • 平方取中法：H（key）=“key2的中间几位” • 取关键字平方后的中间几位作为散列地址 • 目的是“扩大差别”和“贡献均衡” • 关键字的各位在平方值的中间几位有所贡献 数据 关键字 (关键字)2 散列地址 A 0100 0010000 010 I 1100 1210000 210 J 1200 1440000 440 I0 1160 1370400 370 P1 2061 4310541 310 P2 2062 4314704 314 Q1 2161 4734741 734 Q2 2162 4741304 741 Q3 2163 4745651 745 89 11.5 散列方法 （4）折叠法 • 折叠法 • 关键字位数较长时，可将关键字分割成位数相等的几部分（最后一 部分位数可以不同），取这几部分的叠加和（舍去高位的进位）作 为散列地址。位数由存储地址的位数确定。 • 两种叠加方法 • 移位叠加法 • 将每部分的最后一位对齐，然后相加 • 边界叠加法 • 之字形排列，然后相加 dr d2 d1 d2r dr+2 dr+1 d3r d2r+2 d2r+1+) Sr S2 S1 (a) 移位叠加法 dr d2 d1 dr+1 d2r-1d2r d3r d2r+2 d2r+1+) Sr S2 S1 (b) 边界叠加法 此方法适合于: 关键字的数字位数特别多的情况。 90 11.5 散列方法 （5）除留余数法 • 除留余数法 • 关键字除以一个不大于散列表长度m的数p后的余数作为散列地址 • p的选取很重要，如果选的不好会产生很多冲突 • 比如关键字都是10的倍数，而p=10 • p一般选取小于表长m的最大质数 • 函数值依赖于自变量x的所有位，而不仅仅是最右边k个低位 • 增大了均匀分布的可能性 H（key）=key MOD p (p≤m) 91 11.5 散列方法 （5）除留余数法 • 示例 • 从p到m的地址空间无法由散列函数计算得到 • 在处理冲突时，可利用这些地址空间 例 p=21 92 11.5 散列方法 （5）除留余数法 • 为什么p不设成幂 • 若把p设置为2的幂 – 那么，hash(x)＝x % 2k 仅仅是x(用二进制表示)最右边的k个位(bit) ⚫ 若把p设置为10的幂 – 那么，h(x)＝x % 10k 仅仅是x(用十进制表示)最右边的k个十进制位 (digital) ⚫ 缺点：散列值不依赖于x的全部比特位 93 11.5 散列方法 （6）随机数法 • 随机数法 • 选择一个随机函数，取关键字的随机函数值作为散列地址； • H（key）=random（key） • random为随机函数 94 11.5 散列方法 散列函数 • 实际工作中需根据不同的情况采用不同的散列函数，通常 需要考虑的因素有： • 计算散列函数所需时间； • 关键字的长度； • 散列表的大小； • 关键字的分布情况； • 记录的查找频率。 95 11.5 散列方法 11.5.3 散列冲突解决方法 • 冲突 • 两个不同的关键字散列到同一个地址 • 好的散列函数可以减少冲突，但是很难避免冲突 • 冲突处理 • 为出现散列地址冲突的关键字寻找下一个散列地址 • 常见的冲突处理方法 • 开放地址法、再散列法、链地址法 • 公共溢出区法 96 11.5 散列方法 （1）开放地址法 • 也称为闭散列法：为产生冲突的地址H(key)生成一个探查序列 • D0称为基地址，Di（0<i<m）称为后继散列地址 • di为增量序列 • 当插入Key时，若基地址上的结点已被别的元素占用 • 依次探查后继散列地址，找到第一个空闲位置Di作为key的存储位置 • 检索时也像插入时一样遵循同样的策略 D0, D1, D2, …, Ds 1≤ s≤m-1 其中：D0 = H(key) Di = ( H(key) + di) % m i=1, 2, …, s 97 11.5 散列方法 di的三种取法 • 增量序列di的三种取法： – 线性探测再散列 di= c  i 最简单的情况 c=1 – 二次探测（平方探测）再散列 di= 12, -12, 22, -22, ...., 或者di= 12, 22, 32, ...., – 随机探查再散列 di 是一组伪随机数列 98 11.5 散列方法 线性探查示例 • {30, 40, 47, 42, 50, 17, 63, 12, 6, 72, 27}，m=15 • H(key)=key % 13，p(k,i)=i • 理想情况下，表中的每个空槽接收下一个要插入记录的概率相等。 但是，随着记录的插入，接受下一个要插入记录的概率不同 • 下一条记录放在第10个槽中的概率是1/13 • 放到第9个槽中的概率是9/13 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 17 63 12 27 3040 4742 506 72 99 11.5 散列方法 线性探查法可能产生的问题 • 聚集（Clustering） • 散列地址不同的结点，争夺同一后继散列地址 • 小的聚集可能汇合成大的聚集 • 导致很长的探查序列 • 改进 • 每次跳过C个槽，而不是1个槽，基位置相邻的记录就不会进入同 一个探查序列 • C与M通常互素 100 11.5 散列方法 （2）再散列法 • 将n个不同散列函数排成一个序列, 当发生冲突时, 由RHi确 定第i次冲突的地址Hi。 • Hi = RHi(key), i = 1, 2, ..., n • 其中RHi为不同散列函数 • 这种方法不会产生聚类，但会增加计算时间 101 11.5 散列方法 （3）链地址法 • 也称为开散列法 • 插入：将所有散列地址相同的记录都 链接在同一链表中。 • 检索：根据散列地址，遍历相应链表， 找到对应的关键字，则查找成功；否 则，查找失败 h(k) = k mod 10 102 11.5 散列方法 （3）链地址法 • 举例：1000， 9530， 9877， 2007， 3013， 1057 散列函数：H(k) = K % 5 0 1 2 3 4 9530 2007 1057 1000 9877 3013 查找1057 2007 1057 103 11.5 散列方法 （4）公共溢出区法 • 公共溢出区法 • 在基本散列表之外，另设一个溢出表 • 将与基本表中的关键字发生冲突的所有记录都填入溢出表中 • 例子：关键字序列为{19，14，23，01，68，20，84，27， 55，11，10，79}，散列函数为H（key）= key mod 13 ^ 14 ^^^^^^ 1168 19 20 23 01 84 27 55 10 79 0 1 2 3 4 5 6 7 8 9 10 11 12 hash表 溢出表 104 11.5 散列方法 11.5.4 散列查找算法 • 在散列表上查找的过程和散列造表的构造过程基本一致 • 1）给定K值，根据构造表时所用的散列函数求散列地址j， • 2）若此位置无记录, 则查找不成功； 否则比较关键字，若和给定的关键字相等则成功； 否则根据构造表时设定的冲突处理的方法计算“下一地址”， 重复2） 105 11.5 散列方法 散列查找算法 • 散列查找流程 Input k Pos=H(k) Pos==NULL? key==k fail success collision Y N Y N 106 11.5 散列方法 举例 • 已知一组关键字（19，14，23，01，68，20） • 散列表HT有10个槽，用除留余数法构建散列函数h(k)=k % 7 • 冲突解决策略为基于线性探查的闭散列方法 关键字 基地址 线性探查序列 19 14 23 01 68 20 0 1 2 3 4 5 6 7 8 9 散列函数：h(k)=k % 7 1914 2301 68 20 6 7 探查函数：p(k, i)=i 5 0 2 1 5 6 107 11.5 散列方法 举例 • 查找成功 关键字 基地址 线性探 查序列 19 5 14 0 23 2 01 1 68 5 6 20 6 7 0 1 2 3 4 5 6 7 8 9 散列函数：h(k)=k % 7 比较一次 比较一次 比较一次 比较一次 比较两次 比较两次 1914 2301 68 20 探查函数：p(k, i) = i 108 11.5 散列方法 举例 • 查找失败 • 基地址的槽为空 • 基地址的槽不为空，按照探查序列，直至找到为空的槽 14 1 23 19 68 20 0 1 2 3 4 5 6 7 8 9 4 3 2 1 1 4 3 散列函数：h(k)=k % 7 查找不成功的比较次数： 散列函数无法 映射到该地址 109 11.5 散列方法 举例 • 例：关键字集合{ 19, 01, 23, 14, 55, 68, 11, 82, 36 } • 设定散列函数 H(key) = key MOD 11 ( 表长=11 ) • 若采用二次探测再散列处理冲突 0 1 2 3 4 5 6 7 8 9 10 1901 23 14 6855 11 82 36 1 1 2 1 3 1 4 4 1 ASL(成功）=（1+1+2+1+3+1+4+4+1）/9=2 4 3 7 6 5 4 3 2 1 0 0 ASL(失败)= （4+3+7+6+5+4+3+2+1）/9 =35/9 110 11.5 散列方法 举例 • 链地址法：将所有散列地址相同的记录都链接在同一链表中 0 1 2 3 4 5 6 01 19 82 23 11 68 55 14  36       ASL(成功)=(6×1+2×2+3)/9=13/9 ASL(失败)=(4×1+2+3)/7=9/7 关键字集合为 {19,01,23,14,55,68,11,82,36}， 散列函数为 H(key)=key MOD 7 111 11.5 散列方法 查找性能分析 • 散列表的查找性能取决于三个因素： • 散列函数 • 散列函数的质量影响到冲突出现的频繁程度 • 一般情况下，假定散列函数都是均匀的，所以不考虑它对平均查找长度 的影响 • 冲突处理方法 • 散列表的装填因子=表中填入的记录数/散列表长度 • 值越小，散列表中填入的数据越少，发生冲突的可能性越小 • 反之，值越大，散列表中填入的数据越多，发生冲突的可能性越大 112 11.5 散列方法 查找性能分析 • 查找成功时的平均查找长度 • 线性探测再散列 • 二次探测、随机探测再散列 • 链地址法 ) 1 1 1( 2 1 − + nl S )1ln( 1   −− nr S 2 1  + nc S 113 11.5 散列方法 查找性能分析 • 查找不成功时的平均查找长度 • 线性探测再散列 • 二次探测、随机探测再散列 • 链地址法 2 11 (1 ) 2 (1 ) nsU  + − 1 1 tnU   −ncUe + 114 11.5 散列方法 查找性能分析 • 散列表的平均查找长度是装填因子  的函数，而不是 n 的 函数 • 用散列表构造查找表时，可以选择一个适当的装填因子  ，使得 平均查找长度限定在某个范围内。 115 11.5 散列方法 总结 • 散列：函数映射 关键字范围广 存储空间范围小 散列函数 冲突不可避免，不同解决冲突的策略的ASL不同 查找表大小与解决冲突策略和ASL范围相关 选择散列函数 根据冲突策略与ASL计算 散列表大小 建立查找表","libVersion":"0.5.0","langs":""}