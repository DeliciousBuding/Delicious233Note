{"path":"01 数据结构和算法/复习.pdf","text":"前缀表达式：从后往前，后⼊栈的先算 后缀表达式：从前往后，先⼊栈的先算 栈和队列 中缀表达式 前缀表达式 后缀表达式 朴素模式匹配算法 字符串匹配 朴素算法 KMP getNext v o i d c a l _ n e x t ( c h a r * s t r , i n t * n e x t , i n t l e n ) { n e x t [ 0 ] = - 1 ; / / n e x t [ 0 ] 初始化为- 1 ，- 1 表示不存在相同的最大前缀和最大后缀 i n t k = - 1 ; / / k 初始化为- 1 f o r ( i n t q = 1 ; q < = l e n - 1 ; q + + ) { w h i l e ( k > - 1 & & s t r [ k + 1 ] ! = s t r [ q ] ) / / 如果下一个不同，那么k 就变成 n e x t [ k ] ，注意n e x t [ k ] 是小于k 的，无论k 取任何值。 { k = n e x t [ k ] ; / / 往前回溯 } i f ( s t r [ k + 1 ] = = s t r [ q ] ) / / 如果相同，k + + { k = k + 1 ; } n e x t [ q ] = k ; / / 这个是把算的k 的值（就是相同的最大前缀和最大后缀长）赋给 n e x t [ q ] } } 1 2 3 4 5 6 7 8 9 1 0 1 1 1 2 1 3 1 4 1 5 1 6 1 7 KMP算法Next数组： 模式串 索引 （i） ⼦串（t \u0000 0..i] ） PMT [ i] （最⻓公共 前后缀⻓ 度） Next [ i] （从 \u0000 1 开始） Next [ i] （从 0 开始） 0 \"a\" 0 \u00001 0（对应 i=0，空串） 1 \"ab\" 0 \u00001 0（对应 i=1，⼦串 \"a\"） 2 \"aba\" 1 0 0（对应 i=2，⼦串 \"ab\"） 3 \"abab\" 2 1 1（对应 i=3，⼦串 \"aba\"） 4 \"ababc\" 0 \u00001 2（对应 i=4，⼦串 \"abab\"） KMP算法： 树 定义 ⼆叉树 满⼆叉树 （哈夫曼树也算） 完全⼆叉树 完美⼆叉树 哈夫曼树⼆叉树遍历堆 ⼤顶堆：每个⽗节点都⼤于其⼦节点 堆的存储：完全⼆叉树⽤数组存储，节点下标为i，左⼦节 点下标为2 i + 1 ，右⼦节点下标为2 i + 2 堆的基本操作： 上调：任意元素插⼊到堆的尾部，复杂度为O(logN) 下滤：任意元素插⼊到堆的顶部，复杂度为O(logN) 建堆⽅法： ⾃顶向下 ⾃下⽽上：对每个⽗节点进⾏下滤 优先队列/堆排序：弹出顶端元素，然后持续维护 图 邻接表 遍历 DFS：不撞南墙不回头 BFS Bellman-Ford算法通过对边进⾏松弛的⽅式渐近地求出源顶点 s到其余顶点 v的最短路径距离。 要让任意两点之间的路程变短，只能引⼊第三个点，并通过这 个顶 点𝑤中转即𝑢 → 𝑤 → 𝑣 最短路径 Dijkstra单源最短路径 Bellman-Ford算法 Floyd多源最短路径 关键路径 AOE⽹ 拓扑排序：每次选⼊度为0的点，然然后删除这 个点和它的出边 不相交集 最⼩⽣成树 Prim：加点法不断加相邻最近的，不能形成回路 Kruskal：加边法，不断加最⼩的边，不能形成回路 求最⼩⽣成树的Kruskal算法： 按权重递增顺序考虑每条边 并把连接不同连通分量的边e = (u,v) 加⼊⽣成 树。 并查集 路径压缩 按秩合并 排序 内排序 排序的稳定性:若序列中关键字值相等的节点经过某种排序 ⽅法进⾏排序之后，仍能保持它们在 排序前的相对顺序， 则称这种排序⽅法是稳定的；否则，称这种排序⽅法是不 稳定的。 缩⼩增量排序法 每个增量将序列分组进⾏插⼊排序，逐渐缩⼩增量并进⾏排序 从d=n/2\u0000向下取整 ) 插⼊排序（折半插⼊）  普通插⼊排序 算法步骤： 从第⼆个元素开始，将其视为待插⼊元素 与已排序序列（前 i-1 个元素）从后往前⽐较 若待插⼊元素⼩于⽐较元素，则后者后移⼀位 找到合适位置插⼊，重复直⾄所有元素排序完成 时间复杂度：平均 / 最坏 O (n²)，最好 O (n)（序列接近 有序时） 空间复杂度：O\u00001\u0000 稳定性：稳定（相同元素相对顺序不变）  折半插⼊排序 优化点：⽤⼆分查找代替线性查找插⼊位置 算法步骤： 对已排序序列使⽤⼆分法确定待插⼊元素位置 后续元素后移并插⼊ 时间复杂度：⽐较次数 O (nlogn)，移动次数 O (n²) 适⽤场景：数据量不⼤且初始序列基本有序时 希尔排序 两两⽐较，逐渐冒泡 优化：在前⼀轮没有进⾏交换的时候退出循环 每轮都在剩下的数⾥选最⼩的换到前⾯ 冒泡排序 选择排序 归并排序 归并操作 ⽬标：合并成⼀个有序数组 每次都选两个数组中最⼩的(⽐较各⾃剩下元素中的第⼀ 个) 其中⼀个放完后，另⼀个剩下的元素直接放到最后 归并排序 每轮都对相邻⼦序列两两归并 循环⽅法： 通过递归分治⽅法，基于轴点将待排序序列拆分成两个⼦序列 并分别排序，直 到序列有序。 排序步骤： ① 从待排序序列中选取轴点。 ② 通过交换序列元素，将待排序序列拆分为左右两个⼦序 列，左⼦序列元素⼩于等于轴点， 右⼦序列元素⼤于等于轴 点。 ③ 对两个⼦序列递归进⾏上述操作，直到⼦序列元素个数⼩ 于等于1。 还可以使⽤递归算法 快速排序 逐位进⾏分配和收集 堆排序 基数排序  个位： 核⼼思想：将数据分到多个桶中，每个桶内排序后再合并。 算法步骤： 确定桶的数量和范围 将元素分配到对应桶中  ⼗位  百位  得到结果 桶排序 对每个桶内元素排序（可使⽤其他排序算法） 按桶顺序合并元素 时间复杂度：平均 O (n+k)（k 为桶数量），最坏 O (n²) 空间复杂度：O(n+k) 关键前提：数据分布均匀，桶的⼤⼩设计合理 稳定性：稳定（取决于桶内排序算法） 核⼼思想：非⽐较排序，统计每个值的出现次数，再按次数重 建序列。 算法步骤： 找出数据范围 [min, max]，创建⻓度为 max-min+1 的计数数 组 统计每个元素出现次数 按计数数组顺序重建有序序列 时间复杂度：O (n+k)（k 为数据范围） 空间复杂度：O(k) 前提条件：数据范围有限且为整数 稳定性：稳定 排序都需要拷⻉或移动序列中的元素。当元素移动和拷⻉的代 价很⼤时，需要尽可能减少元 素移动和拷⻉的次数。 核⼼思路：创建⼀个索引序列idx，在排序时使⽤原序列元素 进⾏⽐较，使⽤索引序列进⾏元素 交换。最后，算法会给出排 序后的索引序列。 计数排序 索引排序 外排序（多路归并外排序） 胜者树 败者树 查找 ⼆分查找 删除时有三种情况： 没有孩⼦－直接删除 只有左⼦树/只有右⼦树－直接代替 ⼆叉搜索树 BST 平衡⼆叉搜索树 AVL 左右⼦树都有 － 直接后继(或前驱)代替值,然后删除(转换成前 两种情况) 最⻓路径绝不会超过最短路径的两倍 红黑树 红黑树的性质 红黑树的插⼊ 0:00 / 4:32 红黑树的删除 线段树 B树 B+树：索引 B树的插⼊ B树的删除 B+树的⽐较 哈希 冲突的解决 开放定址法 线性探测法 冲突的解决 查找 查找的次数ASL 删除标记 平⽅探测法 优点：删除可以直接删 链表法","libVersion":"0.5.0","langs":""}