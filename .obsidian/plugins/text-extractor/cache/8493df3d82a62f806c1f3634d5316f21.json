{"path":"01 数据结构和算法/PPT/第02章课件-线性表.pdf","text":"数据结构 计算机领域本科教育教学改革试点 工作计划（“101计划”）研究成果 张羽丰 湖南大学 线性结构 第 2 章 张羽丰 湖南大学 2.1 问题引入：一元多项式 2.2 线性表的定义与结构 2.3 线性表的顺序存储实现 2.4 线性表的链式存储实现 2.5 线性表的应用 2.6 拓展延伸 2.7 应用场景：内存管理 2.8 小结 2.1 问题引入：一元多项式 例2.1 一元多项式及其运算 ➢ 一元多项式： ➢ 主要运算：多项式相加、相减、相乘等 n n n n xaxaxaaxf ++++= − − 1 110)(  ◼ 问题：如何在计算机中表示一元多项式并实现相关的运算？ ◼ 多项式的关键数据：多项式项数、每一项系数（以及对应指数） 方法1：采用顺序存储结构直接表示一元多项式 用数组a存储多项式的相关数据：数组分量a[i]表示项xi的系数 例如： 134 25 +− xx a[i] 1 0 –3 0 0 4 …… 下标i 0 1 2 3 4 5 …… ◼ 这种表示的优点和缺点？ 优点：多项式相加容易 缺点：如何表示 3000021 x+ 方法2：采用顺序存储结构表示多项式的非零项 ◼ 每个非零项 涉及两个信息：指数i和系数ai ◼ 可以将一个多项式看成是一个(ai，i)二元组的集合。 i i xa 2812 1 3159)( xxxxP ++= 8213426)( 6819 2 +−−= xxxxP 系数 9 15 3 – 系数 26 –4 –13 82 – 指数 12 8 2 – 指数 19 8 6 0 – 数组下标i 0 1 2 …… 数组下标i 0 1 2 3 …… ◼ 这种表示的优点和缺点？ 方法3：采用链表结构来存储多项式的非零项 链表表示多项式：链表结点对应一个非零项，包括：系数、指数、指针域 系数 指数 指针 2812 1 3159)( xxxxP ++= 8213426)( 6819 2 +−−= xxxxP 9 12p1 p2 15 8 3 2 NIL 26 19 –4 8 –13 6 82 0 NIL ◼ 这种表示的优点和缺点？ 线性表 本章介绍：线性表的抽象定义，并分别讨论基于顺序存储和链接存储的线性表实现方 法，以及线性表的基本操作，包括插入、删除等。 启示：数据结构的设计 ◼ 往往需要在算法简洁、可理解性与时间、空间效率之间权衡 ◼ 针对具体问题选择合适的数据结构及设计相应的算法 2.2.1 线性表的定义 线性表：由同一类型的数据元素构成的有序序列的线性结构 2.2.2 线性表的结构 线性表的逻辑结构：数据元素之间线性的序列关系，即数据元素之间的前驱和后继关系。 线性表的物理结构：线性表在计算机中的存储方式，又称为存储结构，即从程序实现的 角度将逻辑结构映射到计算机存储单元中。 存储结构主要有两种形式：顺序存储结构和链式存储结构。 ◼ 顺序存储结构：数据元素被顺序地存储在连续的内存空间中，前驱和后继元素在物理 空间上是相邻的。 ◼ 链式存储结构：可以动态地申请存储数据的结点空间，并使用类似指针这样的手段将 结点按顺序前后链接起来 2.3 线性表的顺序存储实现 例如：数组list.data[kMaxSize]: 从list.data[0]开始依次顺序存放，kMaxSize代表数组最大容量， list.last记录当前线性表中最后一个元素在数组中的位置，表空时list.last= -1。 data 1a 2a …… ia 1+ia …… na …… - i 0 1 …… i-1 i …… n-1 …… kMaxSize-1 last 1022682044 2.3.1 顺序表的基本操作 1.初始化: 顺序表的初始化即构造一个空表 (1)动态分配表结构所需要的存储空间 (2)将表中 list.last 指针置为-1，表示表中没有数据元素。 2.3.1 顺序表的基本操作 2.查找 查找：在线性表中查找与给定值x相等的数据元素 方法：从第一个元素 起依次和x比较，直到找到一个与x相等的数据元素，返回它在顺序 表中的存储下标；或者查遍整个表都没有找到与x相等的元素，则返回NIL。 时间复杂性： ◼ 1~（n+1)/2 ◼ 平均O(n) 2.3.1 顺序表的基本操作 3.插入 在表的第i个位序上插入一个值为x的新元素 (a1,a2,...,ai-1,ai,ai+1,...,an) --> (a1,a2,...,ai-1,x,ai,ai+1,...,an) 时间复杂度为O(n） 执行步骤： （1）将ai～an顺序向后移动（移动次序从后到前），为新元素让出位置； （2）将x置入空出的第i个位序； （3）修改 list.last 指针(相当于修改表长)，使之仍指向最后一个元素。 2.3.1 顺序表的基本操作 3.插入 2.3.1 顺序表的基本操作 4.删除 将线性表中的第i个位序上的元素删除 (a1,a2,...,ai-1,ai,ai+1,...,an) --> (a1,a2,...,ai-1,ai+1,...,an) 时间复杂度为O(n） ◼ 执行步骤： (1)将第i位置之后的元素顺序向前移动，元素被覆盖 ； (2)修改list.last指针(相当于修改表长)使之仍指向最后 一个元素。 2.4 线性表的链接存储实现 单向链表（简称单链表）：每个数据单元由数据域data和链接域next两部分组成， n个数据单元通过链接域next串联起来。 list.head a1 a2 an NIL …… 链式存储： ◼ 不要求逻辑上相邻的两个数据元素物理上也相邻 ◼ 通过“链”建立起数据元素之间的逻辑关系 ◼ 对线性表的插入、删除不需要移动数据元素，只需要修改“链”。 2.3.2 单链表的基本操作 1. 求表长: 求单链表元素个数 （1）设一个移动指针p和计数器counter，初始化 （2）p逐步往后移，同时计数器counter加1 （3）当后面不再有结点时，counter的值就是结点个数，即表长。 时间复杂性O(n) 2.3.2 单链表的基本操作 2. 查找：分按序号查找Get (list, i)、 按值查找Search(list, x) （1）按序号查找步骤： ◼ 从链表的第一个元素结点起，判 断当前结点是否是第i个； ◼ 若是，则返回该结点的值，否则 继续后一个，直到表结束为止。 ◼ 如果没有第i个结点则返回错误码 (ErrorCode)。 时间复杂性：O(n) 2.3.2 单链表的基本操作 2.查找 （2）按值查找步骤： ◼ 从链表的第一个元素结点起，判断当前结点其值是否等于x； ◼ 若是，返回该结点的位置（即指向该结点的指针），否则继续后一个，直到表结束为止。 ◼ 找不到时返回空（NIL）。 时间复杂性：O(n) 2.3.2 单链表的基本操作 3. 插入：在list的第i个位置上插入元素x 步骤： （1）找到第i-1个结点； （2）若存在，则申请一个新结点的空间 并填上相应值x，然后将新结点插到第i- 1个结点之后； （3）如果不存在则直接退出： 时间复杂度为O(n） 注意：表空和不空时候的不同处理方式 2.3.2 单链表的基本操作 4. 删除 在单链表中删除指定位序i的元素 步骤： ◼ 找到被删除结点的前一个元素 ◼ 再删除结点并释放空间。 时间复杂度为O(n） 2.4.3 双向链表 双向链表：结点前后之间实现双向链接，即每个结点都有两个指针，一个next指向直接后继，另 一个prior指向直接前驱。 1. 插入 2.3.2 单链表的基本操作 2、删除：双向链表中p所指向结点删除 2.3.2 单链表的基本操作 带头结点的双向链表：可以设置一个空的“头结点”，真正的元素链接在这个空结点之后。 2.4.4 循环链表 循环单链表：链表终端结点的指针指向链表的起始结点 循环双向链表：让终端结点的后继指针指向链表的起始结点，同时让起始结点的前驱指 针指向链表的终端结点 2.4.4 循环链表 单向循环链表的遍历：可以从任意结点start开始将整个链表遍历一遍 2.4.5 静态链表 静态链表：用数组存放线性表中的元素，但并不按照元素顺序在数组中依序存放，而是给每个数 组元素增加一个域，用于指示线性表中下一个元素的位置（即它在数组中的下标） ◼ 物理存储空间上依赖于数组 ◼ 元素逻辑链接关系是采用了链表的思想 data g d a e b f h c next 3 8 4 5 6 9 1 0 2 下标 0 1 2 3 4 5 6 7 8 9 10 （a,b,c,d,e,f,g,h） 2.4.6 块状链表 块状链表：采用双向链表维护总长度不超过n的线性表的各元素，并将元素分成若干个块， 每个块所包含的元素个数为 𝑛（最后一个块内的元素个数可能不满）。 1. 查找操作 查找第10个元素的查找路径： （1）在单向链表中遍历第1块、第2块、第3块； （2）进入第3块对应的双向链表继续查找结点6、结点-2，即第10个元素为-2。 时间复杂度： 2.4.6 块状链表 2. 插入操作：在第i个元素之后插入新元素 （1）基于查找操作找到第i个元素所对应的双向链表结点 （2）在双向链表上执行插入操作 （3）由于第i个元素所在块多了一个元素，因此该块之后的所有块指向的双向链表结 点将变为原指向结点的前驱结点。(比简单的双链表更麻烦了) 3. 删除操作: 与插入类似 插入和删除时间复杂度： 例如，如果向第10个元素-2之后插入新元素20 1）在结点-2和-7之间插入新元素20，变为-2、20、-7。 2）原有元素次序产生变化：原第11个元素变为现第12个、原第12个元素变为现第13个……。 3）将第4块所指向的双向链表结点从12更新为前驱10，第5块的双向链表结点从-8更新为前驱-3。 值得额外注意的是，插入操作有可能导致新的块产生，在实现代码中需要处理好这种特殊情况。 2.5 线性表的应用 一元多项式的加法： p1和p2分别指向两个多项式第一个结点，不断循环比较p1和p2所指的各结点，做不同处理 ◼ P1.expon==P2.expon， 插入求和结点， P1=P1.next； P2=P2.next ◼ P1.expon>P2.expon， 插入P1，P1=P1.next; ◼ P1.expon<P2.expon, 插入P2，P2=P.next; 53 44 3-1 12 0-1 42 31 2-7 11 P1 P2 P1 53 P2 P1 P1 P2 P2 P1 46 2-7 13 0-1 2.5.2 大整数处理 大整数表示：用顺序表中的元素依次表示该大整数的个位数、十位数、百位数…… n = -23456所对应的digits[] = {6, 5, 4, 3, 2}，length = 5，sign = -1 1. 加法运算：假设a+b>0,基本过程是： (1) 首先将这两个大整数的位数对齐（位数较少的大整数的高位补0） (2) 将两个大整数对应的位数依次相加或相减，同时处理进位或借位，并将结果存入一 个新的大整数c中。 (3) 处理加法导致的最高位进位，或减法导致的前导0问题。 ◼ 处理一个正的大整数a加一个负的大整数-b（a<b）：计算b和-a相加的结果，并将最终结果的 符号位取反； ◼ 处理一个负的大整数-a加一个负的大整数-b：计算a和b相加的结果，并将最终结果的符号位取 反。 时间复杂度是O(n) 2.5.2 大整数处理 2. 乘法运算：两个正的大整数a和b相乘 （1）用i和j的二重循环分别枚举大整数a和b的每一位（数组下标从0开始） （2）对于a的第i位数字和b的第j位数字（按从低位到高位的顺序），将它们相乘并累加至 表示计算结果的大整数c的第i+j位上。 （3）对于得到的大整数c，从最低位到最高位依次处理进位问题，得到最终的计算结果。 时间复杂度是O(n2) 2.6 拓展延伸 1.广义表 ⚫ 广义表是线性表的推广 ⚫ 对于线性表而言， n个元素都是基本的单元素； ⚫ 广义表中，这些元素不仅可以是单元素也可以是另一个广义表。 283812212 31549),( xyxyxxyxyxP +−++= 283122 3)15()49(),( xxyyxyyxP +−++= 12P 8 3 2 NIL 9 2 4 0 NIL 15 3 –1 1 NIL 例如：二元多项式的表示 2.6.2多维数组和特殊矩阵 1. 多维数组的顺序存储：按照行优先的顺序存放，即先存放第0行的元素，再存放第1行的元 素，……，其中每一行中的元素再按照列的顺序存放。 例如：二维整形数组 a[3][4]的存放顺序： a[0][0] a[0][1] a[0][2] a[0][3] a[1][0] a[1][1] a[1][2] a[1][3] a[2][0] a[2][1] a[2][2] a[2][3] 一般来说，二维数组元素a[i][j]的存储位置（地址）lij计算方法是： lij = l00 +（i × nc + j）× size 设n维数组各维大小是（s1，s2，……，sn），第一个元素的地址是l(0,0,…,0)，元素占用空间为 size个字节，则下标为（i1,i2，…,in）的元素位置是： l(i1,i2,…in) = l(0,0,…,0) + (i1×s2×s3×..×.sn+i2×s3×...sn+...in-1×sn+in)× size 2.6.2多维数组和特殊矩阵 2. 特殊矩阵：上三角矩阵和下三角矩阵 压缩空间存储：如果只存储上三角（或者下三角）元素，则将近减少了一半的存储空间 对于下三角矩阵，设单个元素所占空间为size，则a[i][j]的存储位置lij 与矩阵首个元 素a[0][0]的地址l00 的关系是： lij = l00 + (i(i+1)/2+j) × size，i≥j 2.6.3稀疏矩阵和舞蹈链 1. 稀疏矩阵：数值为0的元素数目远远多于非0元素的数目，并且非0元素分布没有规律 ◼ 存储：非0项 1) 三元组表的顺序存储 row 0 0 1 2 3 3 3 col 0 3 1 3 0 1 4 value 18 2 27 -4 23 -1 12 0 1 2 3 4 5 6 采用一种典型的多重链表——十字链表来存储稀疏矩阵  只存储矩阵非0元素项 结点的数据域：行坐标Row、列坐标Col、数值Value  每个结点通过两个指针域，把同行、同列串起来; ➢ 行指针(或称为向右指针)Right ➢ 列指针（或称为向下指针）Down 2) 三元组表的链式存储：十字链表 对一维稀疏向量（多项式） 表示方法的自然扩展 2.6.3稀疏矩阵和舞蹈链 稀疏矩阵的十字链表结构 ◼ 用一个标识域Tag来区分头结点和非0元素结点：头节点的标识值为“Head”，矩阵非 0元素结点的标识值为“Term”。 (a) 结点的总体结构 (b) 矩阵非0元素结点 (c) 头结点 Tag Down RightURegion Down Right Row Col Value Term Down RightNext Head 稀疏矩阵的十字链表实现的一个例子 Head Term 4 5 7 A Term 0 0 18 Head Head Head Head Head Head Term 3 0 23 Head Head Head Term 1 1 27 Term 3 1 -1 Term 0 3 2 Term 2 3 -4 Term 3 4 12 2.6.3稀疏矩阵和舞蹈链 2. 舞蹈链 ➢ D.E. Knuth提出X算法：采用回溯搜索在矩阵中寻找合适的行实现“精确覆盖” ➢ X算法的执行需要大量的矩阵行和列的删除以及恢复操作，需要良好的矩阵数据结构支持。因 此，提出舞蹈链：双向循环十字链表 ⚫ 例如，在舞蹈链上，可以快速删除矩阵的某一行：只需要找到该行的行首结点，随后从行 首结点开始遍历该行所有结点，将这些结点从所在的列链表中删除即可。 ⚫ 同样，可以快速地向矩阵第r行、第c列插入一个元素。 ◼ 拟解决问题：给定一个元素值为1或者0的n 行m列的矩阵，需要从中挑选若干行形成新 矩阵，要求新矩阵的每一列有且仅有一个元 素为1。 ◼ 精确覆盖问题：从矩阵中选取若干行，使得 这些行中的1“精确地覆盖”原矩阵的每一 列。 2.7 应用场景：内存管理 ◼ 操作系统空闲内存管理：空闲块的管理，处理申请和回收； ◼ 内存空闲块组织成双向链表 ◼ 空闲块分配策略：首次适配、最佳适配 ◼ 空闲块回收：空闲块合并 2.8 小结 ◼ 线性表：若干数据元素组成的有序序列，其基本操作有插入、删除、查找等 ◼ 线性表实现方法：顺序存储、链式存储 ◼ 双向链表：通过设置分别指向后继和前驱结点的两个指针，实现从前向后和从后向前两个方向的访问 ◼ 循环链表：最后结点的向后指针指向链表的头结点；双向链表头结点的向前指针还指向链表最后结点 ◼ 静态链表：物理存储依赖于顺序存储结构、逻辑链接关系采用链表思想 ◼ 块状链表：在传统的链表结构之上采用“分块”的思想进行改进，平衡了查找操作的时间复杂度和插入 /删除操作的时间复杂度 ◼ 广义表：对一般线性表的推广，是一种“表中有表”的数据元素组织方式 ◼ 多维数组：将元素在空间上按行顺序存储，实现类似一维数组的随机访问 ◼ 特殊矩阵和稀疏矩阵可以进行压缩存储，减少所需要的存储空间；稀疏矩阵通过十字链表记录非零元素 ◼ 舞蹈链：一种采用双向链表链接的十字链表，可以较好地支持矩阵的整行删除、整列删除以及恢复操作","libVersion":"0.5.0","langs":""}