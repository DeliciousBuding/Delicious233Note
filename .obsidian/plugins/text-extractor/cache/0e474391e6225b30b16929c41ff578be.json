{"path":"01 数据结构和算法/数据结构/图/实验六/实验6 报告-202408010521-唐丁.pdf","text":"实验6 报告-202408010521-唐丁 一、问题分析 1. 处理对象 2. 功能实现 3. 结果显示 4. 样例求解（题目样例） 输入： 输入数据： 有向图 G(V ,E)，顶点编号为 1∼n，边可能包含环和自环。 每个测试用例包含顶点数 n、边数 m，以及 m 条边的起点和终点。 核心处理目标： 对每个顶点 v，判断从顶点 1 到 v 的路径类型： 0：不可达 1：唯一路径 2：有限多条路径 -1：无限多条路径 功能分解： 1. 可达性判断：通过深度优先搜索（DFS ）确定顶点 1 到其他顶点的可达性。 2. 路径类型判断： 无限路径：若路径中存在环，则后续顶点路径数无限。 多路径：若存在多条独立路径，但路径数有限。 唯一路径：仅有一条路径可达。 输出格式：每个测试用例输出一行，包含 n 个整数，表示顶点 1∼n 的判定结果。 6 7 1 4 1 3 3 4 4 5 2 1 1 2 3 4 5 6 （此处5有自环，未画出） 处理过程： 二、数据结构与算法设计 1. 抽象数据类型设计 5 5 5 6 7 8 1. 第一次DFS（从顶点1出发）： 标记顶点1、3、4、5、6、7为可达。 检测到边 5→5 （自环），顶点5标记为环节点。 2. 第二次DFS（扩展环和多路径影响）： 顶点5的环影响顶点5和6、7，标记为无限路径（-1）。 顶点4通过两条路径（1→3→4 和 1→4 ）可达，标记为多路径（2）。 输出： 1 0 1 2 -1 -11 图结构（ADT Graph）： 数据对象：顶点集合 VV 和边集合 EE。 操作：邻接表构建、顶点可达性遍历。 标记集合（ADT MarkSet） 2. 物理数据对象设计 3. 算法思想 4. 关键功能步骤 数据对象：记录环节点和多路径节点。 操作：插入节点、查询节点是否存在。 邻接表：使用 vector<vector<int>> 存储图的边关系。 颜色标记数组： color[]：记录顶点访问状态（0-未访问，1-处理中，2-已处理）。 关键节点集合： s[0]：存储DFS 过程中检测到的环候选节点（灰色节点）。 s[1]：存储可能形成多路径的节点（黑色节点）。 两次DFS策略： 1. 第一次DFS：从顶点1出发，标记可达性，并记录环候选节点（灰色节点）和多 路径候选节点（黑色节点）。 2. 第二次DFS： 从环候选节点出发，标记所有可达节点为无限路径（-1）。 从多路径候选节点出发，标记所有可达节点为多路径（2）。 结果合并：根据两次DFS 的标记结果，综合判定每个顶点的最终状态。 1. 第一次DFS： 遍历图，标记顶点颜色。 若访问到灰色节点，记录到 s[0]（环候选）。 若访问到黑色节点，记录到 s[1]（多路径候选）。 2. 第二次DFS： 对 s[0] 中的节点进行DFS ，标记所有可达节点为无限路径。 对 s[1] 中的节点进行DFS ，标记所有可达节点为多路径（需排除已标记为无限 路径的节点）。 3. 结果判定： 不可达：未被第一次DFS 标记。 无限路径：被 s[0] 的扩展标记。 多路径：被 s[1] 的扩展标记且未被 s[0] 覆盖。 唯一路径：仅被第一次DFS 标记。 三、算法性能分析 1. 时间复杂度 2. 空间复杂度 3. 优化点 注：参考了codeforce1547G 的解答 第一次DFS：O(n+m)。 第二次DFS： 对 s[0] 和 s[1] 的遍历总时间复杂度为 O(n+m)。 总体复杂度：O(n+m)，与图的顶点和边数成线性关系 邻接表：O(m) 颜色数组：O(n) 集合 s[0] 和 s[1]：最坏情况 O(n)O(n) 总体复杂度：O(n+m) 并行化：若输入规模极大，可将两次DFS 分块并行处理（需处理跨块依赖）。 内存管理：使用位压缩标记数组减少空间占用。","libVersion":"0.5.0","langs":""}