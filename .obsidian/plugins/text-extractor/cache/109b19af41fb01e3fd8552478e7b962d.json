{"path":"01 数据结构和算法/PPT/第05章课件-树与二叉树.pdf","text":"数据结构 信息科学与工程学院 树与二叉树 第 5 章 5.1 问题引入 5.2 树的定义与结构 5.3 二叉树 5.4 二叉树的遍历 5.5 哈夫曼树 5.6 树与森林 5.8 应用场景 5.1 问题引入：商品分类树 5.1 问题引入 问题：如何方便了解超市商品有哪些类别？每个类别可分为哪些更小的类别，以 及属于该类别的终端商品有哪些？ 关键：如何展示商品不同类别之间的层次关系（包含关系） 商品分类树： 5.1 问题引入：商品分类树 5.1 问题引入 商品分类树 结构与倒立的树相似，展示对数以千万计的商品由上至下、由粗到细的分类 根结点（所有商品） 叶结点（终端商品） 相邻两层结点用边连 接，表示父子关系 （包含关系） 除树根外，每个结点都 有且仅有一个父结点 相邻两层结点有边连 接，表示父子关系 5.1 问题引入：商品分类树 5.1 问题引入 商品分类树 结构与倒立的树相似，展示对数以千万计的商品由上至下、由粗到细的分类 问题 主要内容 如何在计算机上表达商品分类树？能否用顺序表、链表等线性结构 存储树？如何在计算机上查询每个分类包含哪些商品？如何判断两 个分类之间是否有包含关系？ 树与二叉树的定义、存储实现、遍历方式及其典型应用 5.2 树的定义与结构 5.2 树的定义与结构 树的定义： 树是由结点组成的有限集合T，用|T|表示结点的数量。树具备以下性质： （1） |T| = 0，T是空树。 （2） T > 0 递归定义 • 父子关系属于二元关系 <r, ri> • 由于根结点没有父结点，而其它所有结点都有一个且 仅一个父结点，所以由n个结点构成的树共包含n-1对 父子关系 • 如果用边连接有父子关系的结点，则树中共有n-1条边 思考：如何从定义中推断非根结点有且仅有一个父结点? • T中有且仅有一个特殊结点r ∈ T，称为树根； • 其它结点T − {r}划分为m(≥ 0)个互不相交的子集T1, T2, … , Tm， 每个子集Ti i ∈ 1, m 也是树，称为根结点r的子树； • 如果 Ti > 0，子树的根 ri ∈ Ti是r的子结点，r是ri的父结点。 5.2 树的定义与结构 5.2 树的定义与结构 树的结构示例： 树 T = {A, B, C, D, E, F, G, H, I, J, K, L, M} • 树根：A • 子树：T1 = {B, E, F, G, K, L}，B为根 T2 = {C, H}, C为根 T3 = {D, I, J, M}, D为根 • 父子关系: <A, B>、<A, C>、<A, D> T1也是树（递归定义） • 树根：B • 子树：{E}, {F, K, L}, {G} • 父子关系：<B, E>, <B, F>, <B, G> 树的基本术语 5.2 树的定义与结构 • 结点的度：子结点或非空子树的个数 • 树的度：树中所有结点的度的最大值 • 叶结点：树中度为0的结点 • 中间结点：树中叶结点以外的结点，亦称内部结点 • 兄弟结点：父结点相同的结点彼此是兄弟结点 • 结点的层次：根结点在第1层；如果结点的层次是𝑘 (𝑘≥1) ，则其子结点都在第𝑘+1层。 亦称结点的深度 • 结点的高度：叶结点的高度等于1；中间结点的高度等于其所有子结点的高度的最大 值加1 • 树的高度：根结点的高度，亦称树的深度 • 有序树：树中各结点的子树从左向右依次排列，不能交换次序；否则称作无序树 • 森林：零个或多个互不相交（独立）的树的集合 树的基本术语 5.2 树的定义与结构 数据结构 结点度结点高度 34 层次（深度） 1 2 3 4 叶结点：E, G, H, J, K, L, M 树的高度：4 树的度：3 中间结点：A, B, C, D, F, I 33 12 23 22 12 0101 010101 01 01 兄弟结点：{B, C, D} / {E, F, G} / {I, J} / {K, L} 树的基本术语 5.2 树的定义与结构 数据结构 • 祖先结点：根没有祖先；父结点以及父结点的祖先都是结点的祖先结点 • 子孙结点：叶结点没有子孙；中间结点的各子结点以及子结点的子孙都 是它的子孙结点 • 以任一结点为根的子树中包 含所有且仅有该结点的子孙 (1) 根结点是其它所有结点的祖先 (2) 如果结点u是结点v的祖先，则 存在路径<r1, r2, … , rn>，满足 r1=u, rn=v 且 ri 是 ri+1 的父结点 (0<i<n) (3) 由于任何非根结点有且仅有一 个父结点，从祖先结点u到子孙结 点v的路径是唯一的 结点B的子孙：{E, F, G, K, L} 树的基本操作 5-2 树的定义与结构 • InitTree(tree): 初始化一个空树tree • CreatTree(tree, definition): 按照definition构造一个树 • IsEmpty(tree): 树tree为空返回true, 否则返回false • Root(tree): 返回树tree的根结点 • Get(tree, node): 返回树tree的结点node的值 • Parent(tree, node): 返回树tree中结点node的父结点 • GetChild(tree, node, k): 返回树tree中结点node的第k个子树 • InsertChild(tree, node, k, subtree): 将树subtree插入到树tree中，使其成为结点node的第k个子树 • Search(tree, x): 在树tree中查找值为x的结点，如果查找成功，返回结点，否则返回NIL • Traverse(tree): 访问树tree中每个结点，且每个结点只访问一次 5.3.1 二叉树的定义 5.3 二叉树 数据结构 二叉树是应用最广泛的 树形结构 二叉树每个结点有且仅有两个子树， 并且子树有左右区别（有序树） 二叉树的定义： 二叉树是由结点组成的有限集合T，用|T|表示结点的数量。树具备以 下性质： （1） |T| = 0，T是空树。 （2） T > 0，T中有且仅有一个特殊结点r ∈ T，称为二叉树的根结 点；其它结点T − {r}划分为两个不相交的子集TL和TR。TL是r的左子树， 本身是一棵二叉树，如果 TL > 0, TL的根rL是r的左子结点，r是rL的父结 点；TR是r的右子树，也是一棵二叉树，如果 TR > 0，其根rR是r的右子 结点，r是rR的父结点。 5.3.1 二叉树的定义 5.3 二叉树 数据结构 二叉树的基本形态： 空树 单根树 左子树 非空， 右子树 是空树 左子树 是空树， 右子树 非空 左子树和右 子树都非空 只有一个结点 有序树 二叉树的基本操作 5-3 二叉树 • BinaryTreeNode(): 创建一个二叉树结点 • Height(tree): 返回二叉树tree的高度（深度） • PreOrder(tree): 前序遍历二叉树tree • InOrder(tree): 中序遍历二叉树tree • PostOrder(tree): 后序遍历二叉树tree • LevelOrder(tree): 层序遍历二叉树tree • CreatBinaryTree(value, left_tree, right_tree): 构造二叉树，根结点的数据为value, 左子树和右子树分别是left_tree和right_tree • IsLeaf(tree, node): 如果二叉树tree中结点node为叶结点，返回true；否则返回false 5.3.2 满二叉树、完全二叉树、完美二叉树 5.3 二叉树 数据结构 满二叉树：由度为0的叶结点和度为2的中间结点构成的二叉树，树中没有度为1 的结点 满二叉树 非满二叉树 满二叉树实例：哈夫曼树、表达式树 形态结构特殊、应用广泛的二叉树 5.3.2 满二叉树、完全二叉树、完美二叉树 5.3 二叉树 数据结构 完全二叉树 高度𝟏 ≤ 𝒅 ≤ 𝟑的所有完全二叉树 完全二叉树实例：堆 形态结构特殊、应用广泛的二叉树 5.3.2 满二叉树、完全二叉树、完美二叉树 5.3 二叉树 数据结构 完全二叉树 高度𝒅 > 𝟑的完全二叉树基本形态 (1) 从第1层到第𝑑−2层全是度为2的中间结点 (2) 第𝑑层的结点都是叶结点，度为0 (3) 在第𝑑−1层，各结点的度从左向右单调非递增排列，同时度为1的 结点要么没有，要么只有一个且该结点的左子树非空 形态结构特殊、应用广泛的二叉树 没有度为1的中间结点 只有一个度为1的中间结点且左子树非空 5.3.2 满二叉树、完全二叉树、完美二叉树 5.3 二叉树 数据结构 完全二叉树 (1) 从第1层到第𝑑−2层全是 度为2的中间结点 (2) 第𝑑层的结点都是叶结点， 度为0 (3) 在第𝑑−1层，各结点的度 从左向右单调非递增排列， 同时度为1的结点要么没 有，要么只有一个且该结 点的左子树非空 非完全二叉树示例 理由：度为0的结点D 在度为2的结点E的左 边，不满足条件(3) 理由1： 结点C的度为1， 不满足条件(1) 理由2：结点E的度为1， 但左子树为空，不满足 条件(3) 形态结构特殊、应用广泛的二叉树 5.3.2 满二叉树、完全二叉树、完美二叉树 5.3 二叉树 数据结构 完美二叉树：对于高度（深度）为𝑑 ≥ 1 的完全二叉树，如果第d-1层所有结点的 度都是2，则该树是一个完美二叉树 完美二叉树中的所有子树都是完美二叉树 去掉完全二叉树最下层的叶结点，由此生 成的树是完美二叉树 形态结构特殊、应用广泛的二叉树 5.3.2 满二叉树、完全二叉树、完美二叉树 5.3 二叉树 数据结构 扩充二叉树：在二叉树结点的空子树位置添加特殊的结点：空树叶，形成的二叉 树称作扩充二叉树 二叉树中所有结点都被扩充成 度为2的中间结点 扩充二叉树是满二叉树，并且 所有的叶结点都是空树叶 形态结构特殊、应用广泛的二叉树 5.3.3 二叉树基本性质 5.3 二叉树 数据结构 命题5-1：设非空二叉树中度为𝒊∈[𝟎,𝟐]的结点数为𝐧i ，则𝐧𝟎=𝐧𝟐+𝟏。 证明： (1) 结点总数 𝑛 = 𝑛0 + 𝑛1 + 𝑛2，其中子结点（边）数目等于𝑛 − 1 （根除外） (2) 中间结点数目为𝑛1 + 𝑛2，并且每个中间结点的子结点都不是其它任何结点的子结点！因此，共有 2𝑛2 + 𝑛1条边，或者说子节点 (3) 根据(1)和(2), 子结点（边）数目：𝑛 − 1 = 𝑛0 + 𝑛1 + 𝑛2 − 1 = 2𝑛2 + 𝑛1 综合上述分析，可得 𝑛0 = 𝑛2 + 1，命题得证。 定理5-1：（满二叉树定理）非空满二叉树中叶结点数等于中间结点数加1。 证明：满二叉树没有度为1的中间结点，由命题5-1直接得证 5.3.3 二叉树基本性质 5.3 二叉树 数据结构 命题5-2：二叉树的第𝑖层最多有 2𝑖−1 个结点 (𝑖 ≥ 1) 。 证明： 第1层只有根结点，即20个结点。 假设第𝑖 − 1层有2𝑖−2 个结点 𝑖 > 1 。由于每个结点最多只有两个子结 点，则第𝑖层的结点数不会超过第𝑖 − 1层结点数的2倍，即2 𝑖−1 个结点。 命题5-3：深度（高度）为𝑑(≥ 1)的二叉树最多有 2𝑑 − 1 个结点。 证明：根据命题5-2，二叉树第𝑖 ∈ [1, 𝑑]层最多有 2 𝑖−1 个结点，因此结 点数的最大值等于： ෍ 𝑖=1 𝑑 2𝑖−1 = 2𝑑 − 1 5.3.3 二叉树基本性质 5.3 二叉树 数据结构 定理5-2：深度（高度）为𝑑(≥ 1)的二叉树是完美二叉树的充分必要条件是 树中有 2𝑑 − 1 个结点。 充分条件 (1) 根据命题5-3，结点总数等于2 𝑑 − 1 说明每层的结点数达到最大值 (2) 根据命题5-2，第𝑖 + 1层的结点数是 第 𝑖 层的结点数的2倍(1 ≤ 𝑖 < 𝑑) (3) 根据(2), 二叉树从第1层到第𝑑 − 1层 都是度为2的中间结点 因此，结点数达到最大值的二叉树是完 美二叉树 必要条件 (1) 完美二叉树第1层的结点数为2 0 (2) 对所有1 ≤ 𝑖 < 𝑑 ，第𝑖层的结点都是 度为2的中间结点 (3) 第𝑖 + 1层的结点数是第 𝑖 层的结点数 的2倍，即 2𝑖 个结点 因此，完美二叉树的结点总数： σ𝑖=1 𝑑 2𝑖−1 = 2𝑑 − 1 完全二叉树的分层编号 5.3 二叉树 数据结构 完全二叉树的结构特征 设完全二叉树的深度（高度）为𝑑(≥ 1) (1) 从第1层到第𝑑 − 1层的结点构成完 美二叉树 (2) 第𝑑 − 1层结点的度从左向右非递增 排列，并且度为1的结点最多1个且 左子树非空 (3) 根据(2)，第𝑑层的叶结点连续集中 在最左边 分层编号 (1) 根编号为1 (2) 第𝑖 ∈ [2, 𝑑]层，左端结点设置为2𝑖−1 (3) 同一层结点，从左向右连续编号 实现对所有结点从上至下、从左向右连续编号！ 5.3.3 二叉树基本性质 5.3 二叉树 数据结构 定理5-3：完全二叉树有𝑛个结点(𝑛 ≥ 1)，按层次从左向右连续编号。树中 任一结点𝑘 (1 ≤ 𝑘 ≤ 𝑛)满足以下性质 (1) 如果2𝑘 ≤ 𝑛，则结点 𝑘 的左子结点是 2𝑘，否则没有左子结点； (2) 如果2𝑘 + 1 ≤ 𝑛 ，则结点 𝑘 的右子结点是2𝑘 + 1 ，否则没有右子结点。 (3) 如果 𝑘 > 1，则结点 𝑘 的父结点是 𝑘 2 。 定理5-3是完全二叉树实现顺序存储以及二叉堆的重要性质！ 命题5-4：有𝑛个结点(𝑛 ≥ 1)的完全二叉树的深度𝑑 = log2(𝑛 + 1) 。 证明：根据定理5-2和命题5-3， 2𝑑−1 − 1 < 𝑛 ≤ 2𝑑 − 1 5.3.4 二叉树的顺序存储实现 5.3 二叉树 数据结构 二叉树的主要存储方式：顺序存储 + 链接存储 完全二叉树的顺序存储：完全二叉树所有结点可以分层从左向右连续编号，可用 一组地址连续的存储单元（顺序表）存储二叉树的各个结点 各结点的索引（编号）与顺序表位置一一对应， 结点的数据存放在顺序表相应位置的单元中 5.3.4 二叉树的顺序存储实现 5.3 二叉树 数据结构 非完全二叉树的顺序存储 (1) 结点编号：树根的索引为1；设结点的编号为𝑘 (𝑘≥1)，如果其左子树非空，则 左子结点的编号为2𝑘；如果右子树非空，则右子结点为2𝑘+1 (2) 顺序存放：用一组地址连续的存储单元存储二叉树的各个结点 各结点的索引（编号）与顺序表位置一一对应， 结点的数据存放在顺序表相应位置的单元中 5.3.4 二叉树的顺序存储实现 5.3 二叉树 数据结构 优点 (1) 只需用顺序表存放结点数据，不需要 保存结点间逻辑关系 (2) 结点间逻辑关系可通过相对位置确定 (3) 对于顺序存储结构第 𝑘 个位置的结 点 (𝑘≥1), 其左右子结点分别存储在 第2𝑘和第2𝑘+1个位置，父结点在位 置 𝑘/2 。因此查找子结点和父结点 只需O(1)的时间 (4) 顺序结构是完全二叉树最简单、最节 省空间的存储方式，n个结点只需 O(n)的空间 缺点 (1) 对一般的二叉树，可能造成空间浪费 (2) 在最坏情况下，存放n个结点的二叉 树可能需要长度为O(2n)的顺序表 (3) 可用其它序列化的方法降低顺序存储 的空间复杂度，但无法通过在顺序表 中的相对位置直接确定两个结点是否 有父子关系，增加了查询结点间逻辑 关系的时间复杂度 5.3.5 二叉树的链接存储实现 5.3 二叉树 数据结构 二叉树的主要存储方式：顺序存储 + 链接存储 链接存储：使用链表存放二叉树，比顺序存储能更有效地表达二叉树的非线性逻 辑结构 数据域 data 左指针域 left 右指针域 right 数据域 data 左指针域 left 右指针域 right 父结点指 针域 parent 二叉链表 三叉链表 指向左子结点 指向右子结点 指向左子结点 指向右子结点 指向父结点 5.3.5 二叉树的链接存储实现 5.3 二叉树 数据结构 链接存储：使用链表存放二叉树，比顺序存储能更有效地表达二叉树的非线性逻 辑结构 逻辑结构 二叉链表存储结构 存放𝑛个结点的二叉树只需𝑛个二叉链表结点，空间复杂度为O(𝑛) 用指针tree表示二叉树 构造二叉树的算法 5-3 二叉树 算法5-1：构造二叉树 CreateBinaryTree(value, left_tree, right_tree ) 输入：结点数据value, 二叉树left_tree和right_tree 输出：以value为根结点数据、left_tree和right_tree为左右子树的二叉树 tree ← new BinaryTreeNode() //生成新的二叉链表结点 tree.data ← value //设置根结点的数据 tree.left ← left_tree //设置根的左子树 tree.right ← right_tree //设置根的右子树 return tree //返回构造的二叉树 5.4.1 二叉树遍历的基本概念 5.4 二叉树的遍历 数据结构 遍历的概念：按预先设定的顺序依次访问树中所有结点，并且每个结点仅访问一次 深度优先遍历：按序独立处理二叉树的各个分支单元：根r、左子树L和右子树R 广度优先遍历：按层从上至下、从左向右依次访问树中所有结点，也称作层序遍历 r L R 3种深度优先遍历方案： (1) rLR — 前序 (2) LrR — 中序 (3) LRr — 后序 深度优先遍历 (1) 递归思想：对左子树L和右子树R按相同 的方案进行遍历 (2) 深度原则：独立处理各分支，即在访问 完一个分支的所有结点后，才能开始遍 历下一个分支 (3) 限制子树的遍历顺序：对子树的遍历始 终按从左向右的顺序进行 5.4.2 二叉树遍历的递归算法 5.4 二叉树的遍历 数据结构 前序遍历方案 (1) 访问根结点r (2) 前序遍历左子树L (3) 前序遍历右子树R r L R 中序遍历方案 (1) 中序遍历左子树L (2) 访问根结点r (3) 中序遍历右子树R 后序遍历方案 (1) 后序遍历左子树L (2) 后序遍历右子树R (3) 访问根结点r 5.4.2 二叉树遍历的递归算法 5.4 二叉树的遍历 数据结构 前序遍历：<A, B, D, H, I, E, J, C, F, K> 中序遍历：<H, D, I, B, E, J, A, F, K, C> 后序遍历：<H, I, D, J, E, B, K, F, C, A> 根结点位置： • 前序遍历的最前 • 后序遍历的最后 • 中序遍历出现在左子树和右子树遍历结果之间 遍历二叉树并按序输出结点数据 递归算法 5-4 二叉树的遍历 算法5-2. 前序遍历二叉树 PreOrder(tree) if tree ≠ NIL then //空树不做处理，直接返回 | Visit(tree) //访问根结点 | PreOrder(tree.left) //前序遍历左子树 | PreOrder(tree.right) //前序遍历右子树 end 算法5-3. 中序遍历二叉树 InOrder(tree) if tree ≠ NIL then | Inorder(tree.left) //中序遍历左子树 | Visit(tree) //访问根结点 | InOrder(tree.right) //中序遍历右子树 end 算法5-4. 后序遍历二叉树 PostOrder(tree) if 𝑡𝑟𝑒𝑒 ≠ NIL then | Postorder(tree.left) //后序遍历左子树 | PostOrder(tree.right) //后序遍历右子树 | Visit(tree) //访问根结点 end 后序遍历递归算法的应用 5-4 二叉树的遍历 算法5-5. 计算二叉树高度 Height(tree) 输入：二叉树tree 输出：二叉树的高度值 if tree = NIL then //空树 | return 0 //空树的高度为0 else | h_left ← Height(tree.left) //遍历左子树，求子树的高度 | h_right ← Height(tree.right) //遍历右子树，求子树的高度 | return Max(h_left, h_right) + 1 //树的高度等于左右子树高度 // 的较大值加1 end 表达式树 5.4 二叉树的遍历 数据结构 算术表达式：由常数、运算符和括号组成，有前缀、中缀、后缀三种表示法 • 中缀表示法：9 + (6 + 3 * 2) / (8 / (5 - 3)) • 前缀表示法：+ 9 / + 6 * 3 2 / 8 - 5 3 • 后缀表示法：9 6 3 2 * + 8 5 3 - / / + 表达式树：表示算术表达式（非线性）逻辑结构的二叉树 中缀表达式的递归定义 (1) 单个常数是表达式 (2) 若exp1、exp2是表达式， 则 (exp1) op (exp2) 也是 表达式 (op表示运算符) 表达式树 (1) 单个常数用单根树表示 (2) 若表达式包含多个常数及运算符，将表达 式分解成(expr_left) op (expr_right) (3) 用根结点表示运算符op，并用左右子树 分别表示expr_left和expr_right（递归） 转换 表达式树 5.4 二叉树的遍历 数据结构 9 + (6 + 3 * 2) / (8 / (5 - 3)) 转换 中缀表达式 表达式树 • 叶结点都对应常数 • 每个中间结点都存放一个运算符 • 表达式树是满树 • 根结点是表达式中优先级最低的运算符 表达式树 5.4 二叉树的遍历 数据结构 表达式树 • 前序遍历结果：+ 9 / + 6 * 3 2 / 8 - 5 3 • 后序遍历结果：9 6 3 2 * + 8 5 3 - / / + • 中序遍历结果：9 + 6 + 3 * 2 / 8 / 5 – 3 没有括号，不是正确的中缀表达式！ 表达式：9 + (6 + 3 * 2) / (8 / (5 - 3)) 需要对左右子树生成的表达式加上括号 = 前缀表示法 = 后缀表示法 ≠ 中缀表示法 将表达式树转换成中缀表达式的算法 5-4 二叉树的遍历 算法5-6. PrintInfixExpression(tree) 输入：非空二叉树tree 输出：中缀表达式（含冗余括号） if tree.left ≠ NIL then //左子树非空 | print ( //输出左括号 | PrintInfixExpression(tree.left) //中序遍历左子树并生成表达式 | print ) //输出右括号，与前面左括号一起将表达式加上括号 end print tree.data //若结点是叶结点，输出常数；否则，输出运算符 if tree.right ≠ NIL then //右子树非空 | print ( //输出左括号 | PrintInfixExpression(tree.right) //中序遍历右子树并生成表达式 | print ) //输出右括号，与前面左括号一起将表达式加上括号 end 表达式树 5.4 二叉树的遍历 数据结构 表达式树 • 前序遍历结果：+ 9 / + 6 * 3 2 / 8 - 5 3 前缀表示法 • 后序遍历结果：9 6 3 2 * + 8 5 3 - / / + 后缀表示法 • 算法5-6：(9)+(((6)+((3)*(2)))/((8)/((5)-(3)))) 中缀表示法 表达式：9 + (6 + 3 * 2) / (8 / (5 - 3)) • 通过遍历将表达式树转换为算术表达式的 时间复杂度是O(n), n表示结点数目 • 思考：如何将算术（中缀）表达式转换为 表达式树，分析需要使用的关键数据结构 5.4.3 二叉树遍历的非递归算法 5.4 二叉树的遍历 数据结构 递归算法的问题： (1) 存在不支持递归算法的程序设计语言 (2) 递归算法在运行中，需要系统在内存栈中分配空间保存函数的参数、返回地 址以及局部变量等，运行效率较低 (3)系统对每个进程分配的栈容量有限，如果二叉树的深度太大造成递归调用的 层次太高，容易导致栈溢出 非递归算法实现的关键：使用栈结构模拟函数调用中系统栈的工作原理 算法5-7：非递归前序遍历 PreOrder(tree) 5-4 二叉树的遍历 InitStack(stack) //初始化栈stack，用于存放结点 while tree ≠ NIL 或 IsEmpty(stack) = false do | while tree ≠ NIL d𝐨 //当前结点不是空结点 | | Visit(tree) //访问结点 | | Push(stack, tree) //结点压入栈 | | tree ← tree.left //沿左分支下移 | end | if IsEmpty(stack) = false then //如果栈不为空 | | tree ← Top(stack) | | Pop(stack) //弹出栈顶结点 | | tree ← tree.right //移到栈顶结点的右子树 | end end DestroyStack(stack) 沿左分支下移，并将 经过的结点压入栈 tree=NIL表示左子 树为空，或者左子树 遍历结束，则从栈中 弹出结点，开始遍历 结点的右子树 算法5-8：非递归中序遍历 InOrder(tree) 5-4 二叉树的遍历 InitStack(stack) //初始化栈stack，用于存放结点 while tree ≠ NIL 或 IsEmpty(stack) = false do | while tree ≠ NIL d𝐨 //当前结点不是空结点 | | Push(stack, tree) //结点压入栈 | | tree ← tree.left //沿左分支下移 | end | if IsEmpty(stack) = false then //如果栈不为空 | | tree ← Top(stack) | | Visit(tree) //访问栈顶结点 | | Pop(stack) //弹出栈顶结点 | | tree ← tree.right //移到栈顶结点的右子树 | end end DestroyStack(stack) 沿左分支下移，并将 经过的结点压入栈 tree=NIL表示左子 树为空，或者左子树 遍历结束，则从栈中 弹出结点，开始遍历 结点的右子树 5.4.3 二叉树遍历的非递归算法 5.4 二叉树的遍历 数据结构 后序遍历算法的非递归化 二叉树所有结点的后序遍历次序，用各结点左 边的数字表示 后序遍历次序的结点序列可分为多个段，用 虚线分开，每段中的结点具有以下性质 ： (1) 段中各结点的访问次序是连续的，并且 最先访问（次序最小）的结点没有右子 结点 (2) 段中若有多个结点，则次序相邻的任意 两个结点，次序小的结点是次序大的结 点的右子结点 (3) 段中次序最大的结点如果不是根，则是 其父结点的左子结点 算法5-9：非递归后序遍历 PostOrder(tree) 5-4 二叉树的遍历 InitStack(stack) while tree ≠ NIL 或 IsEmpty(stack) = false do | while tree ≠ NIL d𝐨 //当前结点不是空结点 | | Push(stack, tree) //结点压入栈 | | tree ← tree.left //沿左分支下移 | end | | top ← Top(stack) //stack非空，top指向栈顶结点 | pre_top ← NIL //初始化 pre_top | //如果栈顶结点的右子树为空，开始从栈弹出结点 沿左分支下移，并将经 过的结点压入栈，找到 下一个要访问的段， while结束时栈顶为该 段中被最后访问的那个 开始时，pre_top = NIL (continue) 5-4 二叉树的遍历 | while IsEmpty(stack) = false 且 top.right = pre_top do | | Visit(top) //访问当前栈顶结点 | | pre_top ← top //栈顶结点传给pre_top | | Pop(stack) //弹出栈顶结点 | | if IsEmpty(stack) = false then | | | top ← Top(stack) //栈非空，top指向新的栈顶结点 | | else | | | top ← NIL //空栈，top赋值NIL，结束遍历 | | end | end | if top ≠ NIL then | | tree ← top.right //移到栈顶结点的右子树并开始遍历 | end end DestroyStack(stack) 从右子树为空 的结点开始。 依次弹出各段 中的结点 若弹出的结点 是新栈顶结点 的右子结点， 继续弹出 5.4.3 二叉树遍历的非递归算法 5.4 二叉树的遍历 数据结构 递归算法的问题： (1) 存在不支持递归算法的程序设计语言 (2) 递归算法在运行中，需要系统在内存栈中分配空间保存函数的参数、返回地址以及 局部变量等，运行效率较低 (3)系统对每个进程分配的栈容量有限，如果二叉树的深度太大造成递归调用的层次太 高，容易导致栈溢出 非递归算法实现的关键：使用栈结构模拟函数调用中系统栈的工作原理 非递归算法分析：前序、中序和后序的非递归算法均使用一个存放结点的栈实现，并且 在遍历过程中每个结点都有且仅有1次入栈和1次出栈的机会，因此算法的时间复杂度和 空间复杂度都是O(n)，其中n表示二叉树的结点数 层序遍历 5.4 二叉树的遍历 数据结构 广度优先遍历：从根结点开始，从上至下按层访问每个结点，并且每层的结点按 照从左向右的顺序进行处理 层序遍历方案通常设计成非递归的算法，可以用队列结构来实现 层序遍历：<A, B, C, D, E, F, H, I, J, K > 算法5-10：层序遍历二叉树 LevelOrder(tree) 5-4 二叉树的遍历 InitQueue(queue) //初始化队列queue，用于存放结点 EnQueue(queue, tree) //树根结点入队 while IsEmpty(queue) = false do | node_ptr ← GetFront(queue) //取出队首结点 | DeQueue(queue) //队首出队 | if node_ptr ≠ NIL then //结点非空 | | Visit(node_ptr) //访问结点 | | EnQueue(queue, node_ptr.left) //左子结点入队 | | EnQueue(queue, node_ptr.right) //右子结点入队 | end end DestroyQueue(queue) 层序遍历 5.4 二叉树的遍历 数据结构 广度优先遍历：从根结点开始，从上至下按层访问每个结点，并且每层的结点按 照从左向右的顺序进行处理 层序遍历：<A, B, C, D, E, F, H, I, J, K > 算法分析：二叉树的每个结点都会入队1次，然后出队1次，因此层序遍历的时间 复杂度为O(n)，与深度优先遍历相同 5.4.4 二叉树的序列化与反序列化 5.4 二叉树的遍历 数据结构 二叉树的序列化：按某种遍历方案访问所有结点并依次输出结点数据，由此形成 结点的线性序列 二叉树的反序列化：根据线性序列重构原始的二叉树 问题： 序列化的作用：将树的非线性结构转换成线性结构，便于使用线性表或字符串等存储 • 完全二叉树的顺序存储是一种 序列化方案，并且可以根据结 点间的相对位置确定它们之间 的逻辑关系，重构出二叉树 • 但该方法对于一般的二叉树可 能造成空间浪费，在最坏情况 下，空间复杂度达到O(2n) • 常用的前序遍历或层序遍历算 法，产生的结点序列只包含了 树结构的部分信息，通常无法 重构二叉树 5.4.4 二叉树的序列化与反序列化 5.4 二叉树的遍历 数据结构 二叉树的序列化：按某种遍历方案访问所有结点并依次输出结点数据，由此形成 结点的线性序列 二叉树的反序列化：根据线性序列重构原始的二叉树 前序遍历：<A, B, D, H, I, E, J, C, F, K> 从序列中，最多只能确定A是根结 点，其它信息，如左子树包含哪些 结点等无法确定 问题：如何使前序遍历的结果能 够重构二叉树？ 5.4.4 二叉树的序列化与反序列化 5.4 二叉树的遍历 数据结构 二叉树的序列化：按某种遍历方案访问所有结点并依次输出结点数据，由此形成 结点的线性序列 二叉树的反序列化：根据线性序列重构原始的二叉树 序列化方法 • 用特殊符号#表示空结点 • 当在前序遍历过程中遇到空结点或空 子树时，不是直接返回，而是输出符 号#，从而将空结点也标记在序列中 前序序列 5.4 二叉树的遍历 数据结构 二叉树前序序列化：前序遍历二叉树，如果结点非空，输出结点数据，否则输出# <A, B, D, H, #, #, I, #, #, E, #, J, #, #, C, F, #, K, #, #, #> 前序序列 通过在结点序列中插入空记号，记录二叉树的非线性结构 算法5-11：二叉树前序序列化 PreOrderSerialize(tree ) 5-4 二叉树的遍历 输入：二叉树tree 输出：二叉树的前序序列 if tree = NIL then //空树 | print # //输出特殊符号，代表空结点 else | print tree.data //输出结点数据 | PreOrderSerialize (tree.left) //对左子树前序序列化 | PreOrderSerialize (tree.right) //对右子树前序序列化 end 基于前序遍历算法 前序序列 5.4 二叉树的遍历 数据结构 前序序列的反序列化 <A, B, D, H, #, #, I, #, #, E, #, J, #, #, C, F, #, K, #, #, #> 前序序列 从前序序列先端依次读取数据， 执行下面的操作： • 如果读取的数据是#，则返 回NIL，表示空结点或空树 • 否则新建二叉树结点，把数 据代入结点并递归地重构结 点的左子树和右子树，然后 返回结点。 算法5-12：二叉树前序序列的反序列化 PreOrderDeSerialize(preorder, n) 5-4 二叉树的遍历 k ← k + 1 tree ← NIL //初始化一个空树 if k < n then //k是线性表的有效序号 | data ← Get(preorder, k) //读出线性表第k个元素 | if data ≠ # then //非空记号 | | tree ← new BinaryTreeNode( ) //新建二叉树结点 | | tree.data ← data //代入数据 | | tree.left ← PreOrderDeSerialize(preorder, n) //重构左子树 | | tree.right ← PreOrderDeSerialize(preorder, n) //重构右子树 | end end return tree //返回新建的二叉树或空树 输入：存放二叉树前序序列的线性表preorder，表中元素个数n (n>0) 输出：二叉树 全局变量：k，初始值为-1 二叉树的序列化：按某种遍历方案访问所有结点并依次输出结点数据，由此形成 结点的线性序列 二叉树的反序列化：根据线性序列重构原始的二叉树 思考： （1）与前序序列类似，在二叉树的层序遍历过程中，输出表示空结点的标记，可生成二叉树的层 序序列，并根据层序序列重构二叉树（过程及算法参考教材） （2）（经典问题）用前序遍历与中序遍历结果重构二叉树，分析重构条件及算法的时间复杂度 5.4.4 二叉树的序列化与反序列化 5.4 二叉树的遍历 数据结构 前序遍历：<A, B, D, H, I, E, J, C, F, K> 中序遍历：<H, D, I, B, E, J, A, F, K, C> 5.5.1 最优二叉树 5.5 哈夫曼树 数据结构 带权二叉树：每个叶结点带有一个权重值（正数）的二叉树 叶结点的带权路径长度：等于𝑤𝑖𝑙𝑖，其中𝑤𝑖是叶结点的权重， 𝑙𝑖是从根到叶结点的 路径长度，即从根到该结点经过的分支数 树的带权路径长度：树中所有叶结点的带权路径长度之和 带有相同权重集 {1, 2, 3, 4 ,5} 的三棵带权二叉树 ෍ 𝑖=1 𝑛 𝑤𝑖𝑙𝑖WPL = 5.5.1 最优二叉树 5.5 哈夫曼树 数据结构 带权二叉树：每个叶结点带有一个权重值（正数）的二叉树 带有相同权重集 {1, 2, 3, 4 ,5} 的三棵带权二叉树 WPL(a) = 1 × 3 + 2 × 3 + 3 × 3 + 4 × 3 + 5 × 1 = 35 WPL(b) = 1 × 3 + 2 × 3 + 3 × 2 + 4 × 2 + 5 × 2 = 33 WPL(c) = 1 × 3 + 2 × 3 + 3 × 3 + 4 × 2 + 5 × 2 = 36 最小值 最优二叉树：给定一组叶结点权重，由此构建的所有带权二叉树中，带权路径长 度最小的二叉树，亦称哈夫曼树 最优二叉树基本性质 5.5 哈夫曼树 数据结构 定理5-4 ：最优二叉树（哈夫曼树）是满二叉树 证明：假设带权二叉树中存在度为1的中间结点。删除度为1的中间结点并把其唯 一的子结点与父结点直接相连，使得从树根到该中间结点的所有子孙结点的路径 长度减1，能够减小树的带权路径长度。因此，最优二叉树不含度为1的中间结点。 减小树的带权路径长度， 使其成为最优二叉树 删除度为1 的中间结点 命题5-5：最优二叉树中，如果两个叶结点的权重值不同，则权重值小的叶结点在 树中的层数大于等于权重值大的叶结点 最优二叉树基本性质 5.5 哈夫曼树 数据结构 证明：反证法。 • 设最优二叉树T的带权路径长度为WPL(T)，其中叶结点u的权重wu小于叶结点v的权 重wv，即wu < wv • 首先假定u在树中的层数比v的层数小，即level(u)<level(v) • 交换叶结点u和v，可得新的带权二叉树T*, 且 WPL(T*) = WPL(T) + wu(level(v) - level(u)) + wv(level(u) - level(v)) < WPL(T) 与T是最优二叉树矛盾。证明 level(u) ≥ level(v)。 交换权重值相同或者在树中同一层上的两个叶 结点，不会改变二叉树的带权路径长度 命题5-6：给定一组叶结点权重，存在最优二叉树，权重最小和次小的叶结点在树 的最下层并且互为兄弟结点。 最优二叉树基本性质 5.5 哈夫曼树 数据结构 证明： • 最优二叉树是满树，因此最下层必有两个以上的叶结点 • 如果权重最小的叶结点不在最下层，则最下层所有结点的权重都必须 等于最小值，因此可以通过交换把权重最小的叶结点移到最优二叉树 的最下层 • 同理可证权重次小的叶结点也在最下层 • 在最下层权重最小叶结点必有兄弟结点（满二叉树）。如果权重最小 结点和次小结点不是兄弟，可以把最小结点的兄弟与次小结点交换， 使两个结点共有一个父结点 中间结点的权重：除了叶结点带有权重，带权二叉树各中间结点也可定义权重， 等于它的左子结点和右子结点的权重之和 哈夫曼算法：一种至下而上构建最优二叉树的方法，通过不断合并两个带权二叉 树，最终生成最优二叉树，具体过程如下： 哈夫曼算法 5.5 哈夫曼树 数据结构 (1) 对于给定的一组权重w1,w2,…,wn (n≥2)，首先创建n个只有一个结点（叶结点） 的二叉树 T={T1, T2, …, Tn}，其中Tj 的根结点权重为wj (1≤j≤n)； (2) 创建新的结点，并从T中取出根结点权重最小和次小的两个二叉树， 分别作为新 结点的左右子树，设置结点的权重为左右子树的根结点权重之和； (3) 把(2)构成的新二叉树插入二叉树集T中； (4) 重复(2)和(3)的操作，直到T中只剩一个二叉树。最后剩下的二叉树就是所要构建 的哈夫曼树。 哈夫曼算法：一种至下而上构建最优二叉树的方法，通过不断合并两个带权二叉 树，最终生成最优二叉树 哈夫曼算法 5.5 哈夫曼树 数据结构 首先创建5棵单根树 最优二叉树的构建过程 每次合并左端根权重 最小和次小的两棵树 哈夫曼树 算法5-15：创建哈夫曼树 CreateHuffmanTree(w ) 5-4 二叉树的遍历 tree_set ← ∅ //二叉树集合的初始化 n ← Length(w) //n个权重 for i ← 1 to n do //初始化n个二叉树 | tree ← new BinaryTreeNode( ) //创建叶结点 | tree.left ← NIL | tree.right ← NIL | tree.weight ← Extract(w) //从数据集w中取出一个值，作为结点权重 | Insert(tree_set, tree) //将单结点二叉树放入集合tree_set end | //合并二叉树 输入：权重值的数据集w，|w| ≥ 2 输出：哈夫曼树 • 时间TW_Extract • 时间TQ_Insert 算法5-15：创建哈夫曼树 CreateHuffmanTree(w ) 5-4 二叉树的遍历 | for i ← 1 to n-1 do //合并二叉树，共n-1次 | tree ← new BinaryTreeNode( ) //新建树根结点 | tree.left ← ExtractMin(tree_set) //取出根权重最小树作为左子树 | tree.right ← ExtractMin(tree_set) //取出根权重次小树作为右子树 | tree.weight ← tree.left.weight + tree.right.weight //设置新树的根权重 | Insert(tree_set, tree) //将新树插入集合tree_set end tree ← Extract(tree_set) //取出集合中唯一的二叉树，即哈夫曼树 return tree • 时间TQ_ExtractMin • 时间TQ_ExtractMin • 时间TQ_Insert • 时间TQ_Extract 哈夫曼算法：一种至下而上构建最优二叉树的方法，通过不断合并两个带权二叉 树，最终生成最优二叉树 算法分析： 哈夫曼算法 5.5 哈夫曼树 数据结构 • 用n个权重值创建了n个单根二叉树，并依次放入集合tree_set中，时间复杂 度为O(n)*(TQ_Insert + TW_Extract) • 合并两个二叉树的时间是2TQ_ExtractMin + TQ_Insert • 算法的时间复杂度等于 O(n)*TQ_Insert + O(n)*TQ_ExtractMin + O(n)*TW_Extract • 假设数据集w和tree_set直接用线性表实现，TQ_Insert和TW_Extract都是O(1)， 但TQ_ExtractMin= O(n)，即在tree_set中顺序查找权重最小二叉树的时间，因 此构建哈夫曼树的时间复杂度达到O(n2) • 更高效的构建方案是使用比线性表更复杂的数据结构，比如堆，这将在第6 章中介绍。 问题：如何传输由字母a、b、c、w、z组成的字符串“baaacabwbzc”？ 关键：需要将文字符串转换成计算机能够识别处理的二进制字符串（编码） 定长码：把每个字母转换成固定长度的二进制字符串 不定长码：使用频率高的字母采用短编码，频率小的采用长编码 哈夫曼编码 5.5 哈夫曼树 数据结构 定长码：a–000, b–001, c–010, w–011, z–100 baaacabwbzc 001000000000010000001011001100010 不定长码：a–01, b–00, c–10, w–110, z–111 baaacabwbzc 000101011001001100011110 编码 长度33 长度24 频率：a(4), b(3), c(2), w(1), z(1) 不定长码比定长码的编码效率高！ 编码 前缀码：一种常用的不定长码，每个字母的编码都不是其它字母编码的前缀 哈夫曼编码 5.5 哈夫曼树 数据结构 a–01, b–00, c–10, w–110, z–111 a–1, b–00, c–10, w–110, z–111 前缀码非前缀码 对二进制字符串解码会出现歧义 例： ”1101” → “wa” “1101” → “aca” 可用二叉树表示前缀码 前缀码：常用的不定长码，每个字母的编码都不是其它字母编码的前缀 哈夫曼编码 5.5 哈夫曼树 数据结构 a–01, b–00, c–10, w–110, z–111 前缀码 前缀码树 • 各结点的左分支对应0，右分支对应1 • 每个叶结点记录唯一的一个字母 • 从根到各叶结点经过的分支序列表示 对应字母的编码，同时编码长度等于 路径长度 • 各叶节点中的数值表示权重，等于对 应字母在字符串“baaacabwbzc” 中出 现的次数（频率） 字符串“baaacabwbzc” 的编码长度前缀码树的带权路径长度WPL 前缀码：常用的不定长码，每个字母的编码都不是其它字母编码的前缀 问题：给定一个字符串，求最优前缀码，使编码出的二进制字符串长度最短 哈夫曼编码 5.5 哈夫曼树 数据结构 字符串的编码长度 前缀码树的带权路径长度WPL 最优前缀码可用哈夫曼算法求解， 并把求得的前缀码称为哈夫曼编码 对应权重集{3,4,2,1,1}的哈夫曼树 a–01, b–00, c–10, w–110, z–111 是字符串“baaacabwbzc”的哈夫曼编码 算法5-16：使用哈夫曼树对二进制字符串解码 Decoding(tree, binary_code) 5-5 哈夫曼树 p ← tree //指向树根 n ← Length(binary_code) //二进制字符串长度 for i ← 0 to n-1 do | if binary_code[i] = 0 then | | p ← p.left //遇到0, 沿左分支下移 | else //binary_code[i] = 1 | | p ← p.right //遇到1, 沿右分支下移 | end | if p.left = NIL 且 p.right = NIL then //到达叶结点 | | print p.data //输出文字符 | | p ← tree //返回树根，重新开始解码 | end end 输入：非空前缀码树tree，二进制字符串binary_code 输出：解码后的文字符序列 算法分析 对长度为n的二进制字 符串，使用哈夫曼（前 缀码）树只需要O(n) 的 时间就能解码生成原来 的文字串 5.6.1 树的存储结构 5.6 树与森林 数据结构 与二叉树相似，树也有顺序存储与链接存储两种方式，而选择何种方式与在树结 点中记录哪些表示树逻辑结构的信息相关 常用的树逻辑结构表示法：父亲表示法、孩子表示法以及孩子兄弟表示法 父亲表示法 5.6 树与森林 数据结构 父亲表示法要求每个结点保存父结点的位置信息，也可称为父结点表示法 适合用顺序表来存储树的所有结点 对所有结点从0开始连续编号 结点数据包含两个域，一 个是数据域tree[i].data记 录树结点的数据元素，另 一个域tree[i].parent存放 父结点位置 可用顺序表存储树 根结点的父结点位置域是-1 算法5-17：查找父亲表示法的树的根结点FindRoot(tree, x) 5-6 树与森林 while tree[𝑥].parent≠ −1 do //结点𝑥有父结点，非根 | 𝑥 ← tree[𝑥].parent // 𝑥移动至父结点 end return 𝑥 输入：父亲表示法的树（顺序表）tree，结点（索引） 𝑥 输出：树tree的根结点索引 时间复杂度O(H), H表示树的高度 • 父亲表示法方便每个结点查找其祖先结点，而且每个结点 只需存放父结点位置，可节省存储空间 • 父亲表示法可用于实现并查集（不相交集） • 如果是查找结点的所有子结点或兄弟结点，父亲表示法需 要对整个树进行遍历，时间效率低 孩子表示法 5.6 树与森林 数据结构 与父亲表示法一样，用顺序表存储树，每个结点包含数据域，父结点位置域，以 及子结点链表域，用来存放指向单链表的指针 链表中各子结点按从左向右的顺序排列 孩子表示法 5.6 树与森林 数据结构 与父亲表示法一样，用顺序表存储树，每个结点包含数据域，父结点位置域，以及 子结点链表域，用来存放指向单链表的指针 第一个孩子：各结点在树中最左边的子结点 下一个兄弟：各结点右侧并且相邻的兄弟结点 结点B的第一个孩子: E，下一个兄弟：C 各结点的第一个孩子就是 其子结点链表的第一个结 点，查找时间O(1) 各结点的下一个兄弟需要 遍历其父结点的子结点链 表，时间复杂度O(d), d 是树的度 孩子兄弟表示法 5.6 树与森林 数据结构 树应用最广泛的存储结构。每个结点存放其第一个孩子和下一个兄弟的信息，可以 直接使用二叉链表实现，因此这种表示法也称作二叉链表表示法 二叉链表中的指针域left 改称 first_child，指向结点的第一个子结点；同时，指针域 right 改称next_sibling，指向右侧的兄弟结点 二叉链表结构 5.6.2 树、森林与二叉树的转换 5.6 树与森林 数据结构 根结点无 右子结点 根结点无 兄弟结点 树与二叉树的转换 对任何一个树，存在唯一的一 个二叉树与它对应，两者具有 相同的二叉链表结构 二叉树树 二叉链表结构 算法5-18：查找树中带有指定数据的结点 Search(tree, x) 5-6 树与森林 node_ptr ← tree if node_ptr ≠ NIL then | if node_ptr.data ≠ 𝑥 then | | node_ptr ← Search(tree.first_child, 𝑥) //在子孙结点中查找 | | if node_ptr = NIL then //不在子孙结点中 | | | node_ptr ← Search(tree.next_sibling, 𝑥) //在兄弟结点及其子孙中找 | | end | end end return node_ptr 输入：基于孩子兄弟表示法的tree，结点元素 𝑥 输出：如果树中有数据域等于𝑥的结点，返回该结点；否则，返回NIL 时间复杂度O(n), n是树中结点数目 采用二叉树的 前序遍历算法 森林与二叉树的转换 5.6 树与森林 数据结构 对于每一棵独立的树，由于根结点没有兄弟，它对应的二叉树的根没有右子结点， 即右子树为空 利用右子树的链将树串联起来，建立森林与二叉树的对应关系 森林转换成二叉树 (1) 把森林中的每个树转换为 二叉树 (2) 把森林中第一个二叉树的 根结点作为转换后的二叉 树的根，从第二个二叉树 开始，把每个二叉树的根 作为前一个二叉树的根的 右子结点 三棵独立 的树 对应每棵树 的二叉树 对应森林的 二叉树 5.6.3 树与森林的遍历 5.6 树与森林 数据结构 树的遍历方案：前序遍历、后序遍历（无中序遍历！） 前序遍历：先访问树根，然后对根的各子树从左向右依次进行前序遍历 后序遍历：遍历根的各子树，最后访问根结点 前序遍历：<A, B, E, F, K, L, G, C, H, D, I, J, M> 后序遍历：<E, K, L, F, G, B, H, C, I, M, J, D, A> 树与对应的二叉树的遍历 5.6 树与森林 数据结构 <A, B, E, F, K, L, G, C, H, D, I, J, M> <E, K, L, F, G, B, H, C, I, M, J, D, A> <A, B, E, F, K, L, G, C, H, D, I, J, M> <E, K, L, F, G, B, H, C, I, M, J, D, A> 对应 前序 前序 后序 中序 树的前序遍历与对应的二叉树的前序遍历结果相同 树的后序遍历与对应的二叉树的中序遍历结果相同 基于二叉树遍历方案的树遍历算法 5-6 树与森林 算法5-19. 前序遍历树 PreOrder(tree) 输入：基于孩子兄弟表示法存储的树tree （二叉链表结构） 输出：按前序遍历的顺序依次访问各结点 if tree ≠ NIL then //空树不做处理，直接返回 | Visit(tree) //先访问根结点 | PreOrder(tree.first_child) //接下来访问tree所有子孙结点 | PreOrder(tree.next_sibling) //最后访问tree后序的兄弟结点及其子孙 end 算法5-20. 后序遍历树 PostOrder(tree) 输入：基于孩子兄弟表示法存储的树tree （二叉链表结构） 输出：按后序遍历的顺序依次访问各结点 if tree ≠ NIL then //空树不做处理，直接返回 | PostOrder(tree.first_child) //先访问tree所有子孙结点 | Visit(tree) //接下来访问根结点 | PostOrder(tree.next_sibling) //最后访问tree后序的兄弟结点及其子孙 end 二叉树的中序 遍历算法 二叉树的前序 遍历算法 森林的遍历 5.6 树与森林 数据结构 前序遍历：从其中的第一个树开始，按序对每个树进行前序遍历 后序遍历：从其中的第一个树开始，按序对每个树进行后序遍历 前序遍历：< B, E, F, K, L, G, C, H, D, I, J, M > 后序遍历：< E, K, L, F, G, B, H, C, I, M, J, D > 从左向右依次遍历每棵树！ 森林与对应的二叉树的遍历 5.6 树与森林 数据结构 <B, E, F, K, L, G, C, H, D, I, J, M> <E, K, L, F, G, B, H, C, I, M, J, D> <E, K, L, F, G, B, H, C, I, M, J, D> 对应 前序 前序 后序 中序 森林的前序遍历与对应的二叉树的前序遍历结果相同 森林的后序遍历与对应的二叉树的中序遍历结果相同 <B, E, F, K, L, G, C, H, D, I, J, M> 算法5.19可用 算法5.20可用 5.6.2 树、森林与二叉树的转换 5.6 树与森林 数据结构 树、森林与二叉树的对应关系表明可以把树或森林先转换为二叉树，使用二叉树 的各种操作进行处理，处理结束后还可以再转换回原来的树或森林 树 或 森 林 二 叉 树 转 换 转 换 执行各种操作：比 如，遍历、序列化 与反序列化、树的 合并与拆分、数据 查找等 5.8 应用场景：决策树 5.8 应用场景 数据结构 决策树：一种解决分类问题的算法 实例： 某高校的优秀学生选拔标准 1）学生在德、智、体三个方面 都取得良以上的成绩 2）按照“为学须先立志”的原 则，品行优异的学生可评为优秀 3）对于品德表现良好的学生， 必须“文武全才”，即学习成绩 和身体素质皆优 转换 决策树 5.8 应用场景：决策树 5.8 应用场景 数据结构 决策树：一种解决分类问题的算法 实例： 决策树 决策树 • 每个中间结点代表一个特征属性，每 个分支代表一个属性值 • 中间结点对属性值进行测试，根据判 断结果决定进入下面哪个子结点 • 叶结点代表最终的决策 • 根结点包含了所有学生，而每个中间 结点包含一个学生集合（子集） • 根据特征属性的测试结果将集合划分 给各个子结点 • 每个叶结点存放一个类别，表示最终 的分类结果 应用 对学生进行分类 5.8 应用场景：决策树 5.8 应用场景 数据结构 决策树：一种解决分类问题的算法 决策树的构建：给定一组训练数据，每个数据包含多个特征属性并且带有表示类 别的标记。从训练数据集中归纳出一组分类规则，并由此构造一个决策树，使它 能够对训练数据执行正确的分类, 也可用于预测新数据的类别。 决策树构建算法：经典的决策树生成算法有ID3、C4.5与CART，其中ID3是最早 提出的机器学习算法 ID3算法是一种贪心法，其核心是“信息熵”。假设样本 数据集C包含k个独立的类别，每个类别构成C的一个子 集𝐶𝑗 (1≤𝑗≤𝑘)，则数据集C的总信息熵为： 𝐻 𝐶 = − ෍ 𝑗=1 𝑘 |𝐶𝑗| |𝐶| log |𝐶𝑗| |𝐶| ID3算法 5.8 应用场景 数据结构 信息增益 设特征属性A的取值为{𝑎1, 𝑎2, … , 𝑎𝑚} (𝑚≥1)。 用𝐷𝑎𝑖表示数据集C中属性A取值𝑎𝑖 (1≤𝑖≤𝑚)的 所有数据集合，对𝐷𝑎𝑖按类别标记进行分类，可 得信息熵： 𝐻 𝐷𝑎𝑖 = − ෍ 𝑗=1 𝑘 |𝐷𝑎𝑖 ∩ 𝐶𝑗| |𝐷𝑎𝑖| log |𝐷𝑎𝑖 ∩ 𝐶𝑗| |𝐷𝑎𝑖| 由此计算属性A对数据集C的条件熵： 𝐻 𝐶, 𝐴 = ෍ 𝑖=1 𝑚 𝐷𝑎𝑖 𝐶 𝐻(𝐷𝑎𝑖) 信息增益定义为𝐻(𝐶)与𝐻(𝐶,𝐴)的差值，即 𝐺𝑎𝑖𝑛(𝐴)=𝐻(𝐶)−𝐻(𝐶, 𝐴) 𝐺𝑎𝑖𝑛(𝐴)表示对数据集先按特征属性A进行划分 后，对判断任意数据属于哪个类别所需信息量 的减少程度。 ID3算法流程： (1) 依次计算各特征属性的信息增益度，如果没有 特征可选或信息增益量小于阀值，结束计算； 否则执行(2)的操作 (2) 选择信息增益度最大的特征属性作为决策树结 点，对特征值区间进行划分并建立子结点，每 个子结点对应不同的特征值 (3) 把数据集按特征值划分给每个子结点 (4) 对各子结点重复执行(1)的操作。 ID3算法 5.8 应用场景 数据结构 ID3算法实例 学生的成绩单及分类 全体学生S中有4名优异生、6名非优异生，总信息熵 按品德表现划分学生，把学生分成三组，即品行优异组、 品行良好组以及品行一般组，各组的信息熵为： 一 根据上面三个信息熵，可以算出按照品德表现进行划分后， S的条件熵 一 同理，按学习成绩和身体素质划分后，S的条件熵分别是 0.761和 0.675。由此可见，品德表现的信息增益度最大 因此，ID3算法选择品德表现这一特征属性作为决策树的根 结点，其三个子结点分别对应T优、T良以及T一般这三个子集； 然后对各子结点继续进行拆分。 5.8 应用场景：决策树 5.8 应用场景 数据结构 决策树：一种解决分类问题的算法 决策树构建算法：经典的决策树生成算法有ID3、C4.5与CART，其中ID3是最早提出的 机器学习算法 总结：决策树算法是机器学习中常用的模型，易于理解，可解释性强，可以同时处理数 值型和非数值型数据，能够处理关联度低的特征属性，符合人类的直观思维。但容易发 生过拟合的现象，容易忽略特征属性之间的关联，并且预测精度易受异常数据的影响。 • ID3算法只能处理离散型特征，同时信息增益倾向于选择取值较多的属性。 • 针对ID3算法的缺陷，C4.5算法引入信息增益率来作为分类标准，能够处 理连续数值型特征属性，同时在决策树构造过程中进行剪枝 • 与C4.5算法相比，CART算法采用了简化的二叉树模型，同时特征选择采 用了近似的基尼系数来简化计算，该算法还可用于回归 小结 数据结构 • 树与二叉树的基本概念 • 二叉树的存储方式和运算实现 • 二叉树的两种应用：表达式树和哈夫曼树 • 普通的树形结构以及森林的表示法、存储结构 • 普通的树形结构、森林与二叉树的转换，以及基于二叉树的遍历方法 • 拓展延伸部分包含前缀树和后缀树 • 以决策树作为应用场景，包括基于信息熵构建决策树的ID3算法","libVersion":"0.5.0","langs":""}