{"path":"01 数据结构和算法/PPT/第08章课件-图应用.pdf","text":"数据结构 计算机领域本科教育教学改革试点 工作计划（“101计划”）研究成果 授课教师： 湖南大学 信息科学与工程学院 图应用 第 8 章 8.1 问题引入 8.2 最短路径问题 8.3 最小生成树 8.4 拓扑排序和关键路径 8.5 拓展延伸 8.6 应用场景：图计算 4 8.1 问题引入：魔方问题 8.1 问题引入 数据结构 • 问题：在一个3阶魔方中，魔方的每一个面都由 9 个方块（3×3）构成。魔方处 在初始形态时，每个面的方块都是同一种颜色，魔方的六个面一共包含蓝、红、 橙、绿、黄、白六种颜色。将魔方的各面随机旋转几次，如何它通过最少的旋 转还原到魔方的初始形态，即各个面的方块颜色一样呢？ • 关键：如何将该问题转化为一个图问题？ • 核心思想：将魔方的任意一个形态建模为图中的一个顶点。如果魔方的两个形 态可以通过魔方一个面的一次旋转相互转化，那么就将相应的两个顶点连成一 条边。这样可以得到一个魔方形态的转移图。从一个打乱的魔方还原至初始形 态可以转化为在该转移图上寻找一条从打乱状态所对应顶点到初始形态所对应 顶点的路径问题。而这两个顶点之间的最短路径即为最优的旋转方案。 5 8.2 最短路径问题 8.2 最短路径问题 数据结构 • 问题：在左图所示的交通网络中找一条从北京 到上海的最短路径，如何计算这条最短路径？ • 定义：在最短路径问题中，给定一个带有权值 的有向图 𝐺 = (𝑉, 𝐸)，令𝑤(𝑢, 𝑣)表示边(𝑢, 𝑣)的 权值。图中一条路径𝑝 =< 𝑣0, 𝑣1, . . . , 𝑣𝑘 >的权 值𝑤(𝑝)是构成该路径的所有边的权值之和，在 所有的从顶点𝑢到顶点𝑣的路径当中，权值最小 的那条路径称之为从𝑢到𝑣的最短路径。 • 总结：给定加权图 𝐺 = (𝑉, 𝐸) ，以及源点 𝑠 ∈ 𝑉 ， 对于所有的其他顶点𝑣，𝑠到𝑣的最短路径有多 长？该路径由哪些边组成？ 交通网络示意图 6 8.2 最短路径问题 8.2 最短路径问题 数据结构 ◼ 最短路径问题：如果从图中某一顶点(称为源点)到达另一顶点(称为终点)的路径可能 不止一条，如何找到一条路径使得沿此路径上各边上的权值总和达到最小。 ◼ 问题解法 • 边上权值非负情形的单源最短路径问题: Dijkstra算法 • 边上权值为任意值的单源最短路径问题: Bellman和Ford算法 • 所有顶点之间的最短路径: Floyd算法 7 8.2 最短路径问题 数据结构 • 重要性质：给定两个顶点之间的一条最短路径，则在该路径上任意两个点的路径都是最短 的，这种最短子路径称为最优子结构。 • 证明：给定加权有向图𝐺 = (𝑉, 𝐸)。设𝑝 =< 𝑣0, 𝑣1, . . . , 𝑣𝑘 >为从顶点𝑣0到顶点𝑣𝑘的一条最短 路径，对于任意的𝑖, 𝑗，0 ≤ 𝑖 ≤ 𝑗 ≤ 𝑘。如果𝑝𝑖𝑗 =< 𝑣𝑖, 𝑣𝑖+1, . . . , 𝑣𝑗 > 为路径𝑝中从顶点𝑣𝑖到 顶点𝑣𝑗的子路径，那么𝑝𝑖𝑗是从顶点𝑣𝑖到𝑣𝑗的一条最短路径。如图8-2所示，如果将路径𝑝分 解为𝑣0, 𝑣𝑖, 𝑣𝑗, 𝑣𝑘 ，则有𝑤(𝑝) = 𝑤(𝑝0𝑖) + 𝑤(𝑝𝑖𝑗) + 𝑤(𝑝𝑗𝑘)。假设存在一条从𝑣𝑖到𝑣𝑗的路径 𝑝𝑖𝑗 、，且𝑤(𝑝𝑖𝑗 、) < 𝑤(𝑝𝑖𝑗)。则𝑣0, 𝑣𝑖, 𝑣𝑗, 𝑣𝑘 是一条从顶点𝑣0到顶点𝑣𝑘的权值为 𝑤(𝑝) = 𝑤(𝑝0𝑖) + 𝑤(𝑝𝑖𝑗 、) + 𝑤(𝑝𝑗𝑘)的路径，而该权值小于𝑤(𝑝)。这与𝑝是从𝑣0到𝑣𝑘的一条最短路径 这一假设相矛盾。 最短路径最优子结构示意图 8 8.2 最短路径问题 数据结构 • 问题：一条最短路径可以包含环路吗？ • (1) 分析最短路是否包含权值为负值的环路 • 给定加权有向如果图𝐺 = (𝑉, 𝐸)包含从源顶点𝑠可以到达的权值为负值的环路，那么 从源顶点𝑠到该环路上的任意顶点的路径都不可能是最短路径。因为只要沿着任意 “最短”路径再遍历一次权值为负值的环路，则总可以找到一条权值更小的路径。 权值为负的环路 9 8.2 最短路径问题 数据结构 • (2) 分析最短路是否包含权值为正值的环路 • 在包含权值为正值的环路上，只要将环路从路径上删除就可以得到一条源顶点和终 顶点与原来路径相同的一条权值更小的路径。 • (3) 分析最短路是否包含权值为0的环路 • 从任何路径上删除权值为0的环路而得到另一条权值相同的路径。如果从源顶点𝑠到 终顶点𝑣存在一条包含权值为0的环路的最短路径，则也同时存在一条不包含该路径 的从源顶点𝑠到终顶点𝑣的最短路径。只要一条路径含有权值为0的环路，就重复删 除这些环路，直到得到一条不包含环路的最短路径。 10 Dijkstra算法 8.2 最短路径问题 数据结构 • 单源点的最短路径：给定加权有向图𝐺和源点𝑠，求从𝑠到𝐺中其余各顶点的最短路径。荷兰计算机 科学家 Edsger Wybe Dijkstra 在1956年提出了Dijkstra算法，使用类似广度优先搜索的方法解 决加权图的单源最短路径问题，它要求所有边的权值都为非负值。Dijkstra算法原始版本仅适用 于找到两个顶点的最短路径，后来更常见的变体是从一个固定的源顶点出发寻找到图中所有其它 顶点的最短路径，产生一个最短路径树。该算法每次取出未访问顶点中距离最小的，再用该顶点 更新其他顶点的距离。 有向加权图G 源点 终点 最短路径 路径长度 v1 v2 <v1,v2> 1 v1 v3 <v1,v2,v4,v3> 8 v1 v4 <v1,v2,v4> 4 v1 v5 <v1,v2,v4,v3,v5> 13 v1 v6 <v1,v2,v4,v3,v5,v6> 17 11 Dijkstra算法 8.2 最短路径问题 数据结构 问题的提法： 给定一个带权有向图D与源点v，求从v到D中其它顶点的最 短路径。限定各边上的权值大于或等于0。 为求得这些最短路径，Dijkstra提出按路径长度的递增次序，逐步产生最短 路径的算法。首先求出长度最短的一条最短路径，再参照它求出长度次短 的一条最短路径，依次类推，直到从顶点v到其它各顶点的最短路径全部求 出为止。 12 Dijkstra算法 8.2 最短路径问题 数据结构 艾兹格·W·迪科斯彻 （Edsger Wybe Dijkstra，1930年5月11日~2002年8月6日）荷 兰人。 计算机科学家，曾在1972年获得过素有计算机科学界的诺贝尔奖之称的图灵奖， 之后，还获得过1974年 AFIPS Harry Goode Memorial Award、1989年ACM SIGCSE 计算机科学教育教学杰出贡献奖、以及2002年ACM PODC最具影响力论文奖。 主要贡献： 1 提出“goto有害论”; 2 提出信号量和PV原语; 3 解决了“哲学家聚餐”问题; 4 最短路径算法(SPF)和银行家算法的创造者; 5 第一个Algol 60编译器的设计者和实现者; 6 THE操作系统的设计者和开发者 与D. E. Knuth并称为我们这个时代最伟大的计算机科学家的人。 13 Dijkstra算法 8.2 最短路径问题 数据结构 依最短路径的长度递增的次序求得各条路径 源点 第一条：最短的“最短路径”。在这条路径 上，必定只含一条弧到达v1，并且这条弧的 权值最小。 下一条路径长度次短的最短路径的特点： 它只可能有两种情况：或者是直接从源点到 该点(只含一条弧)； 或者是从源点经过顶点 v1，再到达该顶点(由两条弧组成)。 v2 v1 v3 14 Dijkstra算法 8.2 最短路径问题 数据结构 依最短路径的长度递增的次序求得各条路径 再下一条路径长度次短的最短路径的特点: 它可能有三种情况：或者是直接从源点到 该点( 只含一条弧)； 或者是从源点经过顶点 v1，再到 达该顶点(由两条弧组成)；或者是 从源点经过顶 点v2，再到达该顶点。 其余最短路径的特点： 它或者是直接从源点到该点(只含一条 弧)； 或 者是从源点经过已求得最短路径 的顶点，再 到达该顶点。 源点 v2 v1 v3 15 Dijkstra算法 8.2 最短路径问题 数据结构 算法思想： 引入辅助向量dist，每个分量dist[v]表示当前所找到的从原点s到每个终点v的最短路径长度。 要求仅仅经过已经确定最短路径长度的节点集合。 设已找到的最短路径的结点集合为S，未找到最短路径的结点集合为 T。 重复以下步骤： 1. 从集合T中基于dist找到当前已知的最短路径结点v加入集合S中 2. 针对v的所有邻居k，更新dist数组 dist[k] = min(dis[k], dist[v]+W(v,k)) 3.重复上述1,2步骤，直到所有节点加入S 16 Dijkstra算法 8.2 最短路径问题 数据结构 举例：寻找出图中节点0到所有其他节点的最短路径。初始的距离列表如下。还有 一个列表用来记录哪些节点未被访问（即尚未被包含在路径中） 17 Dijkstra算法 8.2 最短路径问题 数据结构 从节点0出发，可以直接将它标记为“已访问”，同样的，在未访问节点列表中把 它划掉，并在图中给它加上红色的边框： 18 Dijkstra算法 8.2 最短路径问题 数据结构 现在需要检查节点 0 到相邻节点的距离，两个相邻节点分别是节点 1 和节点 2（注意看 红色的边）。更新节点 0 到节点 1、节点 0 到节点 2 的距离为它们之间的边的权重， 分别为 2 和 6： 提示： 这并不是说立即把这两个相邻节点加入到最短路径中。在把一个节点加入到最短路径之 前，需要确认是否已经寻找到了访问它的最短路径。现在只是在对可选方案做初步检查。 19 Dijkstra算法 8.2 最短路径问题 数据结构 更新了到相邻节点的距离之后： • 根据已知的距离列表选择距离源节点最近的节 点。 • 将它标记为“已访问”。 • 将它添加到路径中。 查看距离列表，发现节点 1 到源节点的距离是最 短的（距离为 2），所以把它加入到路径中。 在图中，以红色边来表示。 在距离列表中用红色方块标记这个节点，表明它 是“已访问”的、已经寻找到了访问这个节点的 最短路径。 在未访问节点列表中将它划掉： 20 Dijkstra算法 8.2 最短路径问题 数据结构 现在分析新的相邻节点，寻找访问它们的最短路径。只需要分析已经在最短路径（标记为红 色边）中的节点的相邻节点。 节点 2 和节点 3 都是最短路径包含的节点的相邻节点，因为它们分别与节点 0 和节点 1 直 接相连，如下图所示。下一步将要分析这两个节点。 之前已经计算过源节点到节点 2 的距离，并记录在了列表中，所以不用更新。这次只需要 更新源节点到新的相邻节点（节点 3）的距离： •对于节点 3： 将构成路 径 0 -> 1 -> 3 的所有边权重 相加，得到总距离为 7（0 -> 1 距离为 2，1 -> 3 距离 为 5）。 21 Dijkstra算法 8.2 最短路径问题 数据结构 现在得到了到相邻节点的距离，需要选择一个节点添加到路径中。我们必 须选择一个已知到源节点距离最短的未访问节点。 从距离列表中可以看出，距离为 6 的节点 2 是我们的目标： 在距离列表中用红色方块把它标记为“已访问”，在“未访问”节点列 表中把它划掉： 在图中为节点2加上红色边框，并将路径上的边标记为红色： 22 Dijkstra算法 8.2 最短路径问题 数据结构 重复前面的步骤，寻找源节点到新的相邻节点节 点 3 的最短路径。 可以看到，有两种可选的路径：0 -> 1 -> 3 或 0 -> 2 -> 3。一起看看我们是如何确定最短路径的。 节点 3 在之前已经有了一个距离记录 （距离为 7，参阅下表），这个距离是 之前步骤中由路径 0 -> 1 -> 3 的两个边权 重（分别为 5 和 2）相加得到的。 不过现在有了一个新的可选路径：0 -> 2 -> 3，它途经权重分别为 6 和 8 的两条 边 0 -> 2 和 2 -> 3，总距离为 14。 23 Dijkstra算法 8.2 最短路径问题 数据结构 因此，使用第一种方案 0 -> 1 -> 3，将节点添 加到路径中。 把这个节点标记为“已访问”，在“未 访问”节点列表中把它划掉： ...... 重复前面的过程。 24 Dijkstra算法 8.2 最短路径问题 数据结构 25 Dijkstra算法 8.2 最短路径问题 数据结构 31 8.2 最短路径问题 数据结构 复杂度：当采用邻接矩阵存储图时，Dijkstra算法的时间复杂度分析如下：设图中顶点数为|𝑉|， 则第一个for循环的时间复杂度为𝑂(|𝑉|)，第二个for循环一共进行|𝑉| − 1次，每次执行时间为 𝑂(|𝑉|)，所以总的时间复杂度为𝑂(|𝑉|2)。 32 Bellman-Ford算法 8.2 最短路径问题 数据结构 • Bellman-Ford算法解决的是一般情况下的单源最短路径问题。这个算法比Dijkstra的 优势在于边权值可以为负值。给定加权有向图𝐺 = (𝑉, 𝐸)，Bellman-Ford算法返回一个 bool值，以表明是否存在一个从源顶点可以到达的权值为负值的环路。如果存在这样 的一个环路，则不存在解决方案；如果没有这种环路存在，算法将给出最短路径和对应 的权值。 • 核心思想：Bellman-Ford算法通过对边进行松弛的方式渐近地求出源顶点s到其余顶点 v的最短路径距离。 • 松弛操作： • 对一条边< 𝑢, 𝑣 >的松弛过程为：从源顶点𝑠到顶点𝑢之间的最短路径距离加上顶点𝑢与𝑣 之间的边权值，并与当前预计算出来的源顶点𝑠到𝑣的最短路径距离比较，如果前者更小， 对𝑑𝑖𝑠𝑡[𝑣]进行更新。 33 Bellman-Ford算法 8.2 最短路径问题 数据结构 • Bellman和Ford提出了从源点逐次绕过其它顶点，以缩短到达终点的最短路径长度 的方法。该方法有一个限制条件，即要求图中不能包含有由带负权值的边组成的回 路。 • 当图中没有由带负权值的边组成的回路时，有n个顶点的图中任意两个顶点之间如 果存在最短路径，此路径最多有n-1条边。 • 我们将以此为依据考虑计算从源点v到其它顶点u的最短路径的长度dist[u]。 34 Bellman-Ford算法 8.2 最短路径问题 数据结构 • 构造一个最短路径长度数组序列dist1 [u]，dist2 [u]，…，distn-1 [u]。其中，dist1 [u]是从源点v到终点u的只经过一条边的最短路径的长度，dist1 [u] = Edge[v][u]； dist2 [u]是从源点v最多经过两条边到达终点u的最短路径的长度，dist3 [u]是从源 点v出发最多经过不构成带负长度边回路的三条边到达终点u的最短路径的长度，…， dist n-1[u]是从源点v出发最多经过不构成带负长度边回路的n-1条边到达终点u的最 短路径的长度。 • 算法的最终目的是计算出dist n-1[u]。 • 可以用递推方式计算distk [u]。 35 Bellman-Ford算法 8.2 最短路径问题 数据结构 递推关系： dist1 [u] = Edge[v][u]； distk [u] = min { distk-1 [u], min { distk-1 [ j]+Edge[ j][u] } } • 设已经求出 distk-1 [ j], j = 0, 1, …, n-1, 此即从源点 v 最多经过不构成带负长度 边回路的 k-1 条边到达终点 j 的最短路径的长度。 • 从图的邻接矩阵中可以找到各个顶点 j 到达顶点 u 的距离 Edge[ j][u]，计算 min { distk-1 [ j]+ Edge[ j][u] }，可得从源点 v 绕过各个顶点，最多经过不构成 带负长度边回路的 k 条边到达终点u的最短路径的长度。 • 用它与distk-1 [u]比较，取小者作为distk [u]的值。 36 Bellman-Ford算法 8.2 最短路径问题 数据结构 复杂度：算法初始化阶段时间复杂度为𝑂(|𝑉|)，算法执行三重循环循环，每重循环的时间复杂度 为𝑂(|𝑉|)，因此执行三重循环的总复杂度为𝑂(|𝑉|3)。算法检测是否存在权值为负值的环路需要 遍历整个图，时间复杂度为𝑂(|𝑉|2)。综上，算法的总运行时间复杂度为𝑂(|𝑉|3)。 37 8.2 最短路径问题 数据结构 Bellman-Ford算法的执行过程示意图 38 Floyd-Warshall算法 8.2 最短路径问题 数据结构 • 算法介绍：Floyd-Warshall算法是一种动态规划算法，能解决所有顶点对最短 路径问题，运行时间为𝑂(|𝑉|3)，能够处理权值为负的边 • 核心思想：要让任意两点之间的路程变短，只能引入第三个点，并通过这个顶 点𝑤中转即𝑢 → 𝑤 → 𝑣，才可能缩短原来从顶点𝑢到顶点𝑣的路程。记图𝐺的所有 顶点为 𝑉 = {1,2, . . . , 𝑛} 。考虑其中一个子集 {1,2, . . . , 𝑘} ，对于任意顶点对 𝑖, 𝑗 ∈ 𝑉 ， 考虑从𝑖到𝑗的所有中间顶点均取自集合 {1,2, . . . , 𝑘}的那些路径，并设𝑝为其中权 值最小的路径。分别考虑顶点𝑘是否是路径𝑝上的一个中间顶点的情况。 1. 如果𝑘不是𝑝上的中间顶点，则 𝑝上所有中间顶点都属于集合 {1,2, . . . , 𝑘 − 1}。 因此，从𝑖到𝑗且中间顶点均取自{1,2, . . . , 𝑘 − 1}的一条最短路径也同时是从i到j且 中间顶点均取自{1,2, . . . , 𝑘}的一条最短路径。 2. 如果顶点 𝑘是路径𝑝上的中间顶点，则将路径𝑝分解成 𝑝1: 𝑖 → 𝑘和𝑝2: 𝑘 → 𝑗。可 得𝑝1是从顶点𝑖到顶点𝑘的，中间顶点全部取自集合{1,2, . . . , 𝑘 − 1}的一条最短路 径（因为𝑘是末尾顶点）。类似的， 𝑝2是从顶点 𝑘到顶点𝑗的，中间顶点全部取 自集合{1,2, . . . , 𝑘 − 1}的一条最短路径。 39 Floyd-Warshall算法 8.2 最短路径问题 数据结构 • 算法介绍：Floyd-Warshall算法是一种动态规划算法，能解决所有顶点对最短 路径问题，运行时间为𝑂(|𝑉|3)，能够处理权值为负的边 • 核心思想： • 定义k-path 为任意一条从顶点v到u的，中间顶点序号小于等于k的路径。 • 0-path 即为直接地从v到u的边。 • 定义D(k)(v, u)为从v到u的长度最小的k-path • 递推关系如何分析？ 40 Floyd-Warshall算法 8.2 最短路径问题 数据结构 • 动态规划的思想： • 设D(k)(v, u)为从v到u的只以（1,…,k）集合中的节点为中间节点的最短路径的长度。 • 若最短路径经过点k，则D(k)(v, u)= D(k-1)(v, k)+ D(k-1)(k, u) • 若最短路径不经过点k，则D(k)(v, u)= D(k-1)(v, u) • 因此D(k)(v,u)应取D(k-1)(v, k)+ D(k-1)(k, u)与D(k-1)(v, u)中的最小值。 v k u {1,2,…,k-1}中的所有中间节点 41 Floyd-Warshall算法 8.2 最短路径问题 数据结构 • 定义一个𝑛阶方阵序列𝐷(−1), 𝐷(0), 𝐷(1), . . . , 𝐷(𝑘), . . . , 𝐷(𝑛 − 1) ，其 中𝐷(−1)[𝑖][𝑗] = 𝑀[𝑖][𝑗]，因此： • 𝐷(𝑘)[𝑖][𝑗] = 𝑚𝑖𝑛{𝐷(𝑘 − 1)[𝑖][𝑗], 𝐷(𝑘 − 1)[𝑖][𝑘]} + 𝐷(𝑘 − 1)[𝑘][𝑗]}, 0 ≤ 𝑘 ≤ 𝑛 − 1 • 𝐷(1)[𝑖][𝑗]是从𝑣𝑖到𝑣𝑗的中间顶点的序号不大于1的最短路径的长度； 𝐷(𝑘)[𝑖][𝑗]是从𝑣𝑖到𝑣𝑗的中间顶点的序号不大于𝑘的最短路径的长度； 𝐷(𝑛 − 1)[𝑖][𝑗]就是从𝑣𝑖到𝑣𝑗的最短路径的长度。根据上述公式，可以 计算顶点𝑣𝑖到𝑣𝑗的最短路径长度。 42 8.2 最短路径问题 数据结构 D D(-1) D(0) D(1) D(2) 0 1 2 0 1 2 0 1 2 0 1 2 0 0 6 22 0 6 22 0 6 18 0 6 18 1 ∞ 0 12 ∞ 0 12 ∞ 0 12 17 0 12 2 5 17 0 5 11 0 5 11 0 5 11 0 P P(-1) P(0) P(1) P(2) 0 1 2 0 1 2 0 1 2 0 1 2 0 v0v1 v0v2 v0v1 v0v2 v0v1 v0v1v2 v0v1 v0v1v2 1 v1v2 v1v2 v1v2 v1v2v0 v1v2 2 v2v0 v2v1 v2v0 v2v0v1 v2v0 v2v0v 1 v2v0 v2v0v1 43 8.2 最短路径问题 数据结构 44 8.3 最小生成树 8.3 最小生成树 数据结构 • 问题：考虑在n个村庄之间建立公路，使得每一个村庄都存在一条到其它村庄的道路。 如何在最节省经费的情况下建立上述的道路网络？ • 总结：由于道路建设的费用和道路的里程成正比。这个问题实际上是在𝑛个城市之间存 在的𝑛(𝑛 − 1)/2个道路中选择𝑛 − 1条道路，使得这𝑛 − 1条道路能够保证𝑛个村庄之间 可以互相连通而且建造的总费用最小。如果用顶点表示村庄，边表示村庄之间的可能 产生的道路，边的权值表示建造道路的费用。那么不难发现，由𝑛 − 1条路连通的𝑛个 村庄构成了一棵树。由于该树包含了图中所有的顶点，我们称这样的树为图的生成树。 对于任意一棵生成树，其代价为生成树的所有边的费用之和。给定一个加权图，在其 所有的生成树中，代价最小的生成树称之为最小代价生成树，简称最小生成树。 • 定义：给定一个连通的加权图𝐺 = (𝑉, 𝐸)，其中𝑉为顶点的集合，𝐸为边的集合，其中𝐸 中的每条边都有一个非负的权值。最小生成树问题是在𝐺中求解权值最小的生成树。 45 Prim算法 8.3 最小生成树 数据结构 • 给定连通图𝐺 = (𝑉, 𝐸)，对于任何一个顶点集的子集𝑈，其补集定义为𝑉 − 𝑈，若边(𝑢, 𝑣)满足 𝑢 ∈ 𝑈，且𝑈 ∌v，则称(𝑢, 𝑣)为一条跨越边（crossing edge）。Prim算法基于以下引理： • 引理：最小生成树必定包含连接任意集合对(𝑈, 𝑉 − 𝑈)的最短跨越边。 • 证明：如图8-8所示，(𝑢, 𝑣)是连接顶点子集𝑈和𝑉 − 𝑈的最小跨越边。假设最小生成树未包括该 边，则其必包含另一条跨越边(𝑥, 𝑦)，由于树的连通性，则𝑢, 𝑣之间必存在一条通路。如果将 (𝑢, 𝑣)加入到最小生成树中，必然会形成一个环(𝑢, 𝑣, 𝑦, 𝑥)，从最小生成树中删除边(𝑥, 𝑦)后，该 环就会消失，形成一个新的最小生成树。由于边(𝑢, 𝑣)的权值小于边(𝑥, 𝑦)的权值，而和的差别 仅仅在于边(𝑢, 𝑣)和边(𝑥, 𝑦)，因此最小生成树的代价一定小于，这与前提相矛盾，因此最小生 成树一定包含连接每一个集合对(𝑈, 𝑉 − 𝑈)的最短跨越边。 最小生成树包含最短跨域边示意图 V-U V-U 46 8.3 最小生成树 数据结构 Prim算法执行过程 47 8.3 最小生成树 数据结构 复杂度：采用邻接矩阵存储，不难看出Prim算法时间复杂度为𝑂(|𝑉|2) 48 Kruskal算法 8.3 最小生成树 数据结构 • Kruskal算法和Prim算法的基本思想不同。Prim算法每一步选择一个顶点，而 Kruskal算法每一步选择一条边。假设𝐺 = (𝑉, 𝐸)为一个连通图，𝐸𝑚𝑠𝑡是𝐸上最 小生成树中边的集合。最小生成树𝑇的初始状态为只有|𝑉|个顶点的无边图。算 法在𝐸中选择最小代价的边，若该边可以连接𝑇中两个不同的连通分量，则将此 边加入到𝐸𝑚𝑠𝑡中；否则，判断下一条代价最小的边。反复如此，直到𝑇中所有 顶点都在同一连通分量中。 • 由于每次遍历时算法仅对边进行遍历，因此Kruskal算法的时间复杂度仅与图中 的边数有关。如果用堆来存储边，建立堆的时间复杂度为𝑂(|𝐸|)，每次选择边 的时间复杂度为𝑂(𝑙𝑜𝑔|𝐸|),因此Kruskal时间复杂度为𝑂(|𝐸|𝑙𝑜𝑔|𝐸|)。因此 Kruskal算法比较适合边稀疏的图。 49 8.3 最小生成树 数据结构 Kruskal算法执行过程 50 8.4.1 拓扑排序：问题引入 8.4 拓扑排序和关键路径 数据结构 • 问题：普通高等学校计算机专业本科生的课程安排，某些课程存在先修课，如 何确定一个合理的课程学习顺序？ • 关键：课程学习顺序需要遵循课程之间的先修关系 • 课程先修关系： 课程名称 课程代码 先修课程 微积分 C0 无 线性代数 C1 无 概率论与数理统计 C2 C0，C1 程序设计基础 C3 无 数据结构 C4 C0，C1，C3 计算机组成原理 C5 C4 操作系统 C6 C4 计算机体系结构 C7 C5 51 问题建模 8.4 拓扑排序和关键路径 数据结构 • 使用有向图表示课程关系：将课程视为顶点，将课程间的先修关系视为有向边 课程名称 微积分 线性代数 概率论与 数理统计 程序设计 基础 数据结构 计算机组 成原理 操作系统 计算机体 系结构 课程代码 C0 C1 C2 C3 C4 C5 C6 C7 先修课程 无 无 C0，C1 无 C0，C1，C3 C4 C4 C5 课程先修关系图 C1 C0 C2 C3 C5 C4 C6 C7 52 问题建模 8.4 拓扑排序和关键路径 数据结构 • 有向无环图 不存在环路的有向图称为有向无环图（Directed Acyclic Graph， DAG）。由于课程先修关系不会出现闭环，因此该图一定是有向无环图。 • AOV网络 在一个有向图中，如果图中的顶点表示活动，图的有向边表示活动之间 的优先关系，则称这样的有向图为AOV网络（Activity On Vertex Network）。 课程先修关系图 C1 C0 C2 C3 C5 C4 C6 C7 53 问题求解：拓扑排序 8.4 拓扑排序和关键路径 数据结构 • 问题分析 • 在一个合法的课程学习顺序中，每个课程的先修课程必须排在该课程之前。 • 拓扑序列&拓扑排序 • 在DAG中，将满足下列条件的顶点序列称为拓扑序列： • （1）每个顶点在序列中出现且仅出现一次； • （2）序列中的每个顶点都不存在边指向其前面的节点。 • 定理：DAG中一定存在拓扑序列，存在拓扑序列的AOV网络一定是DAG。 • 将求解拓扑序列的算法称为拓扑排序。 一个合法的课程学习顺序 54 问题求解：拓扑排序 8.4 拓扑排序和关键路径 数据结构 • 拓扑排序过程 ① 初始化空序列S； ② 任选一个入度为0的顶点v，加入S； ③ 删除顶点v及其所有出边； ④ 重复步骤②和③，直到无顶点可选。 • 时间复杂度：O( V + |E|) • 若执行步骤④后所有顶点均被删除，则S为合法的拓扑序列；否则说明原图存 在环路，无合法拓扑序列。 C2 C5 C4 C6 C7 C5 C4 C6 C7 C5 C6 C7 C6 C7 C7 55 问题求解：拓扑排序算法 8.4 拓扑排序和关键路径 数据结构 拓扑排序算法 TopSort(graph, top_s) 输入：图graph 输出：若存在拓扑排序，则top_s[i]存储拓扑序中第i 个顶点，并返回true；否则返回false 1. n ← graph.n_verts 2. count_v ← 0 //记录已经输出的顶点数 3. InitQueue(queue) //使用队列记录加入拓扑排序的顶点 4. GetInDegree(graph, in_degree) //获得graph中每个顶点的入度，存入数组in_degree 5. for v ← 0 to n-1 do 6. | if in_degree[v]=0 then 7. | | EnQueue(queue, v) 8. | end 9. end 10.while IsEmpty(queue) = false do 11.| u ← GetFront(queue) 12.| DeQueue(queue) 13.| top_s[count_v] ← u 14.| count_v ← count_v + 1 15.| for u的每条出边<u,v> do 16.| | in_degree[v] ← in_degree[v] - 1 //删除 <u,v>，故v的入度减1 17.| | if in_degree[v]=0 then 18.| | | EnQueue(queue, v) 19.| | end 20.| end 21.end 22.if count_v=n then //加入拓扑序列的顶点数为n，说明拓扑排序成功 23.| return true 24.else //否则，说明图中存在环路，不存在拓扑排序 25.| return false 26.end 56 8.4.2 关键路径 8.4 拓扑排序和关键路径 数据结构 • AOE网络 将边表示为活动的图称为AOE网络（Activity On Edge Network）。在AOE网中， 边表示活动，边上权表示活动进行的时间，而顶点表示事件。 • 在实际应用中，AOE网络没有环路，且通常只有一个入度为0的起点和一个出度为0的终 点。 AOE网络 AOE网络主要能够解决的问题： ① 计算完成所有活动需要多长时间； ② 哪些活动是影响进度的关键。 解决上述问题有助于合理规划工程中的活动， 提高工程效率。 57 8.4.2 关键路径 8.4 拓扑排序和关键路径 数据结构 • 关键路径&关键活动 在AOE网络中，将从起点到某点的最长路径称为从起点到 该点的关键路径。关键路径上的活动称为关键活动。 AOE网络中v4的关键路径 当活动可以同步进行时，关键路径反 映了AOE网络中事件的最早发生时间。 右图中，事件v4需要等待活动(v2, v4) 和活动(v1, v4)完成，因此最早发生时间为 𝑎0 + 𝑎4 = 9。 58 8.4.2 关键路径 8.4 拓扑排序和关键路径 数据结构 • 求解关键路径 • 定义： • e[𝑖]：活动𝑎𝑖的最早开始时间 • l[𝑖]：活动𝑎𝑖的最晚开始时间 • earliest[𝑣]：事件𝑣的最早发生时间 • latest[𝑣]：事件𝑣的最晚发生时间 • 若活动𝑎𝑖对应边(𝑢, 𝑣)，则不难推出以下性质： a) e 𝑖 = earliest 𝑢 b) l 𝑖 = latest 𝑣 − weight(𝑢, 𝑣) c) earliest 𝑣 = max 𝑢,𝑣 ∈𝐸{earliest 𝑢 + weight(𝑢, 𝑣)} d) latest 𝑢 = min 𝑢,𝑣 ∈𝐸{latest 𝑣 − weight(𝑢, 𝑣)} e) 关键活动𝑎𝑖满足e 𝑖 = l[𝑖] 蓝：e[𝑖] 橙：l[𝑖] 绿：earliest[𝑣] 红：latest[𝑣] 59 8.4.2 关键路径 8.4 拓扑排序和关键路径 数据结构 • 求解关键路径步骤 ① 求解AOE网络的一个拓扑序列T = {𝑣1, 𝑣2, … , 𝑣𝑛}; ② earliest 𝑣1 = 0; ③ For 𝑖 = 2 to n do ④ earliest 𝑣𝑖 = max 𝑣𝑗,𝑣𝑖 ∈𝐸 earliest 𝑣𝑗 + weight 𝑣𝑗, 𝑣𝑖 ; ⑤ latest 𝑣𝑛 = earliest[𝑣𝑛]; ⑥ For 𝑖 = n to 1 do ⑦ latest 𝑣𝑖 = min 𝑣𝑖,𝑣𝑗 ∈𝐸{latest 𝑣𝑗 − weight(𝑣𝑖, 𝑣𝑗)}; ⑧ For 𝑎𝑖 = 𝑢, 𝑣 ∈ 𝐸 do ⑨ e 𝑖 = earliest[𝑢]; ⑩ l 𝑖 = latest 𝑣 − weight(𝑢, 𝑣); ⑪ if e 𝑖 = l 𝑖 then ⑫ 𝑎𝑖为关键活动; ⑬ 选取所有的关键活动组成关键路径; 60 8.6 应用场景：图计算 8.6 应用场景：图计算 数据结构 金融领域、人际关系、分子拓扑结构、大脑神经元链接等图数据中蕴含着丰富的信息，利 用图计算能够挖掘这些图数据中隐含的价值。 金融风险管理中，图计算可以分析金融市场中的复杂关系 和相互影响，识别潜在的风险因素。通过构建金融关联网 络，包括企业、个人和资产之间的关系，可以发现系统性 风险和连锁反应。通过图计算的路径分析和传播模型，可 以提前预测和评估风险的传播路径和影响范围，帮助金融 机构制定有效的风险管理策略。 金融数据挖掘中，金融图数据包含数十亿级节点和边，顶 点和边反映不同类型的实体和关系。 传统数据分析和挖掘技术通常从个体（企业、个人、金融 机构等）出发，分析个体间的差异； 图计算技术从个体间的关联出发，分析个体之间存在的经 济行为关系。 8.7 小结 8.7 小结 数据结构 本章主要介绍了图在实际应用中的几种经典算法： • 最短路径：重点介绍了两个常用的算法：求单源最短路径的Dijkstra算法和求 所有顶点之间的最短路径的Floyd算法。讨论了单源最短路径中的一些特例， 包括非加权图、含有负权值的图和无环图； • 最小生成树：介绍了最小生成树的概念，以及寻找最小生成树的两个经典算法 ：Kruskal算法和Prim算法； • 拓扑排序：介绍了有向无环图（DAG）、AOV网络和AOE网络的概念、拓扑排 序算法、关键路径和关键活动的求解方法；","libVersion":"0.5.0","langs":""}