{"path":"01 数据结构和算法/PPT/第10章课件-内排序.pdf","text":"数据结构 计算机领域本科教育教学改革试点 工作计划（“101计划”）研究成果 授课教师：张羽丰 湖南大学 信息科学与工程学院 排序 第 10 章 10.1 问题引入 10.2 插入排序 10.3 选择排序 10.4 交换排序 10.5 归并排序 10.6 基于比较排序的复杂度分析 10.7 基于分配的排序 10.8 索引排序* 10.9 拓展延伸* 10.10 应用场景 10.1 问题引入 10.1 问题引入 排序是指将数据按照关键字重新排列为升序（从小到大）或降序（从大到小）的 处理。 • 升序：关键字从小到大 • 降序：关键字从大到小 示例： 待排序列：34 12 34’ 08 96 升序： 08 12 34’ 34 96 降序： 96 34 34’ 12 08 排序的稳定性 10.1 问题引入 若序列中关键字值相等的节点经过某种排序方法进行排序之后，仍能保持它们在 排序前的相对顺序，则称这种排序方法是稳定的；否则，称这种排序方法是不稳 定的。 稳定的排序算法有： • 插入排序、冒泡排序、归并排序 不稳定的排序算法： • 选择排序、快速排序、堆排序 示例： 待排序列： 稳定： 不稳定： 34 12 34’ 08 96 08 12 34 34’ 96 08 12 34’ 34 96 排序的分类 10.1 问题引入 • 内部排序、外部排序（根据内存使用情况） ◼ 内部排序：数据存储调整均在内存中进行 ◼ 外部排序：大部分节点在外存中，借助内存进行调整 • 比较、分配（根据排序实现手段） ◼ 基于“比较”的排序：通过对关键字的比较，交换关键字在序列中的位置 ⚫ 插入排序、冒泡排序、选择排序、快速排序、归并排序、希尔排序、堆 排序 ◼ 基于“分配”的排序：通过将元素进行分配和收集进行排序 ⚫ 基数排序、桶排序 • 根据实现的难易程度： ◼ 基本排序：插入排序、冒泡排序、选择排序、…… ◼ 高级排序：快速排序、归并排序、堆排序、基数排序、…… 10.2 插入排序 10.2 插入排序 基本思想:将一个记录插入到已排好顺序的序列中，形成一个新的、记录数增1的 有序序列 折半插入排序和希尔排序是插入排序的两种改进 直接插入排序 希尔排序 10.2.1 直接插入排序 10.2.1 直接插入排序 排序步骤：假设 𝑎0, 𝑎1, ⋯ , 𝑎𝑖−1 已排序 𝑎0 < 𝑎1 < ⋯ < 𝑎𝑖−1 , 对于𝑡 = 𝒂𝒊, 将他 与𝒂𝒊−𝟏, 𝒂𝒊−𝟐, … , 𝒂𝟎依次进行比较。 若 𝒂𝒋 > 𝑡, 则将 𝒂𝒋 向后移动一位。直到发现某个𝑗(0 ≤ 𝑗 ≤ 𝑖 − 1)； 若 𝒂𝒋 ≤ 𝑡, 则令 𝒂𝑗+1 = 𝑡，此时完成了将 𝒂𝒊 插入有序数组的过程； 如果这样的𝑎𝑗不存在，那么在比较过程中，𝑎𝑖−1, 𝑎𝑖−2, … , 𝑎0都依次后移一个位置， 此时令𝑎0 = 𝑡。 直接插入排序过程 10.2.1 直接插入排序 对关键字序列{68,65,84,65,83,84,82,85,67,84,85,82,69}进行升序排列 直接插入排序伪代码 10.2.1 直接插入排序 算法10-1 插入排序 InsertionSort 𝑎, 𝑙, 𝑟 输入：序列𝑎，左端点下标𝑙，右端点下标𝑟 输出：调整𝑎𝑙, 𝑎𝑙+1, … , 𝑎𝑟元素顺序，使元素按照非递减顺序排列 1 𝐟𝐨𝐫 𝑖 ← 𝑙 + 1 𝐭𝐨 𝑟 𝐝𝐨 //从左边界开始，依次获取每个记录 2 | 𝑡 ← 𝑎𝑖 3 | 𝐟𝐨𝐫 𝑗 ← 𝑖 − 1 𝐝𝐨𝐰𝐧𝐭𝐨 𝑙 𝐝𝐨 4 𝐢𝐟 𝑎𝑗 > 𝑡 𝐭𝐡𝐞𝐧 5 | | | 𝑎𝑗+1 ← 𝑎𝑗 //若当前记录小，则把前面的记录向后移一个位置 6 | | 𝐞𝐥𝐬𝐞 7 | | | 𝑎𝑗+1 ← 𝑡 //将最初获取的记录复制到相应位置 8 | | | 𝐛𝐫𝐞𝐚𝐤 9 | | 𝐞𝐧𝐝 10 | 𝐞𝐧𝐝 11 | 𝐢𝐟 𝑎𝑙 > 𝑡 𝐭𝐡𝐞𝐧 //如果𝑎𝑙 > 𝑡，将最初获取的记录置于序列开始 12 | | 𝑎𝑙 ← 𝑡 13 | 𝐞𝐧𝐝 14 𝐞𝐧𝐝 直接插入排序性能分析 10.2.1 直接插入排序 时间复杂度： 最佳情况（有序）：𝑶(𝒏) • 𝑛 − 1 次比较，0 次移动. 最坏情况（逆序）： 𝑶(𝒏𝟐) • 插入第 𝑖 个元素时，每次都需要比较前 𝑖 − 1 个元素才能找到插入位置。 • 𝑛(𝑛−1) 2 次比较，(𝑛+2) 𝑛−1 2 次移动. 平均情况：𝑶(𝒏𝟐) • 比较次数和记录移动次数约为𝑛2 4 • 𝑂(𝑛2) 次比较，𝑂(𝑛2) 次移动 直接插入排序性能分析 10.2.1 直接插入排序 空间复杂度：𝑶(𝟏) 对于每次排序，仅申请一个临时变量用于存储第i个元素，空间复杂度为𝑂(1) 稳定性分析：稳定 对于值相同的元素，可以选择将后面出现的元素，插入到前面出现元素的后面， 这样就可以保持原有的前后顺序不变，所以插入排序是稳定的排序算法。 适用场景：节点个数少。 10.2.2 折半插入排序 10.2.2 折半插入排序 折半插入排序是对直接插入排序的一种改进。当待排序序列较长时，如果采用折 半查找的方法，可以更快地寻找插入位置，减少关键码的比较次数。 折半插入排序虽然可以减少关键码的比较次数，但是并不减少排序元素的移动次 数。比较次数为O(𝑛𝑙𝑜𝑔𝑛)，移动次数为𝑂(𝑛2) 10.2.3 希尔排序 10.2.3 希尔排序 基本思想：相较于插入排序，对位置相隔较大距离的元素进行比较，使得元素在 比较后能够一次跨过较大的距离。 排序步骤： • 先给定一组严格递减的正整数增量𝒅𝟎, 𝒅𝟏, … , 𝒅𝒕−𝟏，且取𝒅𝒕−𝟏 = 𝟏。 • 对于𝒊=𝟎,𝟏,…,𝒕−𝟏，进行下面各遍的处理： ◆ 将序列分成𝒅𝒊组，每组中结点的下标相差𝒅𝒊 ◆ 对每组节点使用插入排序 希尔排序伪代码 10.2.3 希尔排序 算法10-2 希尔排序 ShellSort 𝑎, 𝑙, 𝑟 输入：序列𝑎，左端点下标𝑙，右端点下标𝑟 输出：调整𝑎𝑙, 𝑎𝑙+1, … , 𝑎𝑟元素顺序，使元素按照非递减顺序排列 1 𝑑 ← 𝑑1, 𝑑2, … , 𝑑𝑡 //希尔排序时使用的步长，根据不同步长循环进行插入排序 2 𝐟𝐨𝐫 𝑚 ← 1 to 𝑑 𝐝𝐨 //步长的个数 3 | 𝐟𝐨𝐫 𝑖 ← 𝑙 + 𝑑𝑚 to 𝑟 𝐝𝐨 //每个元素都往前插入排序一次 4 | | 𝑣 ← 𝑎𝑖 5 𝐟𝐨𝐫 𝑗 ← 𝑖 𝐝𝐨𝐰𝐧𝐭𝐨 𝑙 + 𝑑𝑚 𝐬𝐭𝐞𝐩 𝑑𝑚 𝐝𝐨 //对序列𝑎𝑗, 𝑎𝑗−𝑑𝑚, …进行插入排序，本组内 6 | | | 𝐢𝐟 𝑎𝑗−𝑑𝑚 > 𝑣 𝐭𝐡𝐞𝐧 7 | | | | 𝑎𝑗 ← 𝑎𝑗−𝑑𝑚 8 | | | 𝐞𝐥𝐬𝐞 9 | | | | 𝑎𝑗 ← 𝑣 10 | | | | 𝐛𝐫𝐞𝐚𝐤 12 | | | 𝐞𝐧𝐝 13 | | 𝐞𝐧𝐝 14 | 𝐞𝐧𝐝 15 𝐞𝐧𝐝 希尔排序过程 10.2.3 希尔排序 对关键字序列{57,26,72,88,48,42,36,84,66}进行升序排列，设置增量序列为𝑑 = {4,3,1} 希尔排序性能分析 10.2.3 希尔排序 时间复杂度： 依赖于增量序列，没有确切结论 空间复杂度：𝑶(𝟏) 稳定性分析：不稳定 步长序列 最坏情况下复杂度 n / 2i (n2) 2k − 1 (n3 / 2) 2i3i (nlog 2n) 10.3 选择排序 10.3 选择排序 基本思想：首先选出键值最小的项，将它与第一个项交换位置；然后选出键值次 小的项，将其与第二个项交换位置；…；直到整个序列完成排序。 步骤： • 假设待排序的序列为𝑎0, 𝑎1, 𝑎2, ⋯ , 𝑎𝑛−1 • 依次对𝑖 = 0, 1, ⋯ , 𝑛 − 2 执行如下步骤： • 在 𝑎𝑖, 𝑎𝑖+1, ⋯ , 𝑎𝑛−1 中选择一个键值最小的项𝑎𝑘 • 将 𝑎𝑖 与 𝑎𝑘 交换。 10.3.1 简单选择排序 10.3.1 简单选择排序 简单选择排序在从待排序序列中选出键值最小的项时，所用的策略是简单的逐个枚举法。 简单选择排序过程 简单选择排序伪代码 10.3.1 简单选择排序 算法10-3 简单选择排序 𝑆𝑒𝑙𝑒𝑐𝑡𝑖𝑜𝑛𝑆𝑜𝑟𝑡(𝑎, 𝑙, 𝑟) 输入：序列𝑎，左端点下标𝑙，右端点下标𝑟 输出：调整𝑎𝑙, 𝑎𝑙+1, … , 𝑎𝑟元素顺序，使元素按照非递减顺序排列 1 𝐟𝐨𝐫 𝑖 ← 𝑙 to 𝑟 − 1 𝐝𝐨 //依次从剩余未排序序列中选取一个最小的记录 2 | 𝑚𝑖𝑛 ← 𝑖 3 | 𝐟𝐨𝐫 𝑗 ← 𝑖 + 1 to 𝑟 𝐝𝐨 4 𝐢𝐟 𝑎𝑗 < 𝑎𝑚𝑖𝑛 𝐭𝐡𝐞𝐧 5 | | | 𝑚𝑖𝑛 ← 𝑗 6 | | 𝐞𝐧𝐝 7 | | 𝑡 ← 𝑎𝑖 //将当前的最小记录放入已排序好的队列的末尾 8 | | 𝑎𝑖 ← 𝑎𝑚𝑖𝑛 9 | | 𝑎𝑚𝑖𝑛 ← 𝑡 10 | 𝐞𝐧𝐝 11 𝐞𝐧𝐝 简单选择排序性能分析 10.3.1 简单选择排序 时间复杂度： 最佳情况（有序）：𝑶(𝒏 𝟐) • 𝑛(𝑛−1) 2 次比较，0 次移动. 最坏情况（逆序）： 𝑶(𝒏𝟐) • 𝑛(𝑛−1) 2 次比较， 𝑛 − 1 次移动. 平均情况：𝑶(𝒏𝟐) • 𝑂(𝑛2) 次比较，𝑂(𝑛) 次移动 简单选择排序性能分析 10.3.1 简单选择排序 空间复杂度：𝑶(𝟏) 排序时仅交换未排序序列中最值与未排序序列起始位置，不涉及额外空间的使用。 稳定性分析：不稳定 交换操作时可能会破坏具有相同key值元素的相对位置。因此选择排序为不稳定排 序。 运行时间与记录顺序关系很小 交换次数很少 10.3.2 堆排序 10.3.2 堆排序 基本思想：在简单选择排序中，从长度为𝑘的待排序序列中选出键值最小的项时， 所需的时间复杂度为𝑂 𝑘 。将待排序序列组成优先级队列，则可以优化这一步骤 排序步骤：假设待排序序列为已经建好堆的序列𝑎1, 𝑎2, … , 𝑎𝑛，依次对𝑖 = 𝑛, 𝑛 − 1, … , 2分别执行如下的选择步骤：在𝑎1, 𝑎2, … , 𝑎𝑖中选择一个键值最大的项𝑎1（堆 顶），然后将𝑎𝑖与𝑎1交换并修复堆。 初始堆建立过程 10.3.2 堆排序 （0）初始状态 （1）堆修复：无动作 下沉方法建堆 初始堆建立过程 10.3.2 堆排序 （2）堆修复：调整堆顶 （3）堆修复：调整堆顶 下沉方法建堆 初始堆建立过程 10.3.2 堆排序 （4）堆修复：无动作 （5）堆修复：调整堆顶和堆内修复 下沉方法建堆 初始堆建立过程 10.3.2 堆排序 （6）堆修复：调整堆顶和堆内修复 （7）修复完成，获得最终状态 下沉方法建堆 堆排序过程 10.3.2 堆排序 （0）初始状态 （1）堆顶调整 85 65 65 68 83 82 69 67 84 84 82 85 84 85 85 84 67 84 84 82 65 65 68 83 82 69 取出当前堆中最大值，放到最后面 堆排序过程 10.3.2 堆排序 （2）堆修复 范围1~𝑁 − 1 （3）堆顶调整 取出当前堆中最大值，放到最后面 堆排序过程 10.3.2 堆排序 （4）堆修复 范围1~𝑁 − 2 （5）堆修复 范围1~2 取出当前堆中最大值，放到最后面 堆排序伪代码 10.3.2 堆排序 算法10-4 堆排序 HeapSort(𝑎, 𝑙, 𝑟) 输入：序列𝑎，左端点下标𝑙，右端点下标𝑟 输出：调整𝑎𝑙, 𝑎𝑙+1, … , 𝑎𝑟元素顺序，使元素按照非递减顺序排列 1 𝑛 ← 𝑟 − 𝑙 + 1 2 𝑀𝑎𝑘𝑒𝐻𝑒𝑎𝑝𝐷𝑜𝑤𝑛( 𝑎 𝑙, … , 𝑎 𝑟 ) //建最大堆 3 𝐰𝐡𝐢𝐥𝐞 𝑛 > 1 𝐝𝐨 //基于堆的排序 4 | 𝑡 ← 𝑎𝑙 //堆顶 5 | 𝑎𝑙 ← 𝑎𝑙+𝑛−1 //堆顶与要放到后面的位置的元素交换 6 | 𝑎𝑙+𝑛−1 ← 𝑡 7 | 𝑛 ← 𝑛 − 1 8 | 𝑆𝑖𝑓𝑡𝐷𝑜𝑤𝑛( 𝑎𝑙, … , 𝑎𝑙+𝑛−1 , 𝑙) //交换后的堆顶下沉 9 𝐞𝐧𝐝 堆排序性能分析 10.3.2 堆排序 时间代价：𝑶 𝒏 𝐥𝐨𝐠 𝒏 对𝑛个元素进行堆排序，建立初始堆需要线性时间，即时间复杂度为𝑂(𝑛)，排序 过程中需要的比较次数至多为2𝑛 log 𝑛，因为每下沉一次，要与两个子节点中较大 的交换，因而比较两次，下沉次数为log n。因此总的时间复杂度为𝑂(𝑛 log n)。 空间代价：𝑶(𝟏) 稳定性：不稳定 在堆排序中，会将堆顶元素与数组末尾元素进行交换，这一操作会破坏数组的稳 定性，故堆排序是不稳定排序。 10.4 交换排序 10.4 交换排序 数据结构 核心思路：对序列中的元素进行多次两两交换，从而使序列元素有序。 冒泡排序 快速排序 68 65 84 65 83 84 82 85 67 84 85 82 69 68 65 67 65 69 84 82 85 84 84 85 82 83 65 65 67 68 67 68 82 82 83 84 84 85 84 85 82 82 84 84 84 85 85 84 84 84 65 65 67 68 69 82 82 83 84 84 84 85 85 68 65 84 65 83 84 82 85 67 84 85 82 69 65 68 65 84 67 83 84 82 85 69 84 85 82 65 65 68 67 84 69 83 84 82 85 82 84 85 65 65 67 68 69 84 82 83 84 82 85 84 85 65 65 67 68 69 82 84 82 83 84 84 85 85 65 65 67 68 69 82 82 84 83 84 84 85 85 65 65 67 68 69 82 82 83 84 84 84 85 85 65 65 67 68 69 82 82 83 84 84 84 85 85 65 65 67 68 69 82 82 83 84 84 84 85 85 65 65 67 68 69 82 82 83 84 84 84 85 85 65 65 67 68 69 82 82 83 84 84 84 85 85 65 65 67 68 69 82 82 83 84 84 84 85 85 65 65 67 68 69 82 82 83 84 84 84 85 85 10.4.1 冒泡排序 10.4.1 冒泡排序 数据结构 基本思想：依次比较相邻的两个元素的顺序，如果顺序不对，则将两 者交换，重复这样的操作直到整个序列被排好序。 通过比较与交换使得待排序列一个最值元素“上浮”到序列一端，然 后缩小排序范围。 排序步骤：（以升序为例） • 假设待排序序列为 𝑎0, 𝑎1, … , 𝑎𝑛−1。 • 起始时排序范围为 𝑎0 到 𝑎n−1。 • 从右向左对相邻两元素进行比较，较大值向右移，较小值向左移。 比较完当前排序范围后，键值最小的元素被移动到 𝑎0 位置。 • 下一次排序范围是 𝑎1 到 𝑎n−1。 冒泡排序示例 数据结构 待排序数组 第一轮 第二轮 第三轮 第四轮 第五轮 第六轮 第七轮 第八轮 第九轮 第十轮 第十一轮 第十二轮 68 65 84 65 83 84 82 85 67 84 85 82 69 65 68 65 84 67 83 84 82 85 69 84 85 82 65 65 68 67 84 69 83 84 82 85 82 84 85 65 65 67 68 69 84 82 83 84 82 85 84 85 65 65 67 68 69 82 84 82 83 84 84 85 85 65 65 67 68 69 82 82 84 83 84 84 85 85 65 65 67 68 69 82 82 83 84 84 84 85 85 65 65 67 68 69 82 82 83 84 84 84 85 85 65 65 67 68 69 82 82 83 84 84 84 85 85 65 65 67 68 69 82 82 83 84 84 84 85 85 65 65 67 68 69 82 82 83 84 84 84 85 85 65 65 67 68 69 82 82 83 84 84 84 85 85 65 65 67 68 69 82 82 83 84 84 84 85 85 未排序 已排序 本轮排序 10.4.1 冒泡排序 冒泡排序伪代码 10.4.1 冒泡排序 数据结构 1 𝐟𝐨𝐫 𝑖 ← 𝑙 to 𝑟 𝐝𝐨 //冒泡次数 2 | 𝐟𝐨𝐫 𝑗 ← 𝑟 − 1 𝐝𝐨𝐰𝐧𝐭𝐨 𝑖 𝐝𝐨 //从右往左冒泡 3 𝐢𝐟 𝑎𝑗 > 𝑎𝑗+1 𝐭𝐡𝐞𝐧 4 | | | Swap 𝑎𝑗, 𝑎𝑗+1 //两个元素交换位置 5 | | 𝐞𝐧𝐝 6 | 𝐞𝐧𝐝 7 𝐞𝐧𝐝 算法10-5 冒泡排序 BubbleSort 𝑎, 𝑙, 𝑟 输入：序列𝑎，左端点下标𝑙，右端点下标𝑟 输出：调整𝑎𝑙, 𝑎𝑙+1, … , 𝑎𝑟元素顺序，使元素按照非递减顺序排列 冒泡排序性能分析 10.4.1 冒泡排序 数据结构 假设待排序的序列长度为𝑛，那么冒泡排序共执行𝑛轮，第𝑖轮时最多需要执行𝑛 − 𝑖 次比较和交换。因此，冒泡排序最多的比较和交换次数为： ෍ 𝑖=1 𝑛 𝑛 − 𝑖 = 𝑛(𝑛 − 1) 2 所以，冒泡排序的时间复杂度为𝑶 𝒏𝟐 。 冒泡排序仅对数组中的相邻元素进行比较和交换，因此关键字值相同的元素不会 改变顺序。所以，冒泡排序是稳定的。 但注意，一旦将算法10-5中比较运算𝑎𝑗 > 𝑎𝑗+1改为𝑎𝑗 ≥ 𝑎𝑗+1 ，算法就失去了稳定 性。 另外，冒泡排序中的交换次数又称为反序数或逆序数，可用于体现数列的错乱程 度。 10.4.2 快速排序 10.4.2 快速排序 数据结构 快速排序是一种所需比较次数较少、速度较快的排序方法，由英国计 算机科学家，图灵奖获得者东尼·霍尔于1961年发表。在基于比较的 排序算法中，快速排序的平均性能突出。 基本思想：通过递归分治方法，基于轴点将待排序序列拆分成两个子 序列并分别排序，直到序列有序。 排序步骤： • 从待排序序列中选取轴点。 • 通过交换序列元素，将待排序序列拆分为左右两个子序列，左子序 列元素小于等于轴点，右子序列元素大于等于轴点。 • 对两个子序列递归进行上述操作，直到子序列元素个数小于等于1。 快速排序的序列拆分 10.4.2 快速排序 数据结构 序列拆分（Partition）会根据所选轴点将序列拆分成两个子序列，进 而确定轴点在序列的最终位置。 对于序列𝑎𝑙, … , 𝑎𝑟和轴点元素𝑝，我们需要交换序列中的元素，将轴点 𝑝置于正确的位置𝑎𝑖，使得𝒂𝒍, … , 𝒂𝒊−𝟏 ≤ 𝒂𝒊 ≤ 𝒂𝒊+𝟏, … , 𝒂𝒓， 即 𝑎𝑙, … , 𝑎𝑖−1 均小于等于轴点， 𝑎𝑖+1, … , 𝑎𝑟 均大于等于轴点，并返 回轴点所在下标𝑖。 快速排序的序列拆分 10.4.2 快速排序 数据结构 序列拆分（Partition）会根据所选轴点将序列拆分成两个子序列，进 而确定轴点在序列的最终位置。 对于序列𝑎𝑙, … , 𝑎𝑟和轴点元素𝑝，我们需要交换序列中的元素，将轴点 𝑝置于正确的位置𝑎𝑖，使得𝒂𝒍, … , 𝒂𝒊−𝟏 ≤ 𝒂𝒊 ≤ 𝒂𝒊+𝟏, … , 𝒂𝒓， 即 𝑎𝑙, … , 𝑎𝑖−1 均小于等于轴点， 𝑎𝑖+1, … , 𝑎𝑟 均大于等于轴点，并返 回轴点所在下标𝑖。 𝑎𝑙 … 𝑎𝑟 𝑎𝑙 𝑎𝑖−1 𝑎𝑖 𝑎𝑖+1 𝑎𝑟 Partition Partition Partition … … 序列拆分示例 10.4.2 快速排序 数据结构 对序列𝑎 = 75, 34, 45, 32, 78, 12, 34’, 40 进行一次拆分，其中𝑙 = 0, 𝑟 = 7。 1. 𝑖指向待划分区域首元素，𝑗指向待 划分区域尾元素 2. 𝑝 = 𝑎𝑗(将作为轴点的元素暂存) i j轴点 40 75 34 45 32 78 12 34’ 40 0 1 2 3 4 5 6 7 75 34 45 32 78 12 34’ 40 序列拆分示例 10.4.2 快速排序 数据结构 对序列𝑎 = 75, 34, 45, 32, 78, 12, 34’, 40 进行一次拆分，其中𝑙 = 0, 𝑟 = 7。 1. 𝑖指向待划分区域首元素，𝑗指向待 划分区域尾元素 2. 𝑝 = 𝑎𝑗(将作为轴点的元素暂存) 3. 𝑖从前往后移动直到找到一个比轴 点大的项 4. 𝑗从后往前移动直到找到一 个比轴点小的项 75 34 45 32 78 12 34’ 40 0 1 2 3 4 5 6 7 75 34 45 32 78 12 34’ 40 轴点 40 i j 序列拆分示例 10.4.2 快速排序 数据结构 对序列𝑎 = 75, 34, 45, 32, 78, 12, 34’, 40 进行一次拆分，其中𝑙 = 0, 𝑟 = 7。 1. 𝑖指向待划分区域首元素，𝑗指向待 划分区域尾元素 2. 𝑝 = 𝑎𝑗(将作为轴点的元素暂存) 3. 𝑖从前往后移动直到找到一个比轴 点大的项 75 34 45 32 78 12 34’ 40 0 1 2 3 4 5 6 7 75 34 45 32 78 12 34’ 40 轴点 40 i j 4. 𝑗从后往前移动直到找到一 个比轴点小的项 5. 交换 𝑎0 与 𝑎6 序列拆分示例 10.4.2 快速排序 数据结构 对序列𝑎 = 75, 34, 45, 32, 78, 12, 34’, 40 进行一次拆分，其中𝑙 = 0, 𝑟 = 7。 1. 𝑖指向待划分区域首元素，𝑗指向待 划分区域尾元素 2. 𝑝 = 𝑎𝑗(将作为轴点的元素暂存) 3. 𝑖从前往后移动直到找到一个比轴 点大的项 34’ 34 45 32 78 12 75 40 0 1 2 3 4 5 6 7 75 34 45 32 78 12 34’ 40 轴点 40 i j 4. 𝑗从后往前移动直到找到一 个比轴点小的项 5. 交换 𝑎0 与 𝑎6 序列拆分示例 10.4.2 快速排序 数据结构 对序列𝑎 = 75, 34, 45, 32, 78, 12, 34’, 40 进行一次拆分，其中𝑙 = 0, 𝑟 = 7。 1. 𝑖指向待划分区域首元素，𝑗指向待 划分区域尾元素 2. 𝑝 = 𝑎𝑗(将作为轴点的元素暂存) 3. 𝑖从前往后移动直到找到一个比轴 点大的项 4. 𝑗从后往前移动直到找到一 个比轴点小的项 5. 交换 𝑎0 与 𝑎6 6. goto 3 轴点 40 7. 再一次循环后：交换 𝑎2 与 𝑎5 i 34’ 34 45 32 78 12 75 40 0 1 2 3 4 5 6 7 75 34 45 32 78 12 34’ 40 j 序列拆分示例 10.4.2 快速排序 数据结构 对序列𝑎 = 75, 34, 45, 32, 78, 12, 34’, 40 进行一次拆分，其中𝑙 = 0, 𝑟 = 7。 1. 𝑖指向待划分区域首元素，𝑗指向待 划分区域尾元素 2. 𝑝 = 𝑎𝑗(将作为轴点的元素暂存) 3. 𝑖从前往后移动直到找到一个比轴 点大的项 4. 𝑗从后往前移动直到找到一 个比轴点小的项 5. 交换 𝑎0 与 𝑎6 6. goto 3 轴点 40 7. 再一次循环后：交换 𝑎2 与 𝑎5 i 34’ 34 12 32 78 45 75 40 0 1 2 3 4 5 6 7 75 34 45 32 78 12 34’ 40 j 序列拆分示例 10.4.2 快速排序 数据结构 对序列𝑎 = 75, 34, 45, 32, 78, 12, 34’, 40 进行一次拆分，其中𝑙 = 0, 𝑟 = 7。 1. 𝑖指向待划分区域首元素，𝑗指向待 划分区域尾元素 2. 𝑝 = 𝑎𝑗(将作为轴点的元素暂存) 3. 𝑖从前往后移动直到找到一个比轴 点大的项 4. 𝑗从后往前移动直到找到一 个比轴点小的项 5. 交换 𝑎0 与 𝑎6 6. goto 3 轴点 40 i 34’ 34 12 32 78 45 75 40 0 1 2 3 4 5 6 7 75 34 45 32 78 12 34’ 40 j 7. 再一次循环后：交换 𝑎2 与 𝑎5 8. 再一次循环后：𝑖 ≥ 𝑗循环结束 序列拆分示例 10.4.2 快速排序 数据结构 对序列𝑎 = 75, 34, 45, 32, 78, 12, 34’, 40 进行一次拆分，其中𝑙 = 0, 𝑟 = 7。 1. 𝑖指向待划分区域首元素，𝑗指向待 划分区域尾元素 2. 𝑝 = 𝑎𝑗(将作为轴点的元素暂存) 3. 𝑖从前往后移动直到找到一个比轴 点大的项 4. 𝑗从后往前移动直到找到一 个比轴点小的项 5. 交换 𝑎0 与 𝑎6 6. goto 3 轴点 40 i 34’ 34 12 32 78 45 75 40 0 1 2 3 4 5 6 7 75 34 45 32 78 12 34’ 40 j 7. 再一次循环后：交换 𝑎2 与 𝑎5 8. 再一次循环后：𝑖 ≥ 𝑗循环结束 9. 交换𝑎𝑖与𝑎𝑟，划分结束 序列拆分示例 10.4.2 快速排序 数据结构 对序列𝑎 = 75, 34, 45, 32, 78, 12, 34’, 40 进行一次拆分，其中𝑙 = 0, 𝑟 = 7。 1. 𝑖指向待划分区域首元素，𝑗指向待 划分区域尾元素 2. 𝑝 = 𝑎𝑗(将作为轴点的元素暂存) 3. 𝑖从前往后移动直到找到一个比轴 点大的项 4. 𝑗从后往前移动直到找到一 个比轴点小的项 5. 交换 𝑎0 与 𝑎6 6. goto 3 轴点 40 i 34’ 34 12 32 40 45 75 78 0 1 2 3 4 5 6 7 75 34 45 32 78 12 34’ 40 j 7. 再一次循环后：交换 𝑎2 与 𝑎5 8. 再一次循环后：𝑖 ≥ 𝑗循环结束 9. 交换𝑎𝑖与𝑎𝑟，划分结束 快速排序示例 10.4.2 快速排序 数据结构 68 65 84 65 83 84 82 85 67 84 85 82 69 68 65 67 65 69 84 82 85 84 84 85 82 83 65 65 67 68 67 68 82 82 83 84 84 85 84 85 82 82 84 84 84 85 85 84 84 84 65 65 67 68 69 82 82 83 84 84 84 85 85 被选为轴点 序列拆分后轴 点所在位置 序列拆分伪代码 10.4.2 快速排序 数据结构 算法10-5 序列拆分 Partition 𝑎, 𝑙, 𝑟 输入：序列𝑎，左端点下标𝑙，右端点下标𝑟 输出：将序列a根据轴点拆分，并输出轴点在序列中的位置 1 𝑖 ← 𝑙 2 𝑗 ← 𝑟 − 1 3 𝑝 ← 𝑎𝑟 //选择序列最后一个元素作为轴点 4 while true do 5 | 𝐰𝐡𝐢𝐥𝐞 𝑎𝑖 < 𝑝 𝐝𝐨 //找到𝑖以右第一个大于等于轴点的元素 6 𝑖 ← 𝑖 + 1 //i不会大于r，因为p=ar 7 | 𝐞𝐧𝐝 8 | 𝐰𝐡𝐢𝐥𝐞 𝑎𝑗 > 𝑝 𝐚𝐧𝐝 𝑗 > 𝑙 𝐝𝐨 //找到𝑗以前第一个小于等于 轴点的元素 9 𝑗 ← 𝑗 − 1 10 | 𝐞𝐧𝐝 11 | 𝐢𝐟 𝑖 ≥ 𝑗 𝐭𝐡𝐞𝐧 //如果i大于等于j，完成拆分，退出循环 12 𝐛𝐫𝐞𝐚𝐤 13 | 𝐞𝐧𝐝 14 | Swap 𝑎𝑖, 𝑎𝑗 //交换𝑎𝑖和𝑎𝑗并右移𝑖左移𝑗 15 | 𝑖 ← 𝑖 + 1 16 | 𝑗 ← 𝑗 − 1 17 𝐞𝐧𝐝 18 Swap(𝑎𝑖, 𝑎𝑟) 19 //此时 𝑎𝑙, … , 𝑎𝑖−1 ≤ 𝑎𝑖 ≤ 𝑎𝑖+1, … , 𝑎𝑟 20 𝐫𝐞𝐭𝐮𝐫𝐧 𝑖 快速排序伪代码 10.4.2 快速排序 数据结构 1 𝐢𝐟 𝑖 < 𝑟 𝐭𝐡𝐞𝐧 //超过1个元素才进行排序 2 | i ← Partition(𝑎, 𝑙, 𝑟) 3 | QuickSort(𝑎, 𝑙, 𝑖 − 1) 4 | QuickSort(𝑎, 𝑖 + 1, 𝑟) 5 𝐞𝐧𝐝 算法10-5 快速排序 QuickSort 𝑎, 𝑙, 𝑟 输入：序列𝑎，左端点下标𝑙，右端点下标𝑟 输出：调整𝑎𝑙, 𝑎𝑙+1, … , 𝑎𝑟元素顺序，使元素按照非递减顺序排列 快速排序性能分析 10.4.2 快速排序 数据结构 最坏情况分析： 对于已经排序好的序列𝑎𝑙 , … , 𝑎𝑟，第一轮选择序列最后一个元素𝑎𝑟作 为轴点，这时通过Partition，所有元素和轴点进行一次比较后，仍需 要递归执行快速排序的子序列为 𝑎𝑙 , … , 𝑎𝑟−1 ；第二轮选择 𝑎𝑟−1 为轴点， 并与其他元素进行比较；...…；直到序列长度为1。 上述过程中，第𝑖轮需要排序的元素个数为𝒓 − 𝒍 − 𝒊 + 𝟐，共需要𝒏轮才 能完成排序，需要的比较次数为𝑶(𝒏𝟐)。 快速排序最佳时间复杂度 10.4.2 快速排序 数据结构 68 65 84 65 83 84 82 85 67 84 85 82 69 68 65 67 65 69 84 82 85 84 84 85 82 83 65 65 67 68 67 68 82 82 83 84 84 85 84 85 82 82 84 84 84 85 85 84 84 84 65 65 67 68 69 82 82 83 84 84 84 85 85 被选为轴点 序列拆分后轴 点所在位置 每次迭代将数组 平均分为两份， 树高为log n， 每层计算量O(n)， 因此复杂度为 O(n log n) 快速排序性能分析 10.4.2 快速排序 数据结构 时间复杂度： • 最坏时间复杂度：𝑶 𝒏𝟐 • 平均时间复杂度：𝑶 𝒏 𝐥𝐨𝐠 𝒏 空间复杂度（递归栈深度）： • 最坏时间复杂度：𝑶 𝒏 • 平均时间复杂度：𝑶 𝐥𝐨𝐠 𝒏 快速排序是不稳定排序。 快速排序的轴点选择 10.4.2 快速排序 数据结构 快速排序具有优秀的平均性能，但是最坏情况下性能会退化成和冒泡 排序相当。这是因为快速排序非常依赖于轴点的选择，如果轴点选择 的不好，会导致子序列划分不均。因此，可以使用下述方法对轴点选 择进行改进： • 选取序列中𝑎𝑙, 𝑎𝑙+𝑟 2 , 𝑎𝑟三个元素的中位数作为轴点 • 随机选取一个序列内元素作为轴点 • 将上述两种选取策略结合：首先从序列内随机选择三个元素， 并选择三个元素的中位数作为轴点 需要指出的是，上述轴点选择策略都只能降低快速排序退化的概率， 而不能完全避免快速排序退化。 10.5 归并排序 10.5 归并排序 数据结构 核心思路：基于分治思想，将两个或两个以上的有序序列合并为一个新的有序序 列。 归并次序： • 自顶向下：将序列拆分直到有序；然后使用归并算法得到排序结果。 • 自底向上：将序列看成多条有序子序列，并将子序列两两合并。 应用场景： • 求逆序数对：通过归并排序，快速计算序列中逆序数对的数量。 10.5.1 二路归并 10.5.1 二路归并 数据结构 二路归并算法将两个有序序列合并为一个新的有序序列。 对两有序序列，分别取出这两个序列中键值最小的项，并选出两个数据项中最小 的放置到新的序列中；循环上述动作，直到两个序列中的所有数据都已被放置到 新的序列中。此时，新的序列即为排序结果。 对于长度分别为𝑛和𝑚的有序序列，二路归并算法的主循环最多执行𝑛 + 𝑚次，因 此其复杂度为𝑶 𝒏 + 𝒎 。 二路归并伪代码 10.5.1 二路归并 数据结构 1 𝑡 ← 空序列 2 𝑖 ← 𝑙𝑥 3 𝑗 ← 𝑙𝑦 4 𝐰𝐡𝐢𝐥𝐞 𝑖 ≤ 𝑟𝑥 or 𝑗 ≤ 𝑟𝑦 𝐝𝐨 5 | 𝐢𝐟 𝑗 > 𝑟𝑦 𝐨𝐫 𝑖 ≤ 𝑟𝑥 𝐚𝐧𝐝 𝑎𝑖 ≤ 𝑎𝑗 𝐭𝐡𝐞𝐧 6 | | 将𝑎𝑖添加至𝑡末尾 7 𝑖 ← 𝑖 + 1 8 | 𝐞𝐥𝐬𝐞 9 将𝑎𝑗添加至𝑡末尾 10 𝑗 ← 𝑗 + 1 11 | 𝐞𝐧𝐝 12 𝐞𝐧𝐝 13 𝐫𝐞𝐭𝐮𝐫𝐧 𝑡 算法10-8 二路归并 TwoWayMerge 𝑎, 𝑙𝑥, 𝑟𝑥, 𝑙𝑦, 𝑟𝑦 输入：序列𝑎及其有序子序列𝑥和𝑦的下 标范围𝑙𝑥, 𝑟𝑥和𝑙𝑦, 𝑟𝑦 输出：将两个有序序列合并后的新有 序序列𝑡 10.5.2 归并排序 10.5.2 归并排序 数据结构 利用上述归并思想和二路归并算法来实现的排序算法称为归并排序。 算法首先将序列拆分，直到被拆分的子序列长度为1，此时子序列显然有序。 然后，使用上述二路归并算法，将有序的短序列依次合并为长序列，最终完成序 列的排序。 据归并时对子序列划分方式的不同，归并排序算法又可分为自顶向下和自底向上 两种。 自顶向下归并排序示例 10.5.2 归并排序 数据结构 自顶向下归并排序伪代码 10.5.2 归并排序 数据结构 1 𝐢𝐟 𝑙 < 𝑟 𝐭𝐡𝐞𝐧 //序列中有至少两个元素待排 2 | 𝑚 ← (𝑙 + 𝑟)/2 3 | MergeSort(𝑎, 𝑙, 𝑚) 4 | MergeSort(𝑎, 𝑚 + 1, 𝑟) 5 6 | 𝑎𝑙, … , 𝑎𝑟 ← TwoWayMerge(𝑎, 𝑙, 𝑚, 𝑚 + 1, 𝑟) end 算法10-9 归并排序 MergeSort 𝑎, 𝑙, 𝑟 输入：序列𝑎，左端点下标𝑙，右端点下标𝑟 输出：调整𝑎𝑙, 𝑎𝑙+1, … , 𝑎𝑟元素顺序，使元素按照非递减顺序排列 自底向上归并排序示例 10.5.2 归并排序 数据结构 自底向上归并排序伪代码 10.5.2 归并排序 数据结构 算法10-9 自底向上归并排序 MergeSortBottomUp 𝑎, 𝑙, 𝑟 输入：序列𝑎，左端点下标𝑙，右端点下标𝑟 输出：调整𝑎𝑙, 𝑎𝑙+1, … , 𝑎𝑟元素顺序，使元素按照非递减顺序排列 1. sorted_len ← 1 //当前有序子列长度 2. n ← r-l+1 //待排元素个数，即序列长度 3. while sorted_len < n do //当前有序子列长度小于序列长度，则相邻两子序列归并 4. | lx ← l //左子序列从最左端开始 5. | while lx ≤ r-sorted_len do 6. | | rx ← lx+sorted_len-1 //左子序列的右端点 7. | | ly ← rx+1 //右子序列的左端点 8. | | ry ← Min(ly+sorted_len-1, r) //右子序列的右端点 9. | | 𝑎𝑙𝑥, … , 𝑎𝑟𝑦 ← TwoWayMerge(𝑎, 𝑙 𝑥, 𝑟𝑥, 𝑙 𝑦, 𝑟 𝑦) //归并 10. | | lx ← ry+1 //下一对子序列的左子序列的左端点 11. | end 12. | sorted_len ← sorted_len × 2 //有序子列长度加倍 13. end 归并排序性能分析 10.5.2 归并排序 数据结构 由于二路归并算法的复杂度为两个序列长度之和𝑂 𝑛 + 𝑚 ，因此我们分析每个元 素至多会被二路归并算法调用几次。 自顶向下： 递归的深度每多一层，其待排序序列的长度就减半；同时，对于任意深度相同的 递归调用，它们所覆盖的元素不相交。因此，递归的最大深度为 𝐥𝐨𝐠 𝐧 ，且每层 递归最多覆盖𝑛个元素，其时间复杂度为𝐎 𝐧 𝐥𝐨𝐠 𝒏 。 自底向上： 其外循环的最大循环次数为 𝐥𝐨𝐠 𝐧 ，内循环将每个元素进行二路归并最多一次， 因此复杂度也为𝐎 𝐧 𝐥𝐨𝐠 𝒏 。 归并排序的改进 10.5.2 归并排序 数据结构 从二路归并的伪代码可以看到，需要使用一个临时数组来存储归并结果，并在归 并排序完成后将结果拷贝回原数组，共进行𝟐𝒏 + 𝟐𝒎次拷贝。在序列元素占用内 存较大时，拷贝可能花费大量时间。实际上，可以通过互换当前数组和临时数组 的技巧来减少一半的拷贝时间。 以自底向上的归并排序为例，当外循环进行奇数次时，𝑎作为有序子序列，𝑡作为 存放合并结果的临时序列；当外循环进行偶数次时，𝑡作为有序子序列，𝑎作为存 放合并结果的临时序列。 改进后二路归并的伪代码 10.5.2 归并排序 数据结构 1 𝑖 ← 𝑙 //左子序列当前待比较的元素位置 2 𝑗 ← 𝑚 + 1 //右子序列当前待比较的元素位置 3 𝑘 ← 𝑙 //结果序列当前待放入的元素位置 4 𝐰𝐡𝐢𝐥𝐞 𝑖 ≤ 𝑚 or 𝑗 ≤ 𝑟 𝐝𝐨 5 | 𝐢𝐟 𝑗 > 𝑟 or 𝑖 ≤ 𝑚 and 𝑎𝑖 ≤ 𝑎𝑗 𝐭𝐡𝐞𝐧 6 tk ← ai 7 𝑖 ← 𝑖 + 1 8 𝑘 ← 𝑘 + 1 9 | 𝐞𝐥𝐬𝐞 10 tk ← aj 11 𝑗 ← 𝑗 + 1 12 𝑘 ← 𝑘 + 1 13 | 𝐞𝐧𝐝 14 𝐞𝐧𝐝 算法10-11 改进二路归并 TwoWayMergeImproved 𝑎, 𝑙𝑥, 𝑟𝑥, 𝑙𝑦, 𝑟𝑦 输入：序列𝑎及其有序子序列𝑥和𝑦的下标范围𝑙𝑥, 𝑟𝑥和𝑙𝑦, 𝑟𝑦 输出：将两个有序序列合并后的新有序序列𝑡 改进后自底向上归并排序的伪代码 10.5.2 归并排序 数据结构 算法10-12 改进自底向上归并排序 MergeSortBottomUp 𝑎, 𝑙, 𝑟 输入：序列𝑎，左端点下标𝑙，右端点下标𝑟 输出：调整𝑎𝑙, 𝑎𝑙+1, … , 𝑎𝑟元素顺序，使元素按照非递减顺序排列 1. sorted_len ← 1 //当前有序子列长度 2. n ← r-l+1 //待排元素个数，即序列长度 3. count ← 0 4. while sorted_len < n do //当前有序子列长度小于序列 长度，则相邻两子序列归并 5. | count ← count + 1 6. | lx ← l //左子序列从最左端开始 7. | while lx ≤ r-sorted_len do 8. | | rx ← lx+sorted_len-1 //左子序列的右端点 9. | | ry ← Min(rx+sorted_len, r) //右子序列的右端点 10. | | if count%2=1 then 11. | | | TwoWayMergeImproved(a, t, lx, rx, ry) //a并入t 12. | | else 13. | | | TwoWayMergeImproved(t, a, lx, rx, ry) //t并入a 14. | | end 15. | | lx ← ry+1 //下一对子序列的左子序列的左端点 16. | end 17. | sorted_len ← sorted_len × 2 //有序子列长度加倍 18. end 求逆序对数量 10.5.2 归并排序 数据结构 归并排序的一个经典应用是求逆序对数量。 在一个序列中，两个元素𝑎𝑖和𝑎𝑗逆序指它们满足𝑖 < 𝑗和𝑎𝑖 > 𝑎𝑗，称这两个元素为 一个逆序对。求一个序列的逆序对数量则是找到序列中有多少组不同的𝑖和𝑗，满 足𝑎𝑖和𝑎𝑗是逆序对。 显然，当序列有序时，序列的逆序对数量为零。一种最简单的方法是枚举所有可 能的𝑖和𝑗，如果逆序则答案加一。这种算法的时间复杂度为𝑶 𝒏 𝟐 。 基于归并排序算法思想，可以在𝑶(𝒏 𝐥𝐨𝐠 𝒏)的时间里找到序列的逆序对数量。算法 的核心思想在于：统计两个子序列进行二路归时序列逆序对数量减少了多少。 求逆序对数量 10.5.2 归并排序 数据结构 考虑二路归并时，输入有序子序列𝑥, 𝑦的区间 分别为𝑙𝑥, 𝑟𝑥和𝑙𝑦, 𝑟𝑦。 由于在归并排序中待归并的子序列满足首尾相 连，规定𝑙𝑥 ≤ 𝑟𝑥 < 𝑙𝑦 ≤ 𝑟𝑦，就有𝑟𝑥 + 1 = 𝑙𝑦。 为了便于理解，可以将辅助序列𝑡看作拼接于 待排序子序列前，且每次将元素插入𝑡末尾的 操作看成将元素从原序列首移动至序列末尾， 如图所示。 初始序列 归并子序列𝑥的首元素 归并子序列𝑦的首元素 求逆序对数量 10.5.2 归并排序 数据结构 初始时，辅助序列𝑡中不包含任何元素。 若将𝑥的𝑎𝑙𝑥移至𝑡末尾，相当于序列t和子序列𝑥的分界符 𝑙𝑥右移，序列元素顺序没有发生改变。 若将𝑦的𝑎𝑙𝑦移至𝑡末尾，相当于将该元素使用插入排序插 至𝑙𝑥处，此时序列中元素间两两顺序关系发生改变的只 有𝒂𝒍𝒚和子序列𝒙剩余元素之间。 由于二路归并每次选择的元素是子序列剩余元素中最小 的，逆序对数量减少了𝑥目前剩余的元素数量。 最后，二路归并这两个子序列时，如果一个逆序对的两 个元素未被两个子序列完全包含，则二路归并后它们仍 然为逆序对。 因此，通过二路归并，将两个子序列合并为有序序列后， 求出了逆序对减少的数量，同时没有影响其它未被两个 子序列完全包含的逆序对数量。 算法时间复杂度和归并排序相同，为𝑶 𝒏 𝐥𝐨𝐠 𝒏 。 初始序列 归并子序列𝑥的首元素 归并子序列𝑦的首元素 二路归并求逆序对减量的伪代码 10.5.2 归并排序 数据结构 算法10-13 二路归并求逆序对减量 TwoWayInversionCount 𝑎, 𝑙, 𝑚, 𝑟 输入：序列𝑎，相邻两个有序子序列范围𝑙, 𝑚和𝑚 + 1, 𝑟 输出：将两个有序序列合并，并返回减少的逆序对数 量 1 𝑡 ←空序列 2 𝑖 ← 𝑙 3 𝑗 ← 𝑚 + 1 4 count← 0 5 𝐰𝐡𝐢𝐥𝐞 𝑖 ≤ 𝑚 or 𝑗 ≤ 𝑟 𝐝𝐨 6 | 𝐢𝐟 𝑗 > 𝑟 or 𝑖 ≤ 𝑚 and 𝑎𝑖 ≤ 𝑎𝑗 𝐭𝐡𝐞𝐧 7 | | 将𝑎𝑖添加至𝑡末尾 8 𝑖 ← 𝑖 + 1 9 | 𝐞𝐥𝐬𝐞 10 将𝑎𝑗添加至𝑡末尾 11 12 𝑗 ← 𝑗 + 1 𝑐𝑜𝑢𝑛𝑡 ← 𝑐𝑜𝑢𝑛𝑡 + 𝑚 − 𝑖 + 1 13 | 𝐞𝐧𝐝 14 𝐞𝐧𝐝 15 𝐫𝐞𝐭𝐮𝐫𝐧 count 归并排序兼求逆序对数量的伪代码 10.5.2 归并排序 数据结构 算法10-14 归并排序兼求逆序对数量 InversionCount 𝑎, 𝑙, 𝑟 输入：序列𝑎，左端点下标𝑙，右端点下标𝑟 输出：调整𝑎𝑙, 𝑎𝑙+1, … , 𝑎𝑟元素顺序，使元素按照非递减顺序排列，同时返回序列中逆序对数量 1 2 𝑐𝑜𝑢𝑛𝑡 ←0 𝐢𝐟 𝑙 < 𝑟 𝐭𝐡𝐞𝐧 //序列中至少有2个元素时才执行 3 | 𝑚 ← (𝑙 + 𝑟)/2 4 | 𝑐𝑜𝑢𝑛𝑡 ← 𝑐𝑜𝑢𝑛𝑡 + InversionCount(𝑎, 𝑙, 𝑚) 5 | 𝑐𝑜𝑢𝑛𝑡 ← 𝑐𝑜𝑢𝑛𝑡 + InversionCount(𝑎, 𝑚 + 1, 𝑟) 6 7 | 𝑐𝑜𝑢𝑛𝑡 ← 𝑐𝑜𝑢𝑛𝑡 + TwoWayInversionCount(𝑎, 𝑙, 𝑚 , 𝑟) end 8 𝐫𝐞𝐭𝐮𝐫𝐧 count 10.6 基于比较排序的复杂度分析 10.6 基于比较排序的复杂度分析 数据结构 核心问题：是否存在时间复杂度优于 𝑂(𝑛 log 𝑛) 的基于比较排序的算 法？ • 基于比较的排序的复杂度下界 • 基于比较多排序的平均复杂度 • 最少比较排序 10.6.1 基于比较的排序的复杂度下界 10.6.1 基于比较的排序的复杂度下界 数据结构 核心问题：每次操作可以询问两个元素 a𝑖 是否大于 a𝑗，对于任意的输 入数组，在最坏情况下，至少需要进行多少次操作才能确定输入数组 中所有元素的次序。 理论分析：对于每次询问操作，都可以将剩下可能的次序分成“满足 条件”和“不满足条件”两类，在最坏情况下，我们每次最多只能排 除一半的可能次序。对于 𝑛! 种可能次序，至少需要进行 𝑂 log 𝑛! 次操作。 10.6.1 基于比较的排序的复杂度下界 10.6.1 基于比较的排序的复杂度下界 数据结构 理论分析（二叉决策树）：（以四个元素为例）非叶节点 𝑖: 𝑗 表示比 较 𝑎𝑖 和 𝑎𝑗，如果小于则走向左子树，否则走向右子树。叶子结点包 含了所有的可能次序。 10.6.1 基于比较的排序的复杂度下界 10.6.1 基于比较的排序的复杂度下界 数据结构 理论分析（二叉决策树）：设所有非叶 节点的深度均小于 𝑑，则叶子结点的数 量最多为 2 𝑑（满二叉树时取到）。 𝑛! ≤ 2𝑑 ⇒ 𝑑 ≥ ⌈log(𝑛!)⌉ ∼ 𝑂(𝑛 log 𝑛) 10.6.3 最少比较排序 10.6.3 最少比较排序 数据结构 核心问题：我们通过理论分析得到了比较排序比较次数的下界，但是 否能找到满足下界的排序算法仍是未知之数。对于长度 𝑛 的序列，找 到一个在最坏情况下比较次数最少的排序算法。记理论下界为 𝐶 𝑛 ， 已知的最好比较排序的比较次数为 𝑆 𝑛 [1]。 𝐶 𝑛 𝑆 𝑛 𝐶 𝑛 𝑆 𝑛 𝐶 𝑛 𝑆 𝑛 𝑛 = 3 3 3 𝑛 = 8 16 16 𝑛 = 13 33 34 𝑛 = 4 5 5 𝑛 = 9 19 19 𝑛 = 14 37 38 𝑛 = 5 7 7 𝑛 = 10 22 22 𝑛 = 15 41 42 𝑛 = 6 10 10 𝑛 = 11 26 26 𝑛 = 16 45 46 𝑛 = 7 13 13 𝑛 = 12 29 30 𝑛 = 17 49 50 [1] Stober F, Weiß A. Lower Bounds for Sorting 16, 17, and 18 Elements[C]//2023 Proceedings of the Symposium on Algorithm Engineering and Experiments (ALENEX). Society for Industrial and Applied Mathematics, 2023: 201-213. 10.6.3 最少比较排序 10.6.3 最少比较排序 数据结构 示例（𝒏 = 𝟓）：7 次比较。先比较 𝑎1、𝑎2 和 𝑎3、𝑎4，再将两者的较 大者进行比较，得到如下图所示次序图，其中 𝑎 → 𝑏 表示 𝑎 < 𝑏。再 通过最多两次比较将 𝑎5 插入到 𝑎、𝑏、𝑑 中的适当位置。继续通过最 多两次比较将 𝑐 插入到 𝑎、𝑏、𝑑、𝑎5 中的适当位置。一共进行最多七 次比较完成排序。 思考：当 𝑛 = 6 时，如何设计一个最小比较排序算法[1]。 [1] Ford L R , Johnson S M .A Tournament Problem[J].American Mathematical Monthly, 1959, 66(5):387-389.DOI:10.2307/2308750. 10.7 基于分配的排序 10.7 基于分配的排序 数据结构 定义：不基于“比较-移动”的排序方式，常见的基于分配的排序有 • 计数排序（Counting Sort） • 桶排序（Bucket Sort） • 基数排序（Radix Sort） 10.7.1 计数排序 10.7.1 计数排序 数据结构 假设：假设 𝑛 个输入元素的每一个都是 0 到 𝑘 的一个整数。 核心思路：对于每一个输入元素 𝑥，确定小于 𝑥 的元素个数，这样就 可以将 𝑥 放在它在输出数组的位置上。当有多个 𝑥 相同时，我们统计 相同 𝑥 的数量，再依次存放即可。 示例：待排序数组 (2, 0, 2, 3, 4, 3, 2)。 初始状态 统计每个值出现的次数 10.7.1 计数排序 10.7.1 计数排序 数据结构 假设：假设 𝑛 个输入元素的每一个都是 0 到 𝑘 的一个整数。 核心思路：对于每一个输入元素 𝑥，确定小于 𝑥 的元素个数，这样就 可以将 𝑥 放在它在输出数组的位置上。当有多个 𝑥 相同时，我们统计 相同 𝑥 的数量，再依次存放即可。 示例：待排序数组 (2, 0, 2, 3, 4, 3, 2)。 统计 cnt 前缀和 从后向前依次将 A 的每个元素 x 放 入 B 中，具体位置由 cnt[x] 确定 10.7.1 计数排序 10.7.1 计数排序 数据结构 假设：假设 𝑛 个输入元素的每一个都是 0 到 𝑘 的一个整数。 核心思路：对于每一个输入元素 𝑥，确定小于 𝑥 的元素个数，这样就 可以将 𝑥 放在它在输出数组的位置上。当有多个 𝑥 相同时，我们统计 相同 𝑥 的数量，再依次存放即可。 示例：待排序数组 (2, 0, 2, 3, 4, 3, 2)。 插入 3 插入 4 10.7.1 计数排序 10.7.1 计数排序 数据结构 假设：假设 𝑛 个输入元素的每一个都是 0 到 𝑘 的一个整数。 核心思路：对于每一个输入元素 𝑥，确定小于 𝑥 的元素个数，这样就 可以将 𝑥 放在它在输出数组的位置上。当有多个 𝑥 相同时，我们统计 相同 𝑥 的数量，再依次存放即可。 示例：待排序数组 (2, 0, 2, 3, 4, 3, 2)。 插入 3 插入剩余的元素 计数排序伪代码 10.7.1 计数排序 数据结构 算法 10-15 计数排序 CountingSort 𝑎, 𝑙, 𝑟, 𝑘 输入：序列 𝑎，左端点下标 𝑙，右端点下标 𝑟，元素最大值 𝑘 输出：调整 𝑎𝑙, 𝑎𝑙+1, … , 𝑎𝑟 元素顺序，使元素按照非递减顺序排列 1. b ← new ElemSet [r-l+1] //临时存放有序序列的数组 2. cnt ← new int [k+1] () //计数数组，初始全零 3. for i←l to r do 4. | cnt[ai] ← cnt[ai] + 1 5. end 6. for i←1 to k do 7. | cnt[i] ← cnt[i-1] + cnt[i] 8. end 9. for i← r downto l do 10. | p ← cnt[ai]-1 //ai 应该在b中的位置 11. | bp ← ai //将ai放入 12. | cnt[ai] ← cnt[ai] - 1 13. end 14. for i←l to r do //将有序的b放回a中，b从0开始，a从l开始 15. | ai ← bi-l+1 16. end 计数排序性能分析 10.7.1 计数排序 数据结构 时间复杂度：在上述伪代码中，第 2-8 行统计小于等于每个元素的数 的数量，时间复杂度为 𝑂(𝑛 + 𝑘) ；第 9-13 行根据 cnt 将元素放至正 确位置，时间复杂度为 𝑂(𝑛) ；第 14-16 行将完成排序的元素放回原 序列，时间复杂度为 𝑂(𝑛) 。总体时间复杂度为 𝑂(𝑛 + 𝑘) 。当 𝑘 为 𝑛 的常数 𝑐 倍，即 𝑘 = 𝑐𝑛 时，计数排序的时间复杂度为 𝑂 𝑛 。 空间复杂度：排序过程中需要两个额外数组 b 和 cnt。故空间复杂度 为 𝑂(𝑛 + 𝑘)。 计数排序是稳定的。 “特殊的”计数排序——桶排序 10.7.1 计数排序 数据结构 桶排序： 1. 通过一个单调映射函数 𝑓 将 𝑛 个元素分配到 𝑘 个桶中 2. 然后对每个桶中的元素进行排序（一般使用插入排序） 3. 最后从这 𝑘 个桶中依次取出就得到有序的序列。 与计数排序的关系：计数排序可以看成映射函数为 𝑓 𝑥 = 𝑥，桶个数 为元素最大值的桶排序。此时，由于同一桶内的元素大小均相等，所 以不需要再对桶内元素排序，而改为计数即可。 桶排序性能分析 10.7.1 计数排序 数据结构 时间复杂度：桶排序的效率主要取决于两个因素：映射函数和桶的数 量。如果映射函数不能把元素较均匀地分配到各个桶，或者桶的数量 很少，就会存在大量桶内排序的代价。假设映射函数把元素均匀地分 配到 𝑘 个桶，此时桶排序的平均时间复杂度为 𝑂 𝑛 + 𝑛2 𝑘 + 𝑘 注意，复杂度和桶内排序方法有关！可以自由选择桶内排序方法。 空间复杂度：桶排序的空间复杂度为 𝑂(𝑛 + 𝑘)。 桶排序是稳定的。 10.7.2 基数排序 10.7.2 基数排序 数据结构 核心思路：将待排序元素转换成基于基数的元组表示，再对这些元组 进行排序。对于十进制整数，以 10 为基数，则每个数的元组表示为 由各个数位依次组成的列表，即 𝑎𝑖 = 𝑣𝑖 110 𝑑−1 + 𝑣𝑖 210𝑑−2 + ⋯ + 𝑣𝑖 𝑑100 = (𝑣𝑖 1, … , 𝑣𝑖 𝑑−1, 𝑣𝑖 𝑑 ) = 𝑣𝑖 其中 0 ≤ 𝑣𝑖 𝑗 ≤ 9。 𝑣𝑖 1 为元组关键字的最高位，𝑣𝑖 𝑑 为元组关键字的最 低位。使用计数排序来对元组的每一位进行排序。 基数排序分为两种： • 最高位优先基数排序 MSD(Most Significant Digit First) • 最低位优先基数排序 LSD(Least Significant Digit First) 基数排序中的计数排序伪代码 10.7.2 基数排序 数据结构 算法 10-16 基数排序中使用的计数排序CountingSort2(𝑎, 𝑙,𝑟,𝑟𝑎𝑑𝑖𝑥, 𝑘) 输入：序列 𝑎，左端点下标 𝑙，右端点下标 𝑟，基数 𝑟𝑎𝑑𝑖𝑥，计数位 𝑘 输出：调整 𝑎𝑙, 𝑎𝑙+1, … , 𝑎𝑟 元素顺序，使元素按照计数位 𝑘 非递减顺序排列，并返回统计小于每个基数元素个数的 𝑐𝑛𝑡 数组 1. b ← new ElemSet [r-l+1] //临时存放有序序列的数组 2. c ← new DigitSet [r-l+1] //存储元素第𝑘位的数组 3. cnt ← new int [radix] () //计数数组，初始全零 4. for i←l to r do 5. | ci ← GetDigit( ai, radix, k) //得到ai在基数radix下元组表 示的第k位 6. | cnt[ci] ← cnt[ci] + 1 7. end 8. for i←1 to radix-1 do 9. | cnt[i] ← cnt[i-1] + cnt[i] 10. end 11. for i← r downto l do 12. | p ← cnt[ci] //ai 应该在b中的位置 13. | bp ← ai //将ai放入 14. | cnt[ci] ← cnt[ci] - 1 15. end 16. for i←l to r do //将有序的b放回a中 17. | ai ← bi-l+1 18. end 19. return cnt 最高位优先基数排序 10.7.2 基数排序 数据结构 核心思路：首先按关键字最高位 𝑣𝑖 1 使用计数排序，可得到若干个最 高位值都相同的序列；接着对每个序列分别按关键字 𝑣𝑖 2 使用计数排 序，再将其分成若干个子序列，此时每个子序列的最高位和次高位的 值都相同。以此类推，第 𝑝 轮将对 𝑣𝑖 𝑝 使用计数排序，直到每个子序 列中都仅含一个元素，或者所有位都经过排序。 初始状态 以百位划分子序列 以十位划分子序列 以个位划分子序列 最高位优先基数排序伪代码 10.7.2 基数排序 数据结构 算法 10-17 MSD 基数排序 MSDRadixSort 𝑎, 𝑙, 𝑟, 𝑟𝑎𝑑𝑖𝑥, 𝑘, 𝑑 输入：序列 𝑎，左端点下标 𝑙，右端点下标 𝑟，基数 𝑟𝑎𝑑𝑖𝑥，计数位 𝑘，元组长度 𝑑 输出：调整 𝑎𝑙, 𝑎𝑙+1, … , 𝑎𝑟 元素顺序，使元素按照计数位 𝑘 非递减顺序排列 1 𝐢𝐟 𝑙 + 1 ≥ 𝑟 or 𝑘 > 𝑑 𝐭𝐡𝐞𝐧 //子序列长度不足1，或计数位超过元组长度 2 | 𝐫𝐞𝐭𝐮𝐫𝐧 3 𝐞𝐧𝐝 4 𝑐𝑛𝑡 ← CountingSort2 𝑎, 𝑙, 𝑟, 𝑟𝑎𝑑𝑖𝑥, 𝑘 5 𝐟𝐨𝐫 𝑖 ← 0 𝐭𝐨 𝑟𝑎𝑑𝑖𝑥 − 2 𝐝𝐨 6 | MSDRadixSort(𝑎, 𝑙 + 𝑐𝑛𝑡𝑖, 𝑙 + 𝑐𝑛𝑡𝑖+1 − 1, 𝑟𝑎𝑑𝑖𝑥, 𝑘 + 1, 𝑑) 7 𝐞𝐧𝐝 最低位优先基数排序 10.7.2 基数排序 数据结构 核心思路：首先按关键字最低位 𝑣𝑖 𝑑 的值的大小将元组序列分成若干个子 序列，再按 𝑣𝑖 𝑑 的值，从小到大依次将各个子序列收集起来，产生一个新 序列；再对新的元组序列按 𝑣𝑖 𝑑−1 的值的大小分成若干个子序列，再按 𝑣𝑖 𝑑−1 值从小到大依次将各个子序列收集起来，又产生了一个新的序列； 以此类推，再按 𝑣𝑖 𝑑−2, … , 𝑣𝑖 1 的值依次重复上述过程。 初始状态 按个位进行排序 按十位进行排序 按百位进行排序 最低位优先基数排序伪代码 10.7.2 基数排序 数据结构 算法 10-18 LSD 基数排序 LSDRadixSort 𝑎, 𝑙, 𝑟, 𝑟𝑎𝑑𝑖𝑥, 𝑑 输入：序列 𝑎，左端点下标 𝑙，右端点下标 𝑟，基数 𝑟𝑎𝑑𝑖𝑥，元组长度 𝑑 输出：调整 𝑎𝑙, 𝑎𝑙+1, … , 𝑎𝑟 元素顺序，使元素按照计数位 𝑘 非递减顺序排列 1 𝐟𝐨𝐫 𝑖 ← 𝑑 𝐝𝐨𝐰𝐧𝐭𝐨 1 𝐝𝐨 2 | CountingSort2 𝑎, 𝑙, 𝑟, 𝑟𝑎𝑑𝑖𝑥, 𝑖 3 𝐞𝐧𝐝 利用计数排序的稳定性，低位排好序后，高位排序不会改变低位的 相对次序 基数排序性能分析 10.7.2 基数排序 数据结构 时间复杂度：取决于算法CountingSort2的调用次数。LSD基数排序 调用了d次，因此时间复杂度为 𝑂 𝑑 𝑛 + 𝑟𝑎𝑑𝑖𝑥 。MSD基数排序调用 该函数次数和划分出的子序列数量直接相关，最坏情况下划分的子序 列个数远远多余d，其时间复杂度比LSD高。 空间复杂度：两种基数排序的空间复杂度均为 𝑂 𝑛 + 𝑟𝑎𝑑𝑖𝑥 。 10.8 索引排序 10.8 索引排序 数据结构 在之前提到的排序算法中，不论是基于比较的排序还是基于分配的排序，都需要 拷贝或移动序列中的元素。当元素移动和拷贝的代价很大时，需要尽可能减少元 素移动和拷贝的次数。 核心思路：创建一个索引序列𝒊𝒅𝒙，在排序时使用原序列元素进行比较，使用索引 序列进行元素交换。最后，算法会给出排序后的索引序列。 基于插入排序的索引排序的伪代码 10.8 索引排序 数据结构 算法10-19：基于插入排序的索引排序 IndexedInsertionSort 𝑎, 𝑙, 𝑟 输入：序列𝑎，左端点下标𝑙，右端点下标𝑟 输出：返回一个索引序列𝑖𝑑𝑥，𝑖𝑑𝑥𝑖 = 𝑝指𝑎𝑝是原序列中第𝑖大的元素 1. for i ← l+1 to r do 2. | t ← idxi 3. | for j←i-1 downto l do 4. | | if aidxj>at then 5. | | | idxj+1 ← idxj 6. | | else 7. | | | idxj+1 ← t 8. | | | break 9. | | end 10. | end 11. | if aidxl>at then 12. | | idxl ← t 13. | end 14. end 15. return idx 元素顺序调整 10.8 索引排序 数据结构 在得到排序的索引序列以后，需要基于索引序列调整原序列中元素顺序使其有序。 一种简单的方法是新建一个临时序列𝑡𝑚𝑝，令𝑡𝑚𝑝𝑖 = 𝑎𝑖𝑑𝑥𝑖，然后将𝑡𝑚𝑝拷贝回𝑎。 但是这种方法会使用较多的存储空间。实际上，按照下述方法，可以仅使用𝑶(𝟏) 的空间和 𝑶(𝒏) 的时间，在拥有排序的索引序列后调整原序列的元素顺序使其有序。 • 检查第𝑖个位置的元素位置是否正确 • 如果位置不正确，将𝑎𝑖暂存，并将应放的元素𝒂𝒊𝒅𝒙𝒊移至该位置，并记该元素当 前所在位置𝒊𝒅𝒙𝒊为𝒋。 • 继续检查位置𝑗是否正确，重复上述操作直到应放元素为𝒂𝒊为止。 • 此时所有在循环中访问到的元素已归位，继续检查第𝒊 + 𝟏个位置的元素位置是 否正确，直到所有元素归位。 元素顺序调整的伪代码 10.8 索引排序 数据结构 算法10-19：基于插入排序的索引排序 IndexedInsertionSort 𝑎, 𝑙, 𝑟 输入：序列𝑎，左端点下标𝑙，右端点下标𝑟 输出：返回一个索引序列𝑖𝑑𝑥，𝑖𝑑𝑥𝑖 = 𝑝指𝑎𝑝是原序列中第𝑖大的元素 1. for i ← l+1 to r do 2. | t ← idxi 3. | for j←i-1 downto l do 4. | | if aidxj>at then 5. | | | idxj+1 ← idxj 6. | | else 7. | | | idxj+1 ← t 8. | | | break 9. | | end 10. | end 11. | if aidxl>at then 12. | | idxl ← t 13. | end 14. end 15. return idx 10.9 拓展延伸 10.9 拓展延伸 数据结构 前面几节介绍了经典排序算法的原理和特点。本节从库函数实现的角度，介绍两 个拓展算法： • 内省排序：C++语言中最常用的排序函数实现时采用的排序算法，它是快速排 序的一种拓展，是以快速排序为主干，混合堆排序和插入排序的一种混合排序 算法； • 蒂姆排序：Java和Python语言中最常用的排序函数实现时采用的排序算法，它 是归并排序的一种拓展，主要思想是对序列中的有序（顺序或逆序）子序列进 行利用以提高效率，同时混合了插入排序作为优化。 10.9.1 内省排序 10.9.1 内省排序 数据结构 在所有基于比较的排序中，快速排序是平均运行速度最快的排序方法。然而，快 速排序有其劣势，在某些情况下其表现不如其他排序算法。最坏时间复杂度会退 化至𝑶 𝒏 𝟐 ，这在一些情况下是不可接受的。例如在网络服务中，攻击者可以构 造特殊的序列，使服务器需要花费普通序列更多的时间用于排序，从而使攻击者 容易对服务器进行拒绝服务（DoS）攻击。为了提升排序算法的效率和稳定性， 在快速排序的基础上，David Musser在1997年提出了内省排序算法。 内省排序算法是一种混合排序算法，按照如下步骤避免快速排序退化，提升快速 排序的效率： • 算法算法会首先尝试使用快速排序对序列进行排序。 • 当递归层数超过预先设定的深度阈值𝐷后转为堆排序。 • 如果剩余元素个数少于阈值kThrLen，则会采用插入排序。 在目前的主流实现中，𝐷取1.5 log 𝑛 ~2 log 𝑛，kThrLen取6~32之间。 内省排序的伪代码 10.9.1 内省排序 数据结构 算法10-21：索引排序 IntroSort 𝑎, 𝑙, 𝑟 输入：序列𝑎，左端点下标𝑙，右端点下标𝑟，深度阈值d 输出：调整𝑎𝑙, 𝑎𝑙+1, … , 𝑎𝑟元素顺序，使元素按照非递减顺序排列 1 m← kThrLen //设定短子序列的阈值 2 𝐢𝐟 𝑟 − 𝑙 < 𝑚 𝐭𝐡𝐞𝐧 3 | InsertSort 𝑎, 𝑙, 𝑟 4 𝐞𝐥𝐬𝐞 𝐢𝐟 𝑑 = 0 𝐭𝐡𝐞𝐧 5 | HeapSort 𝑎, 𝑙, 𝑟 6 7 𝐞𝐥𝐬𝐞 | 𝑖 ← Partition(𝑎, 𝑙, 𝑟) 8 | IntroSort(𝑎, 𝑙, 𝑖 − 1, 𝑑 − 1) 9 10 | IntroSort(𝑎, 𝑖 + 1, 𝑟，𝑑 − 1) 𝐞𝐧𝐝 10.9.2 蒂姆排序 10.9.2 蒂姆排序 数据结构 蒂姆排序：蒂姆排序是一种混合、稳定的自适应排序算法，其结合了 归并排序和插入排序的思想，旨在对真实情况下的数据有更好的排序 效率。 蒂姆排序由 Tim Peters 在 2002 年提出，并自 Python2.3 版本以来， 一直作为其标准排序算法，并且在 Java SE 7、Swift 和 Rust 等语言 中，使用它对非原始类型的数组进行排序。蒂姆排序的基本思想是： 先找到输入数据中的有序连续子序列（run），然后通过某种方式归 并这些子序列，以得到有序的数组。 蒂姆排序算法步骤 10.9.2 蒂姆排序 数据结构 1. 根据输入数组长度确定最小有序子序列长度 minRun。 2. 划分成长度不小于 minRun 的非递减或严格递减的连续子序列， 即 run。不足 minRun 的使用插入排序补足。如果得到的 run 为 严格递减的子序列，则将其进行翻转反序（即首尾两两交换）。 3. 对 run 进行合并。用栈来依次存储 run，要求栈中任意三个连续的 run，𝑆𝑥、𝑆𝑥+1、𝑆𝑥+2 的长度满足限制 ① 𝑆𝑥+2 > 𝑆𝑥+1 + 𝑆𝑥 ② 𝑆𝑥+1 > |𝑆𝑥| 4. 从上到下依次归并所有的 run。 蒂姆排序执行过程示例 10.9.2 蒂姆排序 数据结构 初始数组和初始栈 插入排序生成第一个 run run0=(1, 9, 10) 插入排序生成第二个 run 蒂姆排序执行过程示例 10.9.2 蒂姆排序 数据结构 原地翻转得到 run1=(2, 2, 8) 插入排序生成第三个 run run2=(4, 5, 6) 归并 run2 和 run1 蒂姆排序执行过程示例 10.9.2 蒂姆排序 数据结构 归并 run2 和 run0 run3=(11, 12, 13, 14) run4=(7) 由栈顶到栈底依次归并每个 run 蒂姆排序伪代码 10.9.2 蒂姆排序 数据结构 算法 10-22 蒂姆排序 TimSort(𝑎, 𝑙, 𝑟) 输入：序列 𝑎，左端点下标 𝑙，右端点下标 𝑟 输出：调整 𝑎𝑙, 𝑎𝑙+1, … , 𝑎𝑟 元素顺序，使元素按照非递减顺序排列 1 𝑟𝑢𝑛1, … , 𝑟𝑢𝑛𝑘 ←待排序数组𝑎的连续子序列分解 2 InitStack(𝑆)//将栈内run按栈顶到栈底的顺序从𝑆1开始编号 3 𝐟𝐨𝐫 𝑖 ← 1 𝐭𝐨 𝑘 𝐝𝐨 4 | Push(S, runi) //将𝑟𝑢𝑛𝑖加入栈𝑆顶部 5 | 𝐰𝐡𝐢𝐥𝐞 𝐭𝐫𝐮𝐞 𝐝𝐨 6 | | 𝐢𝐟 𝑆 ≥ 3 且 𝑆1 > 𝑆3 𝐭𝐡𝐞𝐧 //不满足限制 7 | | | Merge(𝑆2, 𝑆3) 8 | | 𝐞𝐥𝐬𝐞 𝐢𝐟 𝑆 ≥ 2 且 𝑆1 ≥ 𝑆2 𝐭𝐡𝐞𝐧 //不满足限制 9 | | | Merge(𝑆1, 𝑆2) 10 𝐞𝐥𝐬𝐞 𝐢𝐟 𝑆 ≥ 3 且 𝑆1 + 𝑆2 ≥ 𝑆3 𝐭𝐡𝐞𝐧 //不满足限制 11 | | | Merge(𝑆1, 𝑆2) 12 | | 𝐞𝐥𝐬𝐞 𝐢𝐟 𝑆 ≥ 4 且 𝑆2 + 𝑆3 ≥ 𝑆4 𝐭𝐡𝐞𝐧 //不满足限制 13 | | | Merge(𝑆1, 𝑆2) 14 | | else 15 | | | 𝐛𝐫𝐞𝐚𝐤 16 | | 𝐞𝐧𝐝 17 | 𝐞𝐧𝐝 18 𝐞𝐧𝐝 19 𝐰𝐡𝐢𝐥𝐞 𝑆 > 1 𝐝𝐨 20 | Merge(𝑆1, 𝑆2) 21 𝐞𝐧𝐝 22 𝐟𝐨𝐫 𝑖 ← 𝑙 𝐭𝐨 𝑟 𝐝𝐨 23 | 𝑎𝑖 ← 𝑠1,𝑖−𝑙+1 24 𝐞𝐧𝐝 蒂姆排序性能分析 10.9.2 蒂姆排序 数据结构 时间复杂度：将数组分解成 run 可以在线性时间内完成。上述伪代码 的主循环中最多需要 𝑂 𝑛 𝑆 𝑚𝑎𝑥 次比较，其中 𝑆 𝑚𝑎𝑥 为栈的最大高 度，且满足 𝑆 𝑚𝑎𝑥 ≤ log 𝑛。最后的归并使用了启发式的从小长度到大 长度的归并，时间复杂度为 𝑂 𝑛 log 𝑛 ，故总体的时间复杂度为 𝑂 𝑛 log 𝑛 。 空间复杂度：算法的空间复杂度为 𝑂 𝑛 。 10.10 应用场景：考试录取中的成绩排序 10.10 应用场景：考试录取中的成绩排序 数据结构 在考试录取工作中，考试和录取按省份分别开展，各省考试人数从几万到一百多 万不等，这样规模的录取工作需要计算机来处理，其中最核心的步骤就是将考生 按考分进行排序，排序的效率会直接决定录取工作的处理时长。 在高考这个实际的例子中，由于考生众多，很容易出现总分同分的现象。为了决 定在总分同分时的录取顺序，还需要制定更详细的比较规则。以浙江省为例，在 录取时会依次按文化总分、语文数学总分、语文或数学单科成绩、外语成绩、选 考科目单科成绩由高到低，以及志愿号由小到大决定录取顺序。 从排序的角度来讲，文化总分是排序的主关键字（第一关键字），语文数学总分 是次关键字（第二关键字），语文单科成绩是第三关键字，依次类推。这些比较 项目全部相同的考生为同位次，当然出现这种情况的可能性就非常小了。 10.11 小结 10.11 小结 数据结构 本章我们介绍了若干经典的排序方法，包括：插入排序、冒泡排序、选择排序、 归并排序、快速排序、堆排序、希尔排序、计数排序、基数排序、桶排序，还扩 展介绍了C++、Java和Python的库函数中实现的内省排序和蒂姆排序。 排序方法 平均时间复杂度 最坏时间复杂度 最坏辅助空间复杂度 稳定性 插入排序 𝑂(𝑛2) 𝑂(𝑛2) 𝑂(1) 稳定 冒泡排序 𝑂(𝑛2) 𝑂(𝑛2) 𝑂(1) 稳定 选择排序 𝑂(𝑛2) 𝑂(𝑛2) 𝑂(1) 不稳定 归并排序 𝑂(𝑛𝑙𝑜𝑔𝑛) 𝑂(𝑛𝑙𝑜𝑔𝑛) 𝑂(𝑛) 稳定 快速排序 𝑂(𝑛𝑙𝑜𝑔𝑛) 𝑂(𝑛2) 𝑂(𝑛) 不稳定 堆排序 𝑂(𝑛𝑙𝑜𝑔𝑛) 𝑂(𝑛𝑙𝑜𝑔𝑛) 𝑂(1) 不稳定 计数排序 𝑂(𝑛 + 𝑘) 𝑂(𝑛 + 𝑘) 𝑂(𝑛 + 𝑘) 稳定 基数排序（LSD） 𝑂 𝑑 𝑛 + 𝑟𝑎𝑑𝑖𝑥 𝑂 𝑑 𝑛 + 𝑟𝑎𝑑𝑖𝑥 𝑂 𝑛 + 𝑟𝑎𝑑𝑖𝑥 稳定 桶排序 𝑂(𝑛 + 𝑘 + 𝑛2 𝑘 ) 𝑂 𝑛2 + 𝑘 𝑂(𝑛 + 𝑘) 稳定 内省排序 𝑂(𝑛𝑙𝑜𝑔𝑛) 𝑂(𝑛𝑙𝑜𝑔𝑛) 𝑂(𝑙𝑜𝑔𝑛) 不稳定 蒂姆排序 𝑂(𝑛𝑙𝑜𝑔𝑛) 𝑂(𝑛𝑙𝑜𝑔𝑛) 𝑂(𝑛) 稳定","libVersion":"0.5.0","langs":""}