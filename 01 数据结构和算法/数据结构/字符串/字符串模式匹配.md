# KMP 字符串匹配算法

## 基础实现代码

```cpp
#include<bits/stdc++.h>
using namespace std;

// 构建 next 数组
void getNext(int next[], string P) {
    int i = 0, j = -1;
    next[0] = -1;
    while(i < P.length()) {
        if(j == -1 || P[i] == P[j]) {
            i++;
            j++;
            next[i] = j;
        } else {
            //回溯
            j = next[j];
        }
    }
}

int KMP(string T, string P) {
    int *next = new int[P.length() + 1];
    getNext(next, P);

    int i = 0;
    int j = 0;

    while(i < T.length() && j < P.length()) {
        if(j == -1 || T[i] == P[j]) {
            i++;
            j++;
        } else {
            j = next[j];
        }
    }
    delete[] next;

    if(j == P.length()) {
        cout << "i:" << i << endl;
        cout << "j:" << j << endl;
        return i - P.length();
    }
    return -1;
}

int main() {
    string A = "ABCABCAC";
    string B = "ABCAC";
    cout << KMP(A, B) << endl;
    return 0;
}
```

## 算法基本介绍

- KMP 是一个解决模式串在文本串是否出现过，如果出现过，最早出现的位置的经典算法。
- Knuth-Morris-Pratt 字符串查找算法，简称为 "KMP 算法"，常用于在一个文本串 S 内查找一个模式串 P 的出现位置。这个算法由 `Donald Knuth`、`Vaughan Pratt`、`James H. Morris` 三人于 1977 年联合发表，故取这 3 人的姓氏命名此算法。
- KMP 方法算法就利用之前判断过的信息，通过一个 next 数组，保存模式串中前后最长公共子序列的长度，每次回溯时，通过 next 数组找到，前面匹配过的位置，省去了大量的计算时间。

## 字符串的最长公共前后缀 & 部分匹配表

### 什么是最长公共前后缀

1. **前缀**：字符串的前缀是指不包含最后一个字符的所有以第一个字符（索引为 0）开头的连续子串

   比如字符串 "ABABA" 的前缀有：A，AB，ABA，ABAB

2. **后缀**：字符串的后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串

   比如字符串 "ABABA" 的后缀有：BABA，ABA，BA，A

3. **公共前后缀**：一个字符串的 所有前缀连续子串 和 所有后缀连续子串 中相等的子串

   比如字符串 "ABABA"：
   - 前缀有：A，AB，ABA，ABAB
   - 后缀有：BABA，ABA，BA，A
   
   因此公共前后缀有：A，ABA

4. **最长公共前后缀**：所有公共前后缀中长度最长的那个子串

   比如字符串 "ABABA"，公共前后缀有：A，ABA
   
   由于 `ABA` 是三个字符长度，`A` 是一个字符长度，那么最长公共前后缀就是 ABA

📝 再比如说一个字符串 str = "ABCABD"

- 对于 str 从 `索引为0` 开始的子串 "A" 而言：
    
    1. 前缀：不包含`最后一个字符A`的 所有以`第一个字符A`开头 的 连续子串 不存在
    2. 后缀：不包含`第一个字符A` 的 所有以`最后一个字符A`结尾 的 连续子串 不存在
    
    因此该子串的最长公共前后缀 为 0
    
- 对于 str 从 索引为 0 开始的子串 "AB" 而言：
    
    1. 前缀：不包含 `最后一个字符B` 的 所有以`第一个字符A`开头 的 连续子串 有 —— "A"
    2. 后缀：不包含 `第一个字符A` 的 所有以`最后一个字符B`结尾 的 连续子串 有 —— "B"
    
    因此该子串的最长公共前后缀 为 0
    
- 对于 str 从 索引为 0 开始的子串 "ABC" 而言：
    
    1. 前缀：不包含 `最后一个字符C` 的 所有以`第一个字符A`开头 的 连续子串 有 —— "A"，"AB"
    2. 后缀：不包含 `第一个字符A` 的 所有以`最后一个字符C` 结尾 的 连续子串有 —— "BC"，"C"
    
    前缀与后缀的连续子串不存在相同的，因此该子串的最长公共前后缀 为 0
    
- 对于 str 从 索引为 0 开始的子串 "ABCA" 而言：
    
    1. 前缀：不包含 `最后一个字符A` 的 所有以`第一个字符A`开头 的 连续子串 有 —— "A"，"AB"，"ABC"
    2. 后缀：不包含 `第一个字符A` 的 所有以`最后一个字符A` 结尾 的 连续子串有 —— "BCA"，"CA"，"A"
    
    前缀与后缀的连续子串中存在相同且最长的子串 A，因此该子串的最长公共前后缀 为 1
    
- 对于 str 从 索引为 0 开始的子串 "ABCAB" 而言：
    
    1. 前缀：不包含 `最后一个字符B` 的 所有以`第一个字符A`开头 的 连续子串 有 —— "A"，"AB"，"ABC"，"ABCA"
    2. 后缀：不包含 `第一个字符A` 的 所有以`最后一个字符B` 结尾 的 连续子串有 —— "BCAB"，"CAB"，"AB"，"B"
    
    前缀与后缀的连续子串中存在相同且最长的子串 AB，因此该子串的最长公共前后缀 为 2
    
- 对于 str 从 索引为 0 开始的子串 "ABCABD" 而言：
    
    1. 前缀：不包含 `最后一个字符D` 的 所有以`第一个字符A`开头 的 连续子串 有 —— "A"，"AB"，"ABC"，"ABCA"，"ABCAB"
    2. 后缀：不包含 `第一个字符A` 的 所有以`最后一个字符D` 结尾 的 连续子串有 —— "BCABD"，"CABD"，"ABD"，"BD"，"D"
    
    前缀与后缀的连续子串不存在相同的，因此该子串的最长公共前后缀 为 0

### 什么是部分匹配表 Next

个人理解：对于字符串 str，从 第一个字符开始的每个子串 的 最后一个字符 与 该子串的最长公共前后缀的长度 的对应关系表格。这个表我们以 `int[] next` 数组方式进行存储。

比如说上面举的例子：

- 子串 "A"：最后一个字符是 A，该子串的最长公共前后缀长度是 0，因此对应关系就是 A - 0
- 子串 "AB"：最后一个字符是 B，该子串的最长公共前后缀长度是 0，因此对应关系就是 B - 0
- 子串 "ABC"：最后一个字符是 C，该子串的最长公共前后缀长度是 0，因此对应关系就是 C - 0
- 子串 "ABCA"：最后一个字符是 A，该子串的最长公共前后缀长度是 1，因此对应关系就是 A - 1
- 子串 "ABCAB"：最后一个字符是 B，该子串的最长公共前后缀长度是 2，因此对应关系就是 B - 2
- 子串 "ABCABD"：最后一个字符是 D，该子串的最长公共前后缀长度是 0，因此对应关系就是 D - 0

因此综上，我们说该字符串 str 的部分匹配表为：

|A|B|C|A|B|D|
|:-:|:-:|:-:|:-:|:-:|:-:|
|0|0|0|1|2|0|

那么对应的 [next 数组](https://so.csdn.net/so/search?q=next%E6%95%B0%E7%BB%84&spm=1001.2101.3001.7020)就是 int[] next = {0, 0, 0, 1, 2, 0}

### 字符串最长公共前后缀 & 部分匹配表的代码实现

![](https://i-blog.csdnimg.cn/blog_migrate/beed5704e029cb3a7bb753015158f8a9.png)

下面的代码可以参考图中实例进行分析：

```cpp
#include <bits/stdc++.h>
using namespace std;
vector<int> getNext(const string &pattern) {
    // 创建next数组，用于存储部分匹配表的每个子串的最长公共前后缀
    vector<int> next(pattern.length());

    // 从第一个字符开始的子串，长度为1时最长公共前后缀为0
    // 因为这唯一的字符既是第一个字符，又是最后一个字符，所以前后缀都不存在
    next[0] = 0;

    // len有两个作用：
    // 1. 记录当前子串的最长公共前后缀长度
    // 2. 表示当前子串最长公共前缀字符串的下一个字符的索引
    int len = 0;

    // 从第二个字符开始遍历，求索引在 [0,i] 的子串的最长公共前后缀长度
    int i = 1;
    while (i < pattern.length()) {
        // 比较前缀的下一个字符和当前字符是否相等
        if (pattern[len] == pattern[i]) {
            // 如果相等，最长公共前后缀长度加1
            len++;
            next[i] = len;
            i++;
        } else {
            // 如果不相等
            if (len == 0) {
                // len为0说明已经没有公共前后缀可以参考
                // 当前位置的最长公共前后缀长度为0
                next[i] = 0;
                i++;
            } else {
                // 回退到前一个最长公共前后缀
                // 这里是KMP算法的关键：通过已经计算好的next数组，
                // 快速找到下一个可能的匹配位置
                len = next[len - 1];
            }
        }
    }

    return next;
}

// 测试函数
void testKMP() {
    string pattern = "ABABCABAA";
    vector<int> next = getNext(pattern);

    cout << "模式串: " << pattern << endl;
    cout << "Next数组: ";
    for (int i : next) {
        cout << i << " ";
    }
    cout << endl;
}

int main() {
    testKMP();
    return 0;
}
```

### 代码测试
```java
package kmp;

import java.util.Arrays;

/**
 * @author 狐狸半面添
 * @create 2022-11-22 22:43
 */
public class KMPAlgorithm {
    public static void main(String[] args) {
        String patternStr = "ABCDABD";
		//输出结果：[0, 0, 0, 0, 1, 2, 0]
        System.out.println(Arrays.toString(kmpNext(str2)));
    }

    /**
     * 获取一个字符串 pattern 的部分匹配表
     *
     * @param patternStr 用于模式匹配字符串
     * @return 存储部分匹配表的每个子串的最长公共前后缀的 next数组
     */
    public static int[] kmpNext(String patternStr) {
        //将 patternStr 转为 字符数组形式
        char[] patternArr = patternStr.toCharArray();

        //预先创建一个next数组，用于存储部分匹配表的每个子串的最长公共前后缀
        int[] next = new int[patternStr.length()];

        /*
            从第一个字符（对应索引为0）开始的子串，如果子串的长度为1，那么肯定最长公共前后缀为0
            因为这唯一的一个字符既是第一个字符，又是最后一个字符，所以前后缀都不存在 -> 最长公共前后缀为0
         */
        next[0] = 0;

        /*
          len有两个作用：
            1. 用于记录当前子串的最长公共前后缀长度
            2. 同时知道当前子串的最长公共前后缀的前缀字符串对应索引 [0,len-1]/当前子串最长公共前缀字符串的下一个字符的索引  <-- 可以拿示例分析一下
         */
        int len = 0;

        //从第二个字符开始遍历，求索引在 [0,i] 的子串的最长公共前后缀长度
        int i = 1;
        while (i < patternArr.length) {
            /*
                1.已经知道了上一个子串 对应索引[0,i-1] 的最长公共前后缀长度为 len
                  的前缀字符串是 索引[0,len-1]，对应相等的后缀字符串是 索引[i-len,i-1]

                2.因此我们可以以 上一个子串的最长公共前后缀字符串 作为拼接参考
                  比较一下 patternArr[len] 与 patternArr[i] 是否相等
             */
            if (patternArr[len] == patternArr[i]) {
                /*
                    1.如果相等即 patternArr[len]==patternArr[i]，
                      那么就可以确定当前子串的最长公共前后缀的
                      前缀字符串是 索引[0,len] ，对应相等的后缀字符串是 索引[i-len,i]

                    2.由于是拼接操作，那么当前子串的最长公共前后缀长度只需要在上一个子串的最长公共前后缀长度的基础上 +1 即可
                      即 next[i] = next[i-1] + 1 ，

                    3.由于 len 是记录的子串的最长公共前后缀长度，对于当前我们所在的代码位置而言
                      len 还是记录的上一个子串的最长公共前后缀长度，因此：
                      next[i] = next[i-1] + 1 等价于 next[i] = ++len
                 */

                // 等价于 next[i] = next[i-1] + 1
                next[i] = ++len;
                //既然找到了索引在[0,i]的子串的最长公共前后缀字符串长度，那就 i+1 去判断以下一个字符结尾的子串的最长公共前后缀长度
                i++;
            }else {
                /*
                    1.如果不相等 patternArr[len]!=patternArr[i]
                      我们想要求当前子串 对应索引[0,i] 的最长公共前后缀长度
                      我们就不能以 上一个子串的最长公共前后缀：前缀字符串pre  后缀字符串post （毫无疑问pre==post） 作为拼接参考

                    2.但可以思考一下：
                      pre的最长公共前缀字符串： 索引 [      0        , next[len-1] )
                      是等于
                      post的最长公共后缀字符串：索引 [ i-next[len-1] ,     i       )

                      则我们 就以 pre的最长公共前缀字符串/post的最长公共后缀字符串 作为拼接参考
                      去判断 pre的最长公共前缀字符串的下一个字符patternArr[next[len-1]] 是否等于 post的最长公共后缀字符串的下一个字符patternArr[i]

                    3.在第 1,2 步分析的基础上
                      我们可以在判断出 patternArr[len]!=patternArr[i] 后，
                      不去执行第二步：patternArr[next[len-1]] 是否等于 patternArr[i]，
                      可以先修改len的值：len = next[len-1]，len就成了 pre的最长公共前缀字符串长度/post的最长公共后缀字符串长度，
                      修改完之后，再去判断下一个字符 是否相等，即 判断 patternArr[len] 是否等于 patternArr[i]
                      仔细观察，这不又是在判断 这个循环中 if-else 语句吗

                    4.关于 len 这个值，在循环开始时我们解释的是：上一个子串的最长公共前后缀字符串的长度
                      但实际上我们在这里改为 len = next[len-1] 表示上一个子串的最长公共前后缀字符串的最长公共前后缀字符串的长度
                      是没有问题的，等价于上一个子串的较小的公共前后缀字符串。
                      既然进入了 else 语句说明字符不相等，就不能以 上一个子串的最长公共前后缀字符串 作为 拼接参考，就应当去缩小参考范围。
                 */
                if(len==0) {

                    /*
                        len为0说明上一个子串已经没有了公共前后缀字符串
                        则我们没有继续寻找的必要 --> 索引在[0, i]的当前子串的最长公共前后缀字符串长度就是0
                     */
                    next[i] = len;

                    //继续寻找下一个字符串的最长公共前后缀字符串长度
                    i++;

                }else{
                    len = next[len - 1];
                }

            }
        }

        return next;
    }
}
```

## 根据部分匹配表搜索字符串匹配位置

### 匹配成功一个就退出匹配的代码

#### KMP 算法的大致步骤

1. 求出`模式字符串patternStr`的部分匹配表，已知待匹配的字符串 `matchStr`
    
2. 定义两个指针 `i` 和 `j`，分别指向 patternStr 和 matchStr ，初始化为 0
    
3. 判断 patternStr[i] 和 matchStr[j] 是否相等
    
    - 如果相等，则继续向后匹配：i++, j++
        
    - 如果不相等，则 i 不变，调整 j 为 模式字符串 pattern  的 上一个子串（索引 [0, j-1]）的最长公共`前缀`字符串的下一个索引位置，该索引位置也是[最长公共前缀](https://so.csdn.net/so/search?q=%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80&spm=1001.2101.3001.7020) / 后缀字符串的长度：j = next[j - 1]
        
        解释一下不相等为什么要这样做：
        
        1️⃣ 在不相等的时候，我们可以知道前面已经匹配的字符串 `str1` 和 `str2` 肯定是完全相等的
        
        - str1：在 matchStr 中对应索引 [i - j , i - 1]
        - str2：在 patternStr 中对应索引 [0 , j - 1]
        
        2️⃣ 由于 完全相等，则 str1 的 最长公共后缀字符串 一定等于 str2 的 最长公共前缀字符串，那么：
        
        - 将 i 定位到 str1 的 最长公共后缀字符串 的 下一个字符位置，但很明显，i 此时的位置肯定已经是在 str1 的最长公共后缀字符串的下一个字符的位置，因此 i 的值不需要做调整
        - 将 j 定位到 str2 的 最长公共前缀字符串 的 下一个字符位置 ，next [j - 1] 不仅代表 上一个子串 str1 的最长公共前后缀字符串长度，也是最长公共前缀字符串的下一个字符的索引。因此，我们只需要：j = next[j - 1]
        
        3️⃣ 修改完毕，我们此时已经匹配的字符串：
        
        - 在 matchStr 中 对应索引 [i - j , i - 1]
        - 在 patternStr 中 对应索引 [0 , j - 1]
        
        4️⃣ 那么我们再继续比较已经匹配的字符串后面的字符就可以了，即 判断 patternStr[i] 和 matchStr[j] 是否相等，这又回到了 步骤三！！！
        
        ![](https://i-blog.csdnimg.cn/blog_migrate/5d834ed9d2767753911a010f224b7c26.png#pic_center)
        
4. 判断 i 和 j 是否超出 各自的最大索引值
    
    - 如果都没到超出 各自最大索引值，就继续执行第三步进行比较（说明是个循环）
    - 如果至少有一个超出了 各自最大索引值，就退出循环
5. 循环结束后，判断 j 是否超出了 模式字符串的最大索引值
    
    - 如果超出了，说明匹配成功，返回 patternStr 字符串匹配到的 matchStr 的第一个字符串的起始索引位置：i - j
    - 如果没有超出，说明匹配失败，返回 -1 表示没有匹配到

#### 代码实现 + 测试

```java
package kmp;

import java.util.Arrays;

/**
 * @author 狐狸半面添
 * @create 2022-11-22 22:43
 */
public class KMPAlgorithm {
    public static void main(String[] args) {
        String matchStr = "AABABADDABAC";
        String patternStr = "ABA";

        // 输出：index = 1
        System.out.println("index = " + kmpSearch(matchStr, patternStr, kmpNext(patternStr)));

    }

    /**
     * kmp搜索算法
     *
     * @param matchStr   原字符串
     * @param patternStr 子串
     * @param next       子串对应的部分匹配表
     * @return 如果是-1，就是没有匹配到，否则就返回第一个匹配的位置
     */
    public static int kmpSearch(String matchStr, String patternStr, int[] next) {

        int i = 0, j = 0;

        while (i < matchStr.length() && j < patternStr.length()) {

            if (matchStr.charAt(i) == patternStr.charAt(j)) {
                //相等就继续进行匹配
                i++;
                j++;

            } else {
                //如果 patternStr[i] 和 matchStr[j] 不相等

                if (j == 0) {
                    /*
                        表示 matchStr 没有匹配到 patternStr的第一个字符
                        那直接将 matchStr 的指针 i 向后移动一位即可
                     */
                    i++;
                } else {
                    j = next[j - 1];
                }
            }

        }
        return j == patternStr.length() ? i - j : -1;
    }

    /**
     * 获取一个字符串 pattern 的部分匹配表
     *
     * @param patternStr 用于模式匹配字符串
     * @return 存储部分匹配表的每个子串的最长公共前后缀的 next数组
     */
    public static int[] kmpNext(String patternStr) {
        //将 patternStr 转为 字符数组形式
        char[] patternArr = patternStr.toCharArray();

        //预先创建一个next数组，用于存储部分匹配表的每个子串的最长公共前后缀
        int[] next = new int[patternStr.length()];

        /*
            从第一个字符（对应索引为0）开始的子串，如果子串的长度为1，那么肯定最长公共前后缀为0
            因为这唯一的一个字符既是第一个字符，又是最后一个字符，所以前后缀都不存在 -> 最长公共前后缀为0
         */
        next[0] = 0;

        /*
          len有两个作用：
            1. 用于记录当前子串的最长公共前后缀长度
            2. 同时知道当前子串的最长公共前后缀的前缀字符串对应索引 [0,len-1]  <-- 可以拿示例分析一下
         */
        int len = 0;

        //从第二个字符开始遍历，求索引在 [0,i] 的子串的最长公共前后缀长度
        int i = 1;
        while (i < patternArr.length) {
            /*
                1.已经知道了上一个子串 对应索引[0,i-1] 的最长公共前后缀长度为 len
                  的前缀字符串是 索引[0,len-1]，对应相等的后缀字符串是 索引[i-len,i-1]

                2.因此我们可以以 上一个子串的最长公共前后缀字符串 作为拼接参考
                  比较一下 patternArr[len] 与 patternArr[i] 是否相等
             */
            if (patternArr[len] == patternArr[i]) {
                /*
                    1.如果相等即 patternArr[len]==patternArr[i]，
                      那么就可以确定当前子串的最长公共前后缀的
                      前缀字符串是 索引[0,len] ，对应相等的后缀字符串是 索引[i-len,i]

                    2.由于是拼接操作，那么当前子串的最长公共前后缀长度只需要在上一个子串的最长公共前后缀长度的基础上 +1 即可
                      即 next[i] = next[i-1] + 1 ，

                    3.由于 len 是记录的子串的最长公共前后缀长度，对于当前我们所在的代码位置而言
                      len 还是记录的上一个子串的最长公共前后缀长度，因此：
                      next[i] = next[i-1] + 1 等价于 next[i] = ++len
                 */

                // 等价于 next[i] = next[i-1] + 1
                next[i] = ++len;
                //既然找到了索引在[0,i]的子串的最长公共前后缀字符串长度，那就 i+1 去判断以下一个字符结尾的子串的最长公共前后缀长度
                i++;
            } else {
                /*
                    1.如果不相等 patternArr[len]!=patternArr[i]
                      我们想要求当前子串 对应索引[0,i] 的最长公共前后缀长度
                      我们就不能以 上一个子串的最长公共前后缀：前缀字符串pre  后缀字符串post （毫无疑问pre==post） 作为拼接参考

                    2.但可以思考一下：
                      pre的最长公共前缀字符串： 索引 [      0        , next[len-1] )
                      是等于
                      post的最长公共后缀字符串：索引 [ i-next[len-1] ,     i       )

                      则我们 就以 pre的最长公共前缀字符串/post的最长公共后缀字符串 作为拼接参考
                      去判断 pre的最长公共前缀字符串的下一个字符patternArr[next[len-1]] 是否等于 post的最长公共后缀字符串的下一个字符patternArr[i]

                    3.在第 1,2 步分析的基础上
                      我们可以在判断出 patternArr[len]!=patternArr[i] 后，
                      不去执行第二步：patternArr[next[len-1]] 是否等于 patternArr[i]，
                      可以先修改len的值：len = next[len-1]，len就成了 pre的最长公共前缀字符串长度/post的最长公共后缀字符串长度，
                      修改完之后，再去判断下一个字符 是否相等，即 判断 patternArr[len] 是否等于 patternArr[i]
                      仔细观察，这不又是在判断 这个循环中 if-else 语句吗

                    4.关于 len 这个值，在循环开始时我们解释的是：上一个子串的最长公共前后缀字符串的长度
                      但实际上我们在这里改为 len = next[len-1] 表示上一个子串的最长公共前后缀字符串的最长公共前后缀字符串的长度
                      是没有问题的，等价于上一个子串的较小的公共前后缀字符串。
                      既然进入了 else 语句说明字符不相等，就不能以 上一个子串的最长公共前后缀字符串 作为 拼接参考，就应当去缩小参考范围。
                 */
                if (len == 0) {

                    /*
                        len为0说明上一个子串已经没有了公共前后缀字符串
                        则我们没有继续寻找的必要 --> 索引在[0, i]的当前子串的最长公共前后缀字符串长度就是0
                     */
                    next[i] = len;

                    //继续寻找下一个字符串的最长公共前后缀字符串长度
                    i++;

                } else {
                    len = next[len - 1];
                }

            }
        }

        return next;
    }
}
```

### 允许匹配多个，可重复索引字符的代码

#### KMP 算法的大致步骤

1. 求出`模式字符串patternStr`的部分匹配表，已知待匹配的字符串 `matchStr`
2. 定义两个指针 `i` 和 `j`，分别指向 patternStr 和 matchStr ，初始化为 0
3. 定义一个 ArrayList 集合 `firstIndexList`，用于存储每次匹配成功的字符串的开始索引位置
4. 判断 patternStr[i] 和 matchStr[j] 是否相等
    - 如果相等，则继续向后匹配：i++, j++
    - 如果不相等，则 i 不变，调整 j 为 模式字符串 pattern  的 上一个子串（索引 [0, j-1]）的最长公共`前缀`字符串的下一个索引位置，该索引位置也是最长公共前缀 / 后缀字符串的长度：j = next[j - 1]
5. 判断 i 是否超出 最大索引值
    - 如果超出了 matchStr 的 最大索引值，就退出循环
6. 判断 j 是否超出了 最大索引值
    - 如果超出了 patternStr 的最大索引值：
        - 将匹配到的字符串的开始索引位置加入到 `firstIndexList` 集合：firstIndexList.add(i - j)
        - 调整 j 为 模式字符串 pattern（索引 [0, j-1]）的最长公共`前缀`字符串的下一个索引位置，该索引位置也是最长公共前缀 / 后缀字符串的长度：j = next[j - 1]。
7. 第五步成立则循环退出，返回 `firstIndexList` 集合

#### 代码实现 + 测试


```java
package kmp;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * @author 狐狸半面添
 * @create 2022-11-22 22:43
 */
public class KMPAlgorithm {
    public static void main(String[] args) {
        String matchStr = "AABABADDABAC";
        String patternStr = "ABA";

        // 输出：[1, 3, 8]
        System.out.println(kmpSearch(matchStr, patternStr, kmpNext(patternStr)).toString());

    }

    /**
     * kmp搜索算法
     *
     * @param matchStr   原字符串
     * @param patternStr 子串
     * @param next       子串对应的部分匹配表
     * @return 每次匹配成功的字符串的开始索引位置的集合
     */
    public static ArrayList<Integer> kmpSearch(String matchStr, String patternStr, int[] next) {

        int i = 0, j = 0;

        ArrayList<Integer> firstIndexList = new ArrayList<>();

        while (i < matchStr.length()) {

            if (matchStr.charAt(i) == patternStr.charAt(j)) {
                //相等就继续进行匹配
                i++;
                j++;

            } else {
                //如果 patternStr[i] 和 matchStr[j] 不相等

                if (j == 0) {
                    /*
                        表示 matchStr 没有匹配到 patternStr的第一个字符
                        那直接将 matchStr 的指针 i 向后移动一位即可
                     */
                    i++;
                } else {
                    j = next[j - 1];
                }
            }

            if (j == patternStr.length()) {
                //超出了最大索引值
                firstIndexList.add(i - j);
                j = next[j - 1];
            }

        }
        return firstIndexList;
    }

    /**
     * 获取一个字符串 pattern 的部分匹配表
     *
     * @param patternStr 用于模式匹配字符串
     * @return 存储部分匹配表的每个子串的最长公共前后缀的 next数组
     */
    public static int[] kmpNext(String patternStr) {
        //将 patternStr 转为 字符数组形式
        char[] patternArr = patternStr.toCharArray();

        //预先创建一个next数组，用于存储部分匹配表的每个子串的最长公共前后缀
        int[] next = new int[patternStr.length()];

        /*
            从第一个字符（对应索引为0）开始的子串，如果子串的长度为1，那么肯定最长公共前后缀为0
            因为这唯一的一个字符既是第一个字符，又是最后一个字符，所以前后缀都不存在 -> 最长公共前后缀为0
         */
        next[0] = 0;

        /*
          len有两个作用：
            1. 用于记录当前子串的最长公共前后缀长度
            2. 同时知道当前子串的最长公共前后缀的前缀字符串对应索引 [0,len-1]  <-- 可以拿示例分析一下
         */
        int len = 0;

        //从第二个字符开始遍历，求索引在 [0,i] 的子串的最长公共前后缀长度
        int i = 1;
        while (i < patternArr.length) {
            /*
                1.已经知道了上一个子串 对应索引[0,i-1] 的最长公共前后缀长度为 len
                  的前缀字符串是 索引[0,len-1]，对应相等的后缀字符串是 索引[i-len,i-1]

                2.因此我们可以以 上一个子串的最长公共前后缀字符串 作为拼接参考
                  比较一下 patternArr[len] 与 patternArr[i] 是否相等
             */
            if (patternArr[len] == patternArr[i]) {
                /*
                    1.如果相等即 patternArr[len]==patternArr[i]，
                      那么就可以确定当前子串的最长公共前后缀的
                      前缀字符串是 索引[0,len] ，对应相等的后缀字符串是 索引[i-len,i]

                    2.由于是拼接操作，那么当前子串的最长公共前后缀长度只需要在上一个子串的最长公共前后缀长度的基础上 +1 即可
                      即 next[i] = next[i-1] + 1 ，

                    3.由于 len 是记录的子串的最长公共前后缀长度，对于当前我们所在的代码位置而言
                      len 还是记录的上一个子串的最长公共前后缀长度，因此：
                      next[i] = next[i-1] + 1 等价于 next[i] = ++len
                 */

                // 等价于 next[i] = next[i-1] + 1
                next[i] = ++len;
                //既然找到了索引在[0,i]的子串的最长公共前后缀字符串长度，那就 i+1 去判断以下一个字符结尾的子串的最长公共前后缀长度
                i++;
            } else {
                /*
                    1.如果不相等 patternArr[len]!=patternArr[i]
                      我们想要求当前子串 对应索引[0,i] 的最长公共前后缀长度
                      我们就不能以 上一个子串的最长公共前后缀：前缀字符串pre  后缀字符串post （毫无疑问pre==post） 作为拼接参考

                    2.但可以思考一下：
                      pre的最长公共前缀字符串： 索引 [      0        , next[len-1] )
                      是等于
                      post的最长公共后缀字符串：索引 [ i-next[len-1] ,     i       )

                      则我们 就以 pre的最长公共前缀字符串/post的最长公共后缀字符串 作为拼接参考
                      去判断 pre的最长公共前缀字符串的下一个字符patternArr[next[len-1]] 是否等于 post的最长公共后缀字符串的下一个字符patternArr[i]

                    3.在第 1,2 步分析的基础上
                      我们可以在判断出 patternArr[len]!=patternArr[i] 后，
                      不去执行第二步：patternArr[next[len-1]] 是否等于 patternArr[i]，
                      可以先修改len的值：len = next[len-1]，len就成了 pre的最长公共前缀字符串长度/post的最长公共后缀字符串长度，
                      修改完之后，再去判断下一个字符 是否相等，即 判断 patternArr[len] 是否等于 patternArr[i]
                      仔细观察，这不又是在判断 这个循环中 if-else 语句吗

                    4.关于 len 这个值，在循环开始时我们解释的是：上一个子串的最长公共前后缀字符串的长度
                      但实际上我们在这里改为 len = next[len-1] 表示上一个子串的最长公共前后缀字符串的最长公共前后缀字符串的长度
                      是没有问题的，等价于上一个子串的较小的公共前后缀字符串。
                      既然进入了 else 语句说明字符不相等，就不能以 上一个子串的最长公共前后缀字符串 作为 拼接参考，就应当去缩小参考范围。
                 */
                if (len == 0) {

                    /*
                        len为0说明上一个子串已经没有了公共前后缀字符串
                        则我们没有继续寻找的必要 --> 索引在[0, i]的当前子串的最长公共前后缀字符串长度就是0
                     */
                    next[i] = len;

                    //继续寻找下一个字符串的最长公共前后缀字符串长度
                    i++;

                } else {
                    len = next[len - 1];
                }

            }
        }

        return next;
    }
}
```

### 允许匹配多个，不可重复索引字符的代码

#### KMP 算法的大致步骤

1. 求出`模式字符串patternStr`的部分匹配表，已知待匹配的字符串 `matchStr`
2. 定义两个指针 `i` 和 `j`，分别指向 patternStr 和 matchStr ，初始化为 0
3. 定义一个 ArrayList 集合 `firstIndexList`，用于存储每次匹配成功的字符串的开始索引位置
4. 判断 patternStr[i] 和 matchStr[j] 是否相等
    - 如果相等，则继续向后匹配：i++, j++
    - 如果不相等，则 i 不变，调整 j 为 模式字符串 pattern  的 上一个子串（索引 [0, j-1]）的最长公共`前缀`字符串的下一个索引位置，该索引位置也是最长公共前缀 / 后缀字符串的长度：j = next[j - 1]
5. 判断 i 是否超出 最大索引值
    - 如果超出了 matchStr 的 最大索引值，就退出循环
6. 判断 j 是否超出了 最大索引值
    - 如果超出了 patternStr 的最大索引值：
        - 将匹配到的字符串的开始索引位置加入到 `firstIndexList` 集合：firstIndexList.add(i - j)
        - 设置 j = 0 开始重新匹配
7. 第五步成立则循环退出，返回 `firstIndexList` 集合

#### 代码实现 + 测试
```java
package kmp;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * @author 狐狸半面添
 * @create 2022-11-22 22:43
 */
public class KMPAlgorithm {
    public static void main(String[] args) {
        String matchStr = "AABABADDABAC";
        String patternStr = "ABA";

        // 输出：[1, 8]
        System.out.println(kmpSearch(matchStr, patternStr, kmpNext(patternStr)).toString());

    }

    /**
     * kmp搜索算法
     *
     * @param matchStr   原字符串
     * @param patternStr 子串
     * @param next       子串对应的部分匹配表
     * @return 每次匹配成功的字符串的开始索引位置的集合
     */
    public static ArrayList<Integer> kmpSearch(String matchStr, String patternStr, int[] next) {

        int i = 0, j = 0;

        ArrayList<Integer> firstIndexList = new ArrayList<>();

        while (i < matchStr.length()) {

            if (matchStr.charAt(i) == patternStr.charAt(j)) {
                //相等就继续进行匹配
                i++;
                j++;

            } else {
                //如果 patternStr[i] 和 matchStr[j] 不相等

                if (j == 0) {
                    /*
                        表示 matchStr 没有匹配到 patternStr的第一个字符
                        那直接将 matchStr 的指针 i 向后移动一位即可
                     */
                    i++;
                } else {
                    j = next[j - 1];
                }
            }

            if (j == patternStr.length()) {
                //超出了最大索引值
                firstIndexList.add(i - j);
                j = 0;
            }

        }
        return firstIndexList;
    }

    /**
     * 获取一个字符串 pattern 的部分匹配表
     *
     * @param patternStr 用于模式匹配字符串
     * @return 存储部分匹配表的每个子串的最长公共前后缀的 next数组
     */
    public static int[] kmpNext(String patternStr) {
        //将 patternStr 转为 字符数组形式
        char[] patternArr = patternStr.toCharArray();

        //预先创建一个next数组，用于存储部分匹配表的每个子串的最长公共前后缀
        int[] next = new int[patternStr.length()];

        /*
            从第一个字符（对应索引为0）开始的子串，如果子串的长度为1，那么肯定最长公共前后缀为0
            因为这唯一的一个字符既是第一个字符，又是最后一个字符，所以前后缀都不存在 -> 最长公共前后缀为0
         */
        next[0] = 0;

        /*
          len有两个作用：
            1. 用于记录当前子串的最长公共前后缀长度
            2. 同时知道当前子串的最长公共前后缀的前缀字符串对应索引 [0,len-1]  <-- 可以拿示例分析一下
         */
        int len = 0;

        //从第二个字符开始遍历，求索引在 [0,i] 的子串的最长公共前后缀长度
        int i = 1;
        while (i < patternArr.length) {
            /*
                1.已经知道了上一个子串 对应索引[0,i-1] 的最长公共前后缀长度为 len
                  的前缀字符串是 索引[0,len-1]，对应相等的后缀字符串是 索引[i-len,i-1]

                2.因此我们可以以 上一个子串的最长公共前后缀字符串 作为拼接参考
                  比较一下 patternArr[len] 与 patternArr[i] 是否相等
             */
            if (patternArr[len] == patternArr[i]) {
                /*
                    1.如果相等即 patternArr[len]==patternArr[i]，
                      那么就可以确定当前子串的最长公共前后缀的
                      前缀字符串是 索引[0,len] ，对应相等的后缀字符串是 索引[i-len,i]

                    2.由于是拼接操作，那么当前子串的最长公共前后缀长度只需要在上一个子串的最长公共前后缀长度的基础上 +1 即可
                      即 next[i] = next[i-1] + 1 ，

                    3.由于 len 是记录的子串的最长公共前后缀长度，对于当前我们所在的代码位置而言
                      len 还是记录的上一个子串的最长公共前后缀长度，因此：
                      next[i] = next[i-1] + 1 等价于 next[i] = ++len
                 */

                // 等价于 next[i] = next[i-1] + 1
                next[i] = ++len;
                //既然找到了索引在[0,i]的子串的最长公共前后缀字符串长度，那就 i+1 去判断以下一个字符结尾的子串的最长公共前后缀长度
                i++;
            } else {
                /*
                    1.如果不相等 patternArr[len]!=patternArr[i]
                      我们想要求当前子串 对应索引[0,i] 的最长公共前后缀长度
                      我们就不能以 上一个子串的最长公共前后缀：前缀字符串pre  后缀字符串post （毫无疑问pre==post） 作为拼接参考

                    2.但可以思考一下：
                      pre的最长公共前缀字符串： 索引 [      0        , next[len-1] )
                      是等于
                      post的最长公共后缀字符串：索引 [ i-next[len-1] ,     i       )

                      则我们 就以 pre的最长公共前缀字符串/post的最长公共后缀字符串 作为拼接参考
                      去判断 pre的最长公共前缀字符串的下一个字符patternArr[next[len-1]] 是否等于 post的最长公共后缀字符串的下一个字符patternArr[i]

                    3.在第 1,2 步分析的基础上
                      我们可以在判断出 patternArr[len]!=patternArr[i] 后，
                      不去执行第二步：patternArr[next[len-1]] 是否等于 patternArr[i]，
                      可以先修改len的值：len = next[len-1]，len就成了 pre的最长公共前缀字符串长度/post的最长公共后缀字符串长度，
                      修改完之后，再去判断下一个字符 是否相等，即 判断 patternArr[len] 是否等于 patternArr[i]
                      仔细观察，这不又是在判断 这个循环中 if-else 语句吗

                    4.关于 len 这个值，在循环开始时我们解释的是：上一个子串的最长公共前后缀字符串的长度
                      但实际上我们在这里改为 len = next[len-1] 表示上一个子串的最长公共前后缀字符串的最长公共前后缀字符串的长度
                      是没有问题的，等价于上一个子串的较小的公共前后缀字符串。
                      既然进入了 else 语句说明字符不相等，就不能以 上一个子串的最长公共前后缀字符串 作为 拼接参考，就应当去缩小参考范围。
                 */
                if (len == 0) {

                    /*
                        len为0说明上一个子串已经没有了公共前后缀字符串
                        则我们没有继续寻找的必要 --> 索引在[0, i]的当前子串的最长公共前后缀字符串长度就是0
                     */
                    next[i] = len;

                    //继续寻找下一个字符串的最长公共前后缀字符串长度
                    i++;

                } else {
                    len = next[len - 1];
                }

            }
        }

        return next;
    }
}
```
# BM
### BM 算法原理

BM 算法定义了两个规则：

- 坏字符规则：当文本串中的某个字符跟模式串的某个字符不匹配时，我们称文本串中的这个失配字符为坏字符，此时模式串需要向右移动，`移动的位数 = 坏字符在模式串中的位置 - 坏字符在模式串中最右出现的位置`。此外，`如果"坏字符"不包含在模式串之中，则最右出现位置为-1`。
- 好后缀规则：当字符失配时，`后移位数 = 好后缀在模式串中的位置 - 好后缀在模式串上一次出现的位置`，且`如果好后缀在模式串中没有再次出现，则为-1`。

![](https://i-blog.csdnimg.cn/blog_migrate/385b0ed19295c37245c7db610c521bbe.png#pic_center)

下面举例说明 BM 算法。例如，给定文本串 “`HERE IS A SIMPLE EXAMPLE`”，和模式串 “`EXAMPLE`”，现要查找模式串是否在文本串中，如果存在，返回模式串在文本串中的位置。

- 首先，“文本串 "与" 模式串 " 头部对齐，从尾部开始比较。”`S`“与”`E`“不匹配。这时，”`S`“就被称为 " 坏字符”（bad character），即不匹配的字符，它对应着模式串的第`6`位。且 "`S`“不包含在模式串”`EXAMPLE`“之中（相当于最右出现位置是`-1`），这意味着可以把模式串后移`6-(-1)=7`位，从而直接移到”`S`" 的后一位。  
    
    ![](https://i-blog.csdnimg.cn/blog_migrate/a2485660796429f47c0ad766240852a0.png#pic_center)
    
- 依然从尾部开始比较，发现 "`P`“与”`E`“不匹配，所以”`P`“是 "坏字符”。但是，"`P`“包含在模式串”`EXAMPLE`" 之中。因为 “`P`”这个 “坏字符” 对应着模式串的第`6`位（从`0`开始编号），且在模式串中的最右出现位置为`4`，所以，将模式串后移`6-4=2`位，两个 "P" 对齐。  
    
    ![](https://i-blog.csdnimg.cn/blog_migrate/9a09d02108799d712d96d1b57428d325.png#pic_center)
    
      
    
    ![](https://i-blog.csdnimg.cn/blog_migrate/62520db9c733badc4e3cbe4f58aab430.png#pic_center)
    
- 依次比较，得到 “`MPLE`” 匹配，称为 "好后缀"（good suffix），即所有尾部匹配的字符串。注意，"`MPLE`"、"`PLE`"、"`LE`"、"`E`" 都是好后缀。  
    
    ![](https://i-blog.csdnimg.cn/blog_migrate/018f6c204999270eeca85544fa1bd97f.png#pic_center)
    
- 发现 “`I`” 与 “`A`” 不匹配：“`I`” 是坏字符。如果是根据坏字符规则，此时模式串应该后移`2-(-1)=3`位。问题是，有没有更优的移法？  
    
    ![](https://i-blog.csdnimg.cn/blog_migrate/5aea220126d8b45b6c27da0160c16a15.png#pic_center)
    
      
    
    ![](https://i-blog.csdnimg.cn/blog_migrate/41da877c67b46b40e64dcb72e56a3869.png#pic_center)
    
- 更优的移法是利用好后缀规则：当字符失配时，`后移位数 = 好后缀在模式串中的位置 - 好后缀在模式串中上一次出现的位置`，且如果好后缀在模式串中没有再次出现，则为`-1`。所有的 “好后缀”（`MPLE、PLE、LE、E`）之中，只有 “`E`” 在 “`EXAMPLE`” 的头部出现，所以后移`6-0=6`位。可以看出，“坏字符规则” 只能移`3`位，“好后缀规则” 可以移`6`位。每次后移这两个规则之中的较大值。这两个规则的移动位数，只与模式串有关，与原文本串无关。  
    
    ![](https://i-blog.csdnimg.cn/blog_migrate/462745ac8d99ca2e297ab3ff89e8409e.png#pic_center)
    
- 继续从尾部开始比较，“P”与 “E” 不匹配，因此 “P” 是“坏字符”，根据“坏字符规则”，后移 6 - 4 = 2 位。因为是最后一位就失配，尚未获得好后缀。  
    
    ![](https://i-blog.csdnimg.cn/blog_migrate/4cb136a0839beabd9135299f847c9224.png#pic_center)
    

### 好后缀加深理解

由上可知，BM 算法不仅效率高，而且构思巧妙，容易理解。坏字符规则相对而言比较好理解，好后缀如果还不理解，我这里再继续举个例子解释一下，这里加深理解。

- 如果模式串中存在已经匹配成功的好后缀，则把目标串与好后缀对齐，然后从模式串的最尾元素开始往前匹配。  
    
    ![](https://i-blog.csdnimg.cn/blog_migrate/f77222ab971c5ffcc94e2ce087c9f6ee.png#pic_center)
    
      
    
    ![](https://i-blog.csdnimg.cn/blog_migrate/cd1bcdedb80757b0654da84a91fec426.png#pic_center)
    
- 如果无法找到匹配好的后缀，找一个匹配的最长的前缀，让目标串与最长的前缀对齐（如果这个前缀存在的话）。模式串 [m-s，m] = 模式串 [0，s] 。  
    
    ![](https://i-blog.csdnimg.cn/blog_migrate/51b6672e7613174aebbeede9afd72ccb.png#pic_center)
    
      
    
    ![](https://i-blog.csdnimg.cn/blog_migrate/cf19a80cf945cd3efb040e1ceb6751e8.png#pic_center)
    
- 如果完全不存在和好后缀匹配的子串，则右移整个模式串。

### 先实现好字符规则

BM 算法还是很好理解的，其实如果你之前学习 KMP 算法你也会有同样的感受，KMP 算法理解起来不是很难，但是重点在于怎么去实现 next 数组。BM 算法也是，原理理解起来其实非常的容易，不过怎么去实现，没有一套标准的代码。不过可以研究别人的代码，然后实现一套尽量适合精简的代码。还是一样，一步一步来，我们先来实现好字符规则。好字符规则的代码如下，我会在代码中必要的地方加入注释，辅助理解，代码是最好的老师。

```java
public static void getRight(String pat, int[] right) {
	//首先创建一个模式串的字符位置的数组，初始化为-1，就是用于记录模式串
	//中，每个字符在模式串中的相对位置，这里直接用的是256，也
	//就是ASCII码的最大值，当然，如果你的字符串中只限制了26个
	//字符，你也可以直接使用26
    for (int i = 0; i < 256; i++) {
        right[i] = -1;
    }
    //值得一提的是，通过这种方式，可以你会发现，如果模式串中存在相同的
    //字符，那么right数组中，记录的是最右的那个字符的位置
    for (int j = 0; j < pat.length(); j++) {
        right[pat.charAt(j)] = j;
    }
}

public static int Search(String txt, String pat, int[] right) {
    int M = txt.length();//主串的长度
    int N = pat.length();//模式串的长度
    int skip;//用于记录跳过几个字符
    for (int i = 0; i < M - N; i += skip) {
        skip = 0;//每次进入循环要记得初始化为0
        for (int j = N - 1; j >= 0; j--) {
        	//不相等，意味着出现坏字符，按照上面的规则移动
            if (pat.charAt(j) != txt.charAt(i + j)) {
                skip = j - right[txt.charAt(i + j)];
                //skip之所以会小于1，可能是因为坏字符在模式串中最右的位置，可能
                //在j指向字符的右侧，就是已经越过了。
                if (skip < 1) 
                    skip = 1;
                break;
            }
        }
        //注意了这个时候循环了一遍之后，skip如果等于0，意味着没有坏字符出现，所以
        //匹配成功，返回当前字符i的位置
        if (skip == 0)
            return i;
    }
    return -1;
}
```

### 完整 BM 实现

上面的代码不难理解，相信你已经看懂了，那么接下来也不用单独来讲好后缀的实现，直接上完整的实现代码。因为完整的 BM 实现中，就是比较坏字符规则以及好后缀规则，哪个移动的字符数更多，就使用哪个。老样子，下面的代码中我尽量的加注释。

```java
public static int pattern(String pattern, String target) {
    int tLen = target.length();//主串的长度
    int pLen = pattern.length();//模式串的长度

	//如果模式串比主串长，没有可比性，直接返回-1
    if (pLen > tLen) {
        return -1;
    }

    int[] bad_table = build_bad_table(pattern);// 获得坏字符数值的数组，实现看下面
    int[] good_table = build_good_table(pattern);// 获得好后缀数值的数组，实现看下面

    for (int i = pLen - 1, j; i < tLen;) {
        System.out.println("跳跃位置：" + i);
        //这里和上面实现坏字符的时候不一样的地方，我们之前提前求出坏字符以及好后缀
        //对应的数值数组，所以，我们只要在一边循环中进行比较。还要说明的一点是，这里
        //没有使用skip记录跳过的位置，直接针对主串中移动的指针i进行移动
        for (j = pLen - 1; target.charAt(i) == pattern.charAt(j); i--, j--) {
            if (j == 0) {//指向模式串的首字符，说明匹配成功，直接返回就可以了
                System.out.println("匹配成功，位置：" + i);
                //如果你还要匹配不止一个模式串，那么这里直接跳出这个循环，并且让i++
                //因为不能直接跳过整个已经匹配的字符串，这样的话可能会丢失匹配。
//					i++;   // 多次匹配
//					break;
                return i;
            }
        }
        //如果出现坏字符，那么这个时候比较坏字符以及好后缀的数组，哪个大用哪个
        i += Math.max(good_table[pLen - j - 1], bad_table[target.charAt(i)]);
    }
    return -1;
}

//字符信息表
public static int[] build_bad_table(String pattern) {
    final int table_size = 256;//上面已经解释过了，字符的种类
    int[] bad_table = new int[table_size];//创建一个数组，用来记录坏字符出现时，应该跳过的字符数
    int pLen = pattern.length();//模式串的长度

    for (int i = 0; i < bad_table.length; i++) {
        bad_table[i] = pLen;  
        //默认初始化全部为匹配字符串长度,因为当主串中的坏字符在模式串中没有出
        //现时，直接跳过整个模式串的长度就可以了
    }
    for (int i = 0; i < pLen - 1; i++) {
        int k = pattern.charAt(i);//记录下当前的字符ASCII码值
        //这里其实很值得思考一下，bad_table就不多说了，是根据字符的ASCII值存储
        //坏字符出现最右的位置，这在上面实现坏字符的时候也说过了。不过你仔细思考
        //一下，为什么这里存的坏字符数值，是最右的那个坏字符相对于模式串最后一个
        //字符的位置？为什么？首先你要理解i的含义，这个i不是在这里的i，而是在上面
        //那个pattern函数的循环的那个i，为了方便我们称呼为I，这个I很神奇，虽然I是
        //在主串上的指针，但是由于在循环中没有使用skip来记录，直接使用I随着j匹配
        //进行移动，也就意味着，在某种意义上，I也可以直接定位到模式串的相对位置，
        //理解了这一点，就好理解在本循环中，i的行为了。

		//其实仔细去想一想，我们分情况来思考，如果模式串的最
        //后一个字符，也就是匹配开始的第一个字符，出现了坏字符，那么这个时候，直
        //接移动这个数值，那么正好能让最右的那个字符正对坏字符。那么如果不是第一个
        //字符出现坏字符呢？这种情况你仔细想一想，这种情况也就意味着出现了好后缀的
        //情况，假设我们将最右的字符正对坏字符
        bad_table[k] = pLen - 1 - i;
    }
    return bad_table;
}

//匹配偏移表
public static int[] build_good_table(String pattern) {
    int pLen = pattern.length();//模式串长度
    int[] good_table = new int[pLen];//创建一个数组，存好后缀数值
    //用于记录最新前缀的相对位置，初始化为模式串长度，因为意思就是当前后缀字符串为空
    //要明白lastPrefixPosition 的含义
    int lastPrefixPosition = pLen;

    for (int i = pLen - 1; i >= 0; --i) {
        if (isPrefix(pattern, i + 1)) {
        //如果当前的位置存在前缀匹配，那么记录当前位置
            lastPrefixPosition = i + 1;
        }
        good_table[pLen - 1 - i] = lastPrefixPosition - i + pLen - 1;
    }

    for (int i = 0; i < pLen - 1; ++i) {
    //计算出指定位置匹配的后缀的字符串长度
        int slen = suffixLength(pattern, i);
        good_table[slen] = pLen - 1 - i + slen;
    }
    return good_table;
}

//前缀匹配
private static boolean isPrefix(String pattern, int p) {
    int patternLength = pattern.length();//模式串长度
    //这里j从模式串第一个字符开始，i从指定的字符位置开始，通过循环判断当前指定的位置p
    //之后的字符串是否匹配模式串前缀
    for (int i = p, j = 0; i < patternLength; ++i, ++j) {
        if (pattern.charAt(i) != pattern.charAt(j)) {
            return false;
        }
    }
    return true;
}

//后缀匹配
private static int suffixLength(String pattern, int p) {
    int pLen = pattern.length();
    int len = 0;
    for (int i = p, j = pLen - 1; i >= 0 && pattern.charAt(i) == pattern.charAt(j); i--, j--) {
        len += 1;
    }
    return len;
}
```

理解一下上面代码，这里我针对上面代码举个例子，计算之后的两张表的数值如下：  

![](https://i-blog.csdnimg.cn/blog_migrate/084a76030b223251ad84ed0b6be19867.png#pic_center)

  

![](https://i-blog.csdnimg.cn/blog_migrate/3da31a44949ef1cc305877265bb26bbd.png#pic_center)
# Sunday
### 基本思想及举例

Sunday 算法由 Daniel M.Sunday 在 1990 年提出，它的思想跟 BM 算法很相似：[1](https://blog.csdn.net/q547550831/article/details/51860017#fn:sup1 "See footnote")

只不过 Sunday 算法是从前往后匹配，在匹配失败时关注的是主串中参加匹配的最末位字符的下一位字符。

- 如果该字符没有在模式串中出现则直接跳过，即移动位数 = 模式串长度 + 1；
- 否则，其移动位数 = 模式串长度 - 该字符最右出现的位置 (以 0 开始) = 模式串中该字符最右出现的位置到尾部的距离 + 1。

下面举个例子说明下 Sunday 算法。假定现在要在主串”substring searching” 中查找模式串”search”。

- 刚开始时，把模式串与文主串左边对齐：  
    
    ![](https://img-blog.csdn.net/20160708122016780)
    
- 结果发现在第 2 个字符处发现不匹配，不匹配时关注主串中参加匹配的最末位字符的下一位字符，即标粗的字符 i，因为模式串 search 中并不存在 i，所以模式串直接跳过一大片，向右移动位数 = 匹配串长度 + 1 = 6 + 1 = 7，从 i 之后的那个字符（即字符 n）开始下一步的匹配，如下图：  
    
    ![](https://img-blog.csdn.net/20160708122307562)
    
- 结果第一个字符就不匹配，再看主串中参加匹配的最末位字符的下一位字符，是’r’，它出现在模式串中的倒数第 3 位，于是把模式串向右移动 3 位（m - 3 = 6 - 3 = r 到模式串末尾的距离 + 1 = 2 + 1 =3），使两个’r’对齐，如下：  
    
    ![](https://img-blog.csdn.net/20160708122414877)
    
- 匹配成功。
    
    回顾整个过程，我们只移动了两次模式串就找到了匹配位置，缘于 Sunday 算法每一步的移动量都比较大，效率很高。
    

### 偏移表

在预处理中，计算大小为|∑||∑|的偏移表。

shift[w]={m−max{i<m|P[i]=w}m+1 if w is in P[0..m−1] otherwise shift[w]={m−max{i<m|P[i]=w} if w is in P[0..m−1]m+1 otherwise 

例如： P = “search”  
m = 6  
shift[s] = 6 - max(s 的位置) = 6 - 0 = 6  
shift[e] = 6 - max(e 的位置) = 6 - 1 = 5  
shift[a] = 6 - max(a 的位置) = 6 - 2 = 4  
shift[r] = 6 - max(r 的位置) = 6 - 3 = 3  
shift[c] = 6 - max(c 的位置) = 6 - 4 = 2  
shift[h] = 6 - max(h 的位置) = 6 - 5 = 1  
shift[其他] = m + 1 = 6 + 1 = 7

# KR (Karp-Rabin) 算法

## 基本思想

KR算法的核心思想是利用哈希函数将模式串和文本子串转换为数字进行比较，这样可以在O(1)时间内完成一次比较。其主要步骤如下：

1. 计算模式串P的哈希值hash_p
2. 计算文本串T中长度为m的所有子串的哈希值hash_t
3. 比较hash_p和hash_t，如果相等，则可能找到一个匹配（需要进一步验证）
4. 如果不相等，则一定不匹配

## 哈希函数

KR算法使用的哈希函数需要满足以下特点：

1. 能够快速计算
2. 碰撞概率要小
3. 能够O(1)时间内由上一个子串的哈希值计算出下一个子串的哈希值

通常使用的哈希函数形式如下：

```cpp
hash(string) = (s[0] * d^(m-1) + s[1] * d^(m-2) + ... + s[m-1]) mod q
```

其中：
- d是进制数，通常取一个小于q的素数
- q是一个较大的素数
- m是模式串的长度
- s[i]是字符串中第i个字符的ASCII值

## 实现示例

```java
public class KarpRabin {
    private String pat;      // 模式串
    private long patHash;    // 模式串的哈希值
    private int M;          // 模式串长度
    private long Q;         // 一个大素数
    private int R;          // 基数
    private long RM;        // R^(M-1) % Q

    public KarpRabin(String pat) {
        this.pat = pat;
        R = 256;
        M = pat.length();
        Q = 997;  // 或其他大素数

        // 预计算 R^(M-1) % Q
        RM = 1;
        for (int i = 1; i <= M-1; i++)
            RM = (R * RM) % Q;

        // 预计算模式串的哈希值
        patHash = hash(pat, M);
    }

    // 计算key[0..M-1]的哈希值
    private long hash(String key, int M) {
        long h = 0;
        for (int j = 0; j < M; j++)
            h = (R * h + key.charAt(j)) % Q;
        return h;
    }

    // 检查模式串是否出现在txt的偏移量i处
    private boolean check(String txt, int i) {
        for (int j = 0; j < M; j++)
            if (pat.charAt(j) != txt.charAt(i + j))
                return false;
        return true;
    }

    // 在文本中搜索模式串
    public int search(String txt) {
        int N = txt.length();
        if (N < M) return -1;

        // 计算第一个窗口的哈希值
        long txtHash = hash(txt, M);

        if (patHash == txtHash && check(txt, 0))
            return 0;

        // 用滚动哈希计算后续窗口的哈希值
        for (int i = M; i < N; i++) {
            // 去掉第一个数字，加上新的数字
            txtHash = (txtHash + Q - RM * txt.charAt(i-M) % Q) % Q;
            txtHash = (txtHash * R + txt.charAt(i)) % Q;

            // 找到匹配
            int offset = i - M + 1;
            if (patHash == txtHash && check(txt, offset))
                return offset;
        }
        return -1;  // 未找到匹配
    }
}
```

## 性能分析

- **时间复杂度**：预处理时间O(m)，最坏情况下的匹配时间O(mn)，但平均情况下接近O(n)
- **空间复杂度**：O(1)
- **优点**：实现简单，在实际应用中速度较快
- **缺点**：存在哈希冲突的可能，需要进行额外的字符串比较

## 总结

KR算法是一个基于哈希的字符串匹配算法：
1. 通过哈希函数将字符串比较转换为数值比较
2. 使用滚动哈希技术实现O(1)时间内计算下一个子串的哈希值
3. 适用于多模式串匹配的场景
4. 在实际应用中（如文本编辑器的查找功能）表现良好

# 各算法对比

## 时间复杂度对比

| 算法 | 预处理时间 | 匹配时间 |
|------|------------|----------|
| KMP | O(m) | O(n) |
| BM | O(m + σ) | O(mn) |
| Sunday | O(m + σ) | O(mn) |
| KR | O(m) | 平均O(n) |

其中：
- n 是主串长度
- m 是模式串长度
- σ 是字符集大小

## 空间复杂度对比

| 算法 | 空间复杂度 |
|------|------------|
| KMP | O(m) |
| BM | O(σ) |
| Sunday | O(σ) |
| KR | O(1) |

## 适用场景对比

1. **KMP算法**
   - 适合在有大量重复的模式串中进行匹配
   - 对于较短的文本，可能不如简单的暴力匹配

2. **BM算法**
   - 特别适合于大字符集的文本
   - 在实际应用中通常比KMP算法更快
   - 是很多文本编辑器使用的字符串搜索算法

3. **Sunday算法**
   - 实现简单
   - 在实际应用中性能优于KMP
   - 对于短模式串特别有效

4. **KR算法**
   - 适合进行多模式串匹配
   - 实现简单，易于理解
   - 在实际应用中表现稳定

## 代码实现难度

从易到难排序：
1. Sunday算法（最简单）
2. KR算法
3. KMP算法
4. BM算法（最复杂）

## 实际应用建议

1. 对于短文本（长度<1000）：
   - 可以直接使用Sunday算法或暴力匹配

2. 对于中等长度文本：
   - Sunday或BM算法都是不错的选择
   - 如果需要处理多模式串，可以考虑KR算法

3. 对于超长文本：
   - BM算法通常是最佳选择
   - 如果内存受限，可以考虑KMP算法

4. 特殊场景：
   - 二进制数据匹配：KMP算法
   - 多模式串匹配：KR算法
   - 近似字符串匹配：考虑其他算法（如编辑距离）

