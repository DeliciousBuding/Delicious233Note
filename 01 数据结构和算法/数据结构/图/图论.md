# 图的基础
## 图的概念术语
![[图论-20250421182027369.png|400]]
1. **图**：可以用一个二元组G = (V,E)表示，其中V是顶点的非空集合，E是两个顶点间边（弧）的集合。G1是由顶点集合V = {A,B,C,D}和边的集合E={<B,A>，<A,C>，<C,A>，<C,D>，<D,A>，<C,B>}构成。G2是由顶点集合V ={A,B,C,D,E}和边集合E ={ (A,C)，(A,E)，(D,B)，(D,A)}构成。
2. **有向边**：边带有方向，用带尖括号的顶点对来表示，如<D,A>，表示由D射向A的边，A为弧头，D为弧尾。
3. **有向图**：由顶点集和有向边集合组成的图。G１就是一个有向图。
4. **无向边**：边不带有方向，用带圆括号的顶点对来表示，如 (C,A) ，表示C和A之间有条边。
5. **无向图**：由顶点集和无向边集合组成的图。G２就是一个无向图。
6. **邻接**：图的顶点间有边相连，称顶点间有邻接关系。(vi,vj)是一条无向边，称vi和vj邻接、vj和vi邻接、边(vi,vj)邻接于顶点vi和vj；<vi,vj>是条有向边，称vi邻接到vj 、或vj和vi邻接、边<vi,vj>邻接于顶点vi和vj。
7. **出度**：有向图中一个顶点的出度是指由该顶点射出的有向边的条数。
8. **入度**：有向图中一个顶点的入度是指射入该顶点的有向边的条数
9. **度**：  无向图中一个顶点的度是指邻接于该顶点的边的总数。![[图论-20250421182517692.png|400]]
10. **无向完全图**：当无向图中边的条数达到最大，为ｎ（ｎ－１）／２时的图。
11. **有向完全图**：当有向图中边的条数达到最大，为ｎ（ｎ－１）时的图。
12. **加权有向图**：边上带有权重的有向图。
13. **加权无向图**：边上带有权重的无向图。
14. **网络**：加权有向图和加权无向图，统称为网络。
15. **路径**：如果可以从顶点vi出发经过若干条无向边或者有向边到达顶点vj，称顶点vi到顶点vj之间存在着一条路径。
16. **路径的长度**：是顶点vi到顶点vj之间的这条路径上无向边或有向边的条数；
	•如果边上有权重，路径长度也可以用路径上所有边的权重之和来表示。
17. **简单路径**：一条路径上除了第一个顶点和最后一个顶点可能相同之外，其余各顶点都不相同。
18. **简单回路或简单环**：简单路径上第一个顶点和最后一个顶点相同。
19. **子图**：假设有两个图G = (V,E)，G’ = (V’,E’)，且V’是V的子集，E’是E的子集，称G’是G的子图。![[图论-20250421182616875.png|图G1、图G2、图G3均是图G的子图。|450]]
20. **连通**：在一个图中，如果顶点vi到vj之间有路径存在，称顶点vi到vj是连通的。
21. **连通图**：在一个无向图中，如果任意两个顶点对之间都是连通的，称该无向图G是连通图。
22. **极大连通子图**：将该子图外的任意一个顶点增加进子图都会造成子图不连通，且该子图包含了其中顶点间所有的边，该子图称极大连通子图。
23. **连通分量**：_无向图_ 的极大连通子图称连通分量。![[图论-20250421182758535.png]]
24. **强连通图**：在一个有向图G中，如果任意两个顶点对之间都是连通的，称有向图G是强连通图。
25. **强连通分量**：有向图的极大连通子图，称强连通分量。![[图论-20250421182817353.png]]
26. **生成树**：连通图的极小连通子图，该子图包含连通图的所有n个顶点，但只含它的n-1条边。如果去掉一条边，这个子图将不连通；如果增加一条边，必存在回路。
27. **不唯一性**：一个连通图的生成树并不保证唯一。
## ADT
### 数据对象
- 顶点集合：$\{v_i \mid v_i \in \text{ElemSet}, i = 1,2,3,\cdots,n, n > 0\}$ 或 $\varnothing$
  - $\text{ElemSet}$ 为顶点元素的集合
### 数据关系
- 边集合：$\{\langle v_i, v_j \rangle \text{或} (v_i, v_j) \mid v_i, v_j \in \text{ElemSet}, \text{且} P(v_i, v_j), i, j = 1,2,3,\cdots,n\}$
  - $\langle v_i, v_j \rangle$ 表示从 $v_i$ 到 $v_j$ 的**有向边**
  - $(v_i, v_j)$ 表示 $v_i$ 和 $v_j$ 之间的**无向边**
  - $P(v_i, v_j)$ 定义边的关系语义/附加信息
### 基本操作
- `InitGraph(graph, kMaxVertex, no_edge_value, directed)`：初始化一个空的图`graph`。其中`kMaxVertex`是最多可能的顶点数；`no_edge_value`是当顶点间不存在边时，在图中给顶点关系赋予的权值；`directed`为`true`时图是有向的，为`false`时图是无向的。
- `CreateGraph(graph)`：构造一个图`graph`。
- `DestroyGraph(graph)`：释放图`graph`占用的所有空间。
- `NumberOfVex(graph)`：返回图`graph`中顶点的个数。
- `NumberOfEdge(graph)`：返回图`graph`中边的条数。
- `ExistEdge(graph, u, v)`：判断图`graph`中顶点`u`到`v`之间是否存在边，有返回`true`，无返回`false`。
- `GetPosition(graph, v)`：返回顶点`v`在图`graph`中的位置，无则返回`NIL`。
- `GetValue(graph, v)`：返回图`graph`中顶点`v`的值
- `PutValue(graph, v, value)`：为图`graph`中顶点`v`赋值`value`。
- `FirstAdjVex(graph, v)`： 返回图`graph`中顶点`v`的第一个邻接顶点，若`v`无邻接顶点返回`NIL`。
- `NextAdjVex(graph, u, v)`：返回图`graph`中`u`顶点相对`v`顶点的下一个邻接顶点，无则返回`NIL`。
- `InsertVex(graph, v)`：在图`graph`中插入顶点`v`。
- `InsertEdge(graph, u, v, weight)`：在图`graph`中顶点`u`和`v`之间插入一条边，权值为`weight`。
- `RemoveVex(graph, v)`：在图`graph`中删除顶点`v`及所有邻接于顶点`v`的边。
- `RmoveEdge(graph, u, v)`：在图`graph`中删除顶点`u`和`v`之间的边。
- `DFS(graph)`：按深度优先遍历图`graph`中顶点。
- `DFS(graph, v, visited)`：从顶点`v`开始深度优先遍历，`visited`记录顶点访问标记
- `BFS(graph)`：按广度优先遍历图`graph`中顶点。
- `BFS(graph, v, visited)`：从顶点`v`开始广度优先遍历，`visited`记录顶点访问标记 
## 图的存储
图的存储既要考虑到顶点的存储又要考虑到边的存储。
如果按照线性结构和树结构的存储思路，找到一个类似的、既能同时存储顶点又能存储表示顶点间关系的边的结构就非常困难。不妨换个思路，**将顶点和边的存储独立开来**，顶点归顶点存、边归边存。
### 邻接矩阵
- 在一维数组中存储顶点信息，在二维矩阵中存储边的信息。
- 如果非加权图中，存在一条自顶点vi到vj 的有向边或无向边，那么在二维矩阵（如Ａ）中，a\[i][j] = 1，否则 a\[i][j] = 0。
- 按照简单图的定义，主对角线上元素a\[i][i] = 0，即顶点到自身没有边相连。
- 无向图的邻接矩阵是以主对角线为轴对称的。
![[图论-20250421183827644.png]]
#### 加权邻接矩阵
![[图论-20250421183939441.png]]
邻接矩阵
优点：快速判断是否存在边，快速得到顶点的度或者出度入度
缺点：当边的总数远远小于$n^2$，也需要$n^2$个内存单元来储存边的信息，空间消耗大

因此，对于稠密图（边数非常多），对于有向图是合适的，对于无向图可以只存储上三角矩阵或下三角矩阵。
如果是稀疏图（边数很少），且非零元素的分布没有规律
通常的做法是只存储其中的非零元素和非零元素所在的位置，每个非零元素$a[i][j]$用一个三元组来表示：$（i,j, a[i][j]）$.
将此三元组按照一定的次序排列，如先按照行序再按照列序排列。
三元组可以放在顺序表或者链表中。
### 邻接表
- 顶点依然用一个一维数组来存储，而边的存储是将由同一个顶点出发的所有边组成一条单链表。
- 存储顶点的一维数组称顶点表，存储边信息的单链表称边表。一个图由顶点表和边表共同表示。
- 顶点表不仅保存各个顶点的信息，还保存由该顶点射出的边形成的单链表中首结点的地址（首指针），这种方法称邻接表表示法。
![[图论-20250421184502149.png|625]]
- 无向图，同一条边存储了两次。
- 计算某个顶点v的出度（有向图）或者度（无向图），只需遍历该顶点v指向的边表，即利于计算出度。
- 计算某个顶点v的入度（有向图），需要遍历所有顶点v指向的边表，即不利于计算入度。（可以使用逆邻接表）
	逆邻接表:
	顶点表保存该顶点的射入边形成的单链表的首结点地址，有利于计算顶点的入度）
	![[图论-20250421184629406.png|500]]
- 邻接表中顶点的表依然运用了一维数组，可以改进
	顶点表也用一个单链表表示。此时，dest用顶点结点地址而不用下标。![[图论-20250421184844817.png|500]]
#### 邻接多重表
邻接表中，无向图时每条边都用了两个边结点，即同一条边被存储了两次。
1. 空间浪费
2. 在某些应用中，如遍历所有边时因重复而不方便
所以引出了**邻接多重表**
1.每条边**仅使用一个结点**来表示，即只存储一次，但这个边结点同时要在它邻接的两个顶点的边表中被链接。
2.为了方便两个边表同时链接，每个边结点不再像邻接表中那样只存储边的一个顶点，而是存储两个顶点。
![[图论-20250421185041921.png]]
#### 十字链表
十字链表将有向图的邻接表和逆邻接表结合在了一起，既利于求出度又利于求入度。![[图论-20250421185328446.png]]
## 图的操作
![[9.2 图基础操作]]
![[graph_adjacency_matrix.cpp]]
![[graph_adjacency_list.cpp]]
## 图的遍历
![[9.3 图的遍历]]
## 无向图的连通性
如果无向图是连通的，那么选定图中任何一个顶点，从该顶点出发，通过遍历，就能到达图中其他所有顶点。

方法是：

只需在以上的深度优先、广度优先遍历实现算法中增加一个计数器，记录外循环体中，进入内循环的次数，根据次数是否可以判断出该图是否连通？如果不连通有几个连通分量？每个连通分量包含哪些顶点？
利用BFS即可

# 图的应用
## 最短路径问题
![[图论-20250421190513126.png|375]]
n最短路径问题：如果从图中某一顶点(称为源点)到达另一顶点(称为终点)的路径可能不止一条，如何找到一条路径使得沿此路径上各边上的权值总和达到最小。
问题解法
• 边上**权值非负情形**的单源最短路径问题: [[Dijkstra算法]]
• 边上**权值为任意值**的单源最短路径问题: Bellman和Ford算法
•所有顶点之间的最短路径: Floyd算法
### [[Dijkstra算法]]
![[图论-20250421190649758.png|525]]
算法思想：
引入辅助向量dist，每个分量$dist[v]$表示当前所找到的从原点s到每个终点v的最短路径长度。要求仅仅经过已经确定最短路径长度的节点集合。
设已找到的最短路径的结点集合为S，未找到最短路径的结点集合为 T。
重复以下步骤：
1. 从集合T中基于dist找到当前已知的最短路径结点v加入集合S中
2. 针对v的所有邻居k，更新dist数组
	$dist[k] = min(dis[k], dist[v]+W(v,k))$
3. 重复上述1,2步骤，直到所有节点加入S![[图论-20250421191052914.png|300]]
![[图论-20250421191722695.png|500]] 
![[图论片1.png|300]]![[图论片2.png|300]]
![[图论片5.png|300]]![[图论片4.png|300]]
![[图论片3.png|450]]

### Bellman-Ford算法
- 核心思想：Bellman-Ford算法通过对边进行松弛的方式渐近地求出源顶点s到其余顶点v的最短路径距离
- 松弛操作：
	对一条边<u,v>的松弛过程为：从源顶点s到顶点u之间的最短路径距离加上顶点u与v之间的边权值，并与当前预计算出来的源顶点s到v的最短路径距离比较，如果前者更小，对dist[v]进行更新。

- 构造一个最短路径长度数组序列$dist^1 [u]，dist^2 [u]，…，dist^{n-1} [u]$。其中，$dist^1 [u]$是从源点v到终点u的只经过一条边的最短路径的长度，$dist^1 [u] = Edge[v][u]$；$dist^2 [u]$是从源点v最多经过两条边到达终点u的最短路径的长度，$dist^3 [u]$是从源点v出发最多经过不构成带负长度边回路的三条边到达终点u的最短路径的长度，…，$dist ^{n-1}[u]$是从源点v出发最多经过不构成带负长度边回路的n-1条边到达终点u的最短路径的长度。
- 算法的最终目的是计算出$dist ^{n-1}[u]$。
- 可以用递推方式计算$dist^k [u]$。
- 递推关系：    
$$dist^1 [u] = Edge[v][u]；$$$$

dist^k [u] = min { dist^{k-1} [u], min { dist^{k-1} [j]+Edge[j][u] } }$$
•设已经求出 $dist^k-1 [j], j = 0, 1, …, n-1$, 此即从源点 v 最多经过不构成带负长度边回路的 k-1 条边到达终点 j 的最短路径的长度。
• 从图的邻接矩阵中可以找到各个顶点 j 到达顶点 u 的距离 $Edge[j][u]，$计算 $min { dist^{k-1} [j]+ Edge[j][u] }$，可得从源点 v 绕过各个顶点，最多经过不构成带负长度边回路的 k 条边到达终点u的最短路径的长度。
•用它与$dist^{k-1} [u]$比较，取小者作为$dist^k [u]$的值。
对每对边不断进行比较，得到两点间最短路径
![[图论-20250421192435826.png]]
![[图论-20250421194100618.png]]![[图论-20250421194105752.png]]
复杂度：算法初始化阶段时间复杂度为O($|V|$)，算法执行三重循环循环，每重循环的时间复杂度为O($|V|$)，因此执行三重循环的总复杂度为O($|V|^3$)。算法检测是否存在权值为负值的环路需要遍历整个图，时间复杂度为O($|V|^2$)。综上，算法的总运行时间复杂度为O($|V|^3)。$
### Floyd-Warshall算法
•算法介绍：Floyd-Warshall算法是一种动态规划算法，能解决所有顶点对最短路径问题，运行时间为$O(|V|^3)$，能够处理权值为负的边
•核心思想：**要让任意两点之间的路程变短，只能引入第三个点**，并通过这个顶点w中转即$u→w→v$，才可能缩短原来从顶点u到顶点v的路程。记图G的所有顶点为$V={1,2,...,n}$。考虑其中一个子集 ${1,2,...,k}$，对于任意顶点对$i,j∈V$，考虑从i到j的所有中间顶点均取自集合 ${1,2,...,k}$的那些路径，并设p为其中权值最小的路径。分别考虑顶点k是否是路径p上的一个中间顶点的情况。

1.如果k不是$p$上的中间顶点，则 $p$上所有中间顶点都属于集合 ${1,2,...,k-1}$。因此，从i到j且中间顶点均取自${1,2,...,k-1}$的一条最短路径也同时是从i到j且中间顶点均取自${1,2,...,k}$的一条最短路径。
2.如果顶点$k$是路径$p$上的中间顶点，则将路径p分解成 $p_1:i→k$和$p_2:k→j$。可得$p_1$是从顶点i到顶点$k$的，中间顶点全部取自集合${1,2,...,k-1}$的一条最短路径（因为$k$是末尾顶点）。类似的，$p_2$是从顶点 k到顶点j的，中间顶点全部取自集合${1,2,...,k-1}$的一条最短路径。

•定义$k-path$为任意一条从顶点$v$到$u$的，中间顶点序号小于等于k的路径。
•$0-path$ 即为直接地从v到u的边。
•定义$D(k)(v, u)$为从v到u的长度最小的$k-path$
•动态规划的思想：
•设$D(k)(v, u)$为从v到u的只以$（1,…,k）$集合中的节点为中间节点的最短路径的长度。
•若最短路径经过点k，则$D(k)(v, u)= D(k-1)(v, k)+ D(k-1)(k, u)$
•若最短路径不经过点k，则$D(k)(v, u)= D(k-1)(v, u)$
•因此$D(k)(v,u)$应取$D(k-1)(v, k)+ D(k-1)(k, u)$与$D(k-1)(v, u)$中的最小值。
![[图论-20250421194722572.png|500]]
•定义一个n阶方阵序列D(-1),D(0),D(1),...,D(k),...,D(n-1) ，其中D(-1)[i][j]=M[i][j]，因此：
•$D(k)[i][j]=min{D(k-1)[i][j],D(k-1)[i][k]}+D(k-1)[k][j],0≤k≤n-1$
•$D(1)[i][j]$是从$v_i$到$v_j$的中间顶点的序号不大于1的最短路径的长度；$D(k)[i][j]$是从$v_i$到$v_j$的中间顶点的序号不大于k的最短路径的长度；$D(n-1)$$[i][j]$就是从$v_i$ 到$v_j$的最短路径的长度。根据上述公式，可以计算顶点$v_i$到$v_j$的最短路径长度。
![[图论-20250421195017622.png]]
![[图论片6.png]]![[图论-20250421195140624.png]]
![[图论-20250421200331460.png]]
![[图论-20250421200711357.png]]
## 最小生成树
### Prim算法
从图中任意一个顶点开始，逐步将与已选顶点集相连的权值最小的边及其对应的顶点加入到最小生成树中，直到包含图中的所有顶点。
![[图论-20250421200921416.png]]
![[图论-20250421201025893.png]]![[图论-20250421201030309.png]]
复杂度：采用邻接矩阵存储，不难看出Prim算法时间复杂度为$O(|V|^2)$
### Kruskal算法
•假设G=(V,E)为一个连通图，Emst是E上最小生成树中边的集合。最小生成树T的初始状态为只有|V|个顶点的无边图。算法在E中选择最小代价的边，若该边可以连接T中两个不同的连通分量，则将此边加入到Emst中；否则，判断下一条代价最小的边。反复如此，直到T中所有顶点都在同一连通分量中。
![[图论-20250421201226316.png]]
•由于每次遍历时算法仅对边进行遍历，因此Kruskal算法的时间复杂度仅与图中的边数有关。如果用[[堆的概念]]来存储边，建立[[堆的概念]]的时间复杂度为$O(|E|)$，每次选择边的时间复杂度为$O(log|E|)$,因此Kruskal时间复杂度为$O(|E|log|E|)$。因此Kruskal算法比较适合边稀疏的图。
## [[拓扑排序]]
![[图论-20250421201350749.png]]
![[图论-20250421201405114.png]]
![[图论-20250421201423353.png]]
![[图论-20250421201437356.png]]
![[图论-20250421201449092.png]]
![[图论-20250421201503337.png]]
## [[关键路径]]
![[图论-20250421201540747.png]]
![[图论-20250421201556887.png]]
![[图论-20250421201619098.png]]
![[图论-20250421201639057.png]]
