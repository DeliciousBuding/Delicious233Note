# 建造水族馆问题实验报告

## 一、问题分析

### 1.1 处理对象

输入数据包括：

- 珊瑚礁列数n
- 可用水量上限x
- 珊瑚礁各列高度数组a（长度为n）

核心公式：求最大$h≥1$，使得$Σ(h - a_i) ≤ x$（其中k表示所有满足$a_i < h$的列数）

### 1.2 功能需求

1. 处理多组测试数据（最多10^4组）
2. 快速计算每组数据的最大可行高度h
3. 处理极端情况：
    - 单列珊瑚礁
    - 所有列高度相同
    - 水量刚好用完


## 二、算法设计

### 2.1 数据结构

vector a：存储原始高度（排序后用于快速计算）  
pre_sum数组：前缀和数组，支持O(1)区间求和

### 2.2 算法流程

三阶段：
1. 排序预处理：sort(a.begin(), a.end())
2. 前缀和计算：pre_sum[i] = Σa_j (j=1 to i)
3. 二分查找核心
(1) 初始化边界
`long long left = 1, right = a.back() + x;`
- ​**​搜索范围​**​：
    - 最小可能高度：`left = 1`
    - 最大可能高度：`right = 最大珊瑚高度 + 可用水量`
- ​**​数学依据​**​：  
    最坏情况下所有列都需要注水：`h ≤ max(a_i) + x/n`
(2)二分循环
```cpp
while (left < right) 
{     
long long mid = (left + right + 1) >> 1;   // 计算水量... 
}
```
- ​**​中点选择​**​：  
    使用`mid = (left + right + 1)/2`确保偏向右侧，避免死循环
(3) 关键计算
```cpp
int k = upper_bound(a.begin(), a.end(), mid-1) - a.begin(); 
long long water = mid * k - pre_sum[k];
```
- ​**​k的含义​**​：  
    找到第一个大于`mid-1`的珊瑚位置，即`a[0..k-1]`都≤`mid-1`
(4) 边界调整
`(water <= x) ? left = mid : right = mid-1;`
- ​**​调整逻辑​**​：
    - 水量足够：尝试更大的`h`（右移left）
    - 水量不足：必须减小`h`（左移right）
- ​**​终止条件​**​：  
    当`left == right`时，找到最大可行`h````


## 三、复杂度分析

### 3.1 时间复杂度

排序：O(n log n)  
前缀和计算：O(n)  
二分查找：O(log M)
总复杂度：O(t(n log n + log M log n))

### 3.2 空间复杂度

额外空间：O(n)（前缀和数组）  




