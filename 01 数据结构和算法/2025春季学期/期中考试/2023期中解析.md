​**​1. 分析程序的时间复杂度​**​
> 1.（10 分）分析下列程序的时间复杂度，给出其最佳、最差情况下的时间代价Θ表达式， 要求写出具体的分析过程。 void insertHeap(int *nums,int n,int value) { nums[n] = value; while (n > 0) { int pre = (n-1) / 2; if (nums[pre] <= nums[n]) { break; } else { swap(nums[pre], nums[n]); } n = (n-1) / 2; } }

[[2023春数据结构与算法期中考试题（打印版）.pdf#page=1&selection=77,0,170,1|2023春数据结构与算法期中考试题（打印版）, 页面 1]]
​**​解答：​**​

函数 `insertHeap` 用于将元素插入堆中并调整。其时间复杂度分析如下：

- ​**​最坏情况​**​：插入元素需要从叶子节点一直上浮到根节点。对于包含 `n` 个元素的堆，树的高度为 `Θ(log n)`，每次循环比较父节点，最多进行 `log n` 次交换。时间复杂度为 ​**​Θ(log n)​**​。
    
- ​**​最佳情况​**​：插入元素直接满足堆性质（如父节点已更小），仅需一次比较，时间复杂度为 ​**​Θ(1)​**​。
    

---

​**​2. 链表删除结点可能性​**​

​**​解答：​**​

- ​**​(1) 单链表​**​：无法删除。删除需要前驱结点地址，但单链表无法直接获取前驱。
    
- ​**​(2) 双链表​**​：可以删除。通过 `p->prev` 和 `p->next` 直接调整前后结点的指针。
    
- ​**​(3) 循环单链表​**​：可以删除。从 `p` 出发遍历找到前驱结点（当 `q->next == p` 时，`q` 为前驱），再修改指针。
    

---

​**​3. Mystery类分析​**​

​**​解答：​**​

​**​(1) 操作序列​**​：  
假设三次 `add()` 依次压入 A、B、C。调用 `remove()` 时：

- `pop C` → 递归 `pop B` → 递归 `pop A` → 栈空返回 A。
- 回溯时依次 `push B`、`push C`。  
    操作序列：`pop, pop, pop, push, push`。

​**​(2) 栈示意图​**​：  
执行后栈为 `[B, C]`，栈顶为 C。

​**​(3) 模拟数据结构​**​：​**​队列​**​（FIFO，`remove` 返回最早加入元素）。

---

​**​4. 队列设计​**​
> 4.（10 分）请设计一个队列，要求满足: ①初始时队列为空；②入队时，允许增加队列占 用空间；③出队后，出队元素所占用的空间可重复使用，即整个队列所占用的空间只增不减； ④入队操作和出队操作的时间复杂度始终保持为 O(1)。请回答下列问题： (1) 该队列是选择链式存储结构，还是应选择顺序存储结构?并说明采用该存储结构时如何 能满足题中 4 个要求； (2) 画出队列的初始状态，并给出判断队空和队满的条件。

[[2023春数据结构与算法期中考试题（打印版）.pdf#page=2&selection=146,0,188,24|2023春数据结构与算法期中考试题（打印版）, 页面 2]]
​**​解答：​**​

​**​(1) 存储结构选择​**​：  
选择 ​**​顺序存储结构（动态数组）​**​。

- 入队时若空间不足则扩容（空间只增不减）。
- 出队后保留空间，通过循环队列复用，保证 O(1) 操作。

​**​(2) 初始状态与条件​**​：

- ​**​初始状态​**​：数组大小为初始容量（如 4），`front = rear = 0`。
- ​**​队空​**​：`front == rear`。
- ​**​队满​**​：`(rear + 1) % capacity == front`（触发扩容）。

---

​**​5. 颜色填充算法​**​

​**​解答：​**​

​**​(1) 数据结构选择​**​：​**​队列​**​（BFS 实现，避免递归栈溢出）。

​**​(2) 算法实现​**​：



```cpp
#include <queue>
#include <utility>

// 颜色填充函数
void FillColor(unsigned char **image, int w, int h, int x, int y, unsigned char newColor) {
    // 检查起始坐标是否越界
    if (x < 0 || x >= h || y < 0 || y >= w) {
        return;
    }
    unsigned char oldColor = image[x][y];
    // 若新旧颜色相同，无需填充
    if (oldColor == newColor) {
        return;
    }
    // 定义队列存储待处理的坐标点
    std::queue<std::pair<int, int>> q;
    q.push({x, y}); // 起始点入队

    // 上下左右四个方向的偏移量
    int dx[] = {-1, 1, 0, 0};
    int dy[] = {0, 0, -1, 1};

    while (!q.empty()) {
        auto [curX, curY] = q.front(); // 取出当前处理的点
        q.pop();

        image[curX][curY] = newColor; // 填充当前点颜色

        // 遍历四个方向,并把符合条件的点入队
        for (int i = 0; i < 4; ++i) {
        //利用提前定义的偏移量，+(-1,0)或者+(1,0)，来实现上下左右的各个方向的遍历，很巧妙啊
            int nx = curX + dx[i]; // 计算新坐标x
            int ny = curY + dy[i]; // 计算新坐标y
            // 检查新坐标是否越界且颜色为旧颜色
            if (nx >= 0 && nx < h && ny >= 0 && ny < w && image[nx][ny] == oldColor) {
                q.push({nx, ny}); // 符合条件的点入队
            }
        }
    }
}
```



​​算法中每个像素点最多入队和出队一次，对于宽为 w、高为 h 的图像，总共有 \(w \times h\) 个像素点。每次处理队列中的一个点时，对四个方向的检查和操作时间为常数。因此，算法的时间复杂度为 $(O(w \times h))$，即与图像的像素总数成正比。

---

​**​6. 完全二叉树​**​

​**​解答：​**​

​**​(1) 二叉链表结构​**​：

```
        A
      /   \
     B     C
    / \   / \
   D  E  F  G
  /
 H
```

​**​(2) 中序遍历序列​**​：​**​H D B E A F C G​**​。

---

​**​7. 哈夫曼编码​**​

​**​解答：​**​

​**​(1) 权值较大结点位置​**​：​**​离根更近​**​（哈夫曼树优先合并小权值，大权值路径短）。

​**​(2) 构造 Huffman 树与编码​**​：

- 合并顺序：E+D(0.11) → E+D+A(0.23) → B+0.23(0.41) → C+F(0.59) → 0.41+0.59(1.0)。
- 编码：  
    F: 0  
    C: 10  
    B: 110  
    A: 1110  
    D: 11110  
    E: 11111

---

​**​8. BST 构造​**​

​**​解答：​**​

插入顺序：8 → 11 → 2 → 1 → 4 → 13 → 15。  
最终 BST：

```
    8
   / \
  2   11
 / \   \
1  4   13
         \
          15
```

---

​**​9. 表达式树转中缀​**​

​**​解答：​**​

​**​(1) 设计思想​**​：递归中序遍历，根据运算符优先级添加括号。若子节点运算符优先级低于父节点，则加括号。

​**​(2) 代码实现​**​：

c

复制

```c
void BTreeToInfix(BTree* root, int isRoot) {
    if (!root) return;
    int needBracket = !isRoot && (root->left || root->right);//既不是节点，也有孩子，则需要括号
    if (needBracket) printf("(");//需要括号
    if (root->left) BTreeToInfix(root->left, 0);//遍历到左边
    printf("%s", root->data);//输出里面的数据
    if (root->right) BTreeToInfix(root->right, 0);//遍历到右边
    if (needBracket) printf(")");
}
```

​**​(3) 时间复杂度​**​：​**​O(n)​**​，每个结点访问一次。