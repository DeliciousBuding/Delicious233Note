# 栈和队列

## 中缀表达式 前缀表达式 后缀表达式
![[PixPin_2025-06-05_19-31-20.gif]]
![[PixPin_2025-06-05_19-32-21.gif]]

前缀表达式：从后往前，后入栈的先算
![[PixPin_2025-06-05_19-37-48.gif]]
后缀表达式：从前往后，先入栈的先算
# 字符串匹配
## 朴素算法
> 朴素模式匹配算法
![[第04章课件-字符串.pdf#page=21&selection=2,0,2,8|第04章课件-字符串, 页面 21]]
## KMP
![[期末复习-20250609132105126.png]]
```cpp title="getNext"
void cal_next(char *str, int *next, int len)
{
    next[0] = -1;//next[0]初始化为-1，-1表示不存在相同的最大前缀和最大后缀
    int k = -1;//k初始化为-1
    for (int q = 1; q <= len-1; q++)
    {
        while (k > -1 && str[k + 1] != str[q])//如果下一个不同，那么k就变成next[k]，注意next[k]是小于k的，无论k取任何值。
        {
            k = next[k];//往前回溯
        }
        if (str[k + 1] == str[q])//如果相同，k++
        {
            k = k + 1;
        }
        next[q] = k;//这个是把算的k的值（就是相同的最大前缀和最大后缀长）赋给next[q]
    }
}
```
> KMP算法
![[第04章课件-字符串.pdf#page=26&selection=2,0,3,2|第04章课件-字符串, 页面 26]]

Next数组：![[PixPin_2025-06-09_12-33-37.gif]]

| 模式串索引（i） | 子串（t [0..i]） | PMT [i]（最长公共前后缀长度） | Next [i]（从 - 1 开始） | Next [i]（从 0 开始）    |
|----------|--------------|--------------------|--------------------|---------------------|
| 0        | "a"          | 0                  | -1                 | 0（对应 i=0，空串）        |
| 1        | "ab"         | 0                  | -1                 | 0（对应 i=1，子串 "a"）    |
| 2        | "aba"        | 1                  | 0                  | 0（对应 i=2，子串 "ab"）   |
| 3        | "abab"       | 2                  | 1                  | 1（对应 i=3，子串 "aba"）  |
| 4        | "ababc"      | 0                  | -1                 | 2（对应 i=4，子串 "abab"） |
![[期末复习-20250609130331154.png]]
KMP算法：![[PixPin_2025-06-09_12-28-04.gif]]




#### 代码实现：KMP算法
```cpp
#include <iostream>
#include <string>
using namespace std;

// 计算next数组
void getNext(string t, int next[]) {
    int m = t.length();
    next[0] = -1;
    int i = 0, j = -1;
    while (i < m - 1) {
        if (j == -1 || t[i] == t[j]) {
            i++; j++;
            next[i] = j;
        } else {
            j = next[j];
        }
    }
}

// KMP匹配
int kmp(string s, string t) {
    int n = s.length(), m = t.length();
    if (m == 0) return 0;
    int next[m];
    getNext(t, next);
    int i = 0, j = 0;//i 遍历主串 s，j 遍历模式串 t
    while (i < n && j < m) {
        if (j == -1 || s[i] == t[j]) {
            i++; j++;//当字符匹配时，i 和 j 同时后移。
        } else {
            j = next[j];//当模式串的第 j 位与主串不匹配时，模式串应回退到 next[j] 位置继续比较，这个位置记录了模式串前缀和后缀的最长公共长度,i不变
        }
    }
    if (j == m) return i - j;  // 匹配成功，返回位置
    return -1;  // 匹配失败
}
```

# 树

## 定义
![[期末复习-20250605191255565.png]]

## 二叉树
- 满二叉树![[期末复习-20250605203032220.png]]（哈夫曼树也算）
- 完全二叉树![[期末复习-20250605202939174.png]]
- 完美二叉树![[期末复习-20250605202953702.png]]
- 

## 哈夫曼树
![[期末复习-20250605202735239.png]]
![[期末复习-20250605202645403.png]]
## 二叉树遍历
![[期末复习-20250605191341555.png]]

![[期末复习-20250605192541096.png]]
![[期末复习-20250605192759573.png]]


# 堆
- 大顶堆：每个父节点都大于其子节点
- 堆的存储：完全二叉树用数组存储，节点下标为$i$，左子节点下标为$2i+1$，右子节点下标为$2i+2$![[期末复习-20250607120802241.png]]
- 堆的基本操作：
	- 上调：任意元素插入到堆的尾部，复杂度为$O(logN)$
		- ![[第06章课件-优先级队列.pdf#page=12&selection=0,0,0,8|第06章课件-优先级队列, 页面 12]]
	- 下滤：任意元素插入到堆的顶部，复杂度为$O(logN)$
- 建堆方法：
	- 自顶向下:朴素建堆
	- 自下而上：快速建堆，对每个父节点进行下滤
- 优先队列/堆排序：弹出顶端元素，然后持续维护

# 不相交集

# 图
## 邻接表
![[期末复习-20250605194204602.png]]
![[期末复习-20250605194221872.png]]
## 遍历
- DFS：不撞南墙不回头![[期末复习-20250605194423999.png]]
- BFS![[期末复习-20250605194530564.png]]


## 最短路径
### Dijkstra单源最短路径
![[期末复习-20250605195211159.png]]
### Bellman-Ford算法
Bellman-Ford算法通过对边进行松弛的方式渐近地求出源顶点s到其余顶点 v的最短路径距离。 
### Floyd多源最短路径
要让任意两点之间的路程变短，只能引入第三个点，并通过这个顶 点𝑤中转即𝑢 → 𝑤 → 𝑣
![[期末复习-20250605202154094.png]]
![[期末复习-20250605202205802.png]]

## 关键路径
### AOE网
![[期末复习-20250605193841035.png]]
### 拓扑排序：每次选入度为0的点，然然后删除这个点和它的出边
![[406b51ee8cd784f7c5c44ccc6c1265e.png]]
![[23e8cf38fb4acbcb92f36bcf51742ab.png]]

## 最小生成树
- Prim：加点法不断加相邻最近的，不能形成回路
- Kruskal：加边法，不断加最小的边，不能形成回路
	- 求最小生成树的Kruskal算法： 
		- 按权重递增顺序考虑每条边 
		- 并把连接不同连通分量的边e = (u,v) 加入生成树。
## 并查集 路径压缩 按秩合并
![[845950fbd730f8be5eb8b582854df7b.png]]
![[1b60b8437831631cd5306050a6f8b3b.png]]
![[19701afc6ce3ea697a61268ebe9efd7.png]]

# 排序
## 内排序
![[期末复习-20250609102356393.png]]
- 排序的稳定性:若序列中关键字值相等的节点经过某种排序方法进行排序之后，仍能保持它们在 排序前的相对顺序，则称这种排序方法是稳定的；否则，称这种排序方法是不稳定的。
### 插入排序（折半插入）
![[期末复习-20250609110140093.png]]
 1. 普通插入排序
	算法步骤：
	从第二个元素开始，将其视为待插入元素
	与已排序序列（前 i-1 个元素）从后往前比较
	若待插入元素小于比较元素，则后者后移一位
	找到合适位置插入，重复直至所有元素排序完成
	时间复杂度：平均 / 最坏 O (n²)，最好 O (n)（序列接近有序时）
	空间复杂度：O(1)
	稳定性：稳定（相同元素相对顺序不变）
2. 折半插入排序
	优化点：用二分查找代替线性查找插入位置
	算法步骤：
	对已排序序列使用二分法确定待插入元素位置
	后续元素后移并插入
	时间复杂度：比较次数 O (nlogn)，移动次数 O (n²)
	适用场景：数据量不大且初始序列基本有序时
### 希尔排序
缩小增量排序法
每个增量将序列分组进行插入排序，逐渐缩小增量并进行排序
从d=n/2(向下取整 )
![[期末复习-20250609110546551.png]]
### 冒泡排序
两两比较，逐渐冒泡
优化：在前一轮没有进行交换的时候退出循环
### 选择排序
每轮都在剩下的数里选最小的换到前面
### 归并排序
- 归并操作
	目标：合并成一个有序数组
	每次都选两个数组中最小的(比较各自剩下元素中的第一个)
	其中一个放完后，另一个剩下的元素直接放到最后
- 归并排序
	每轮都对相邻子序列两两归并 
	循环方法：
	![[期末复习-20250609114741888.png]]
	还可以使用递归算法
### 快速排序
通过递归分治方法，基于轴点将待排序序列拆分成两个子序列并分别排序，直 到序列有序。 
排序步骤：
	①从待排序序列中选取轴点。
	②通过交换序列元素，将待排序序列拆分为左右两个子序列，左子序列元素小于等于轴点， 右子序列元素大于等于轴点。 
	③对两个子序列递归进行上述操作，直到子序列元素个数小于等于1。
	代码实现
```cpp
#include <iostream>
#include <vector>
using namespace std;

// 快速排序的划分函数
int partition(vector<int>& arr, int low, int high) {
    int pivot = arr[low];  // 选择最左元素为枢轴
    while (low < high) {
        while (low < high && arr[high] >= pivot) high--;
        arr[low] = arr[high];
        while (low < high && arr[low] <= pivot) low++;
        arr[high] = arr[low];
    }
    arr[low] = pivot;
    return low;
}

// 快速排序主函数
void quickSort(vector<int>& arr, int low, int high) {
    if (low < high) {
        int pi = partition(arr, low, high);
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}
```

### 堆排序
![[PixPin_2025-06-09_11-41-10.gif]]
### 基数排序
逐位进行分配和收集 

1. 个位：![[期末复习-20250609120800815.png]]
2. 十位![[期末复习-20250609120913240.png]]
3. 百位 ![[期末复习-20250609120834472.png]]
4. 得到结果 ![[期末复习-20250609120845364.png]]

### 桶排序
核心思想：将数据分到多个桶中，每个桶内排序后再合并。

算法步骤：
确定桶的数量和范围
将元素分配到对应桶中
对每个桶内元素排序（可使用其他排序算法）
按桶顺序合并元素
时间复杂度：平均 O (n+k)（k 为桶数量），最坏 O (n²)
空间复杂度：O(n+k)
关键前提：数据分布均匀，桶的大小设计合理
稳定性：稳定（取决于桶内排序算法）
### 计数排序
核心思想：非比较排序，统计每个值的出现次数，再按次数重建序列。

算法步骤：
找出数据范围 [min, max]，创建长度为 max-min+1 的计数数组
统计每个元素出现次数
按计数数组顺序重建有序序列
时间复杂度：O (n+k)（k 为数据范围）
空间复杂度：O(k)
前提条件：数据范围有限且为整数
稳定性：稳定

### 索引排序
排序都需要拷贝或移动序列中的元素。当元素移动和拷贝的代价很大时，需要尽可能减少元 素移动和拷贝的次数。 
核心思路：创建一个索引序列idx，在排序时使用原序列元素进行比较，使用索引序列进行元素 交换。最后，算法会给出排序后的索引序列。
## 外排序（多路归并外排序）
### 胜者树
![[第13章-外排序.pdf#page=16&selection=4,7,6,3|第13章-外排序, 页面 16]]
### 败者树
![[第13章-外排序.pdf#page=20&selection=6,0,6,3|第13章-外排序, 页面 20]]
# 查找
## 二分查找
![[期末复习-20250605190931645.png]]
![[期末复习-20250605190948764.png]]
## 二叉搜索树 BST
![[期末复习-20250605203531472.png]]
## 平衡二叉搜索树 AVL
![[期末复习-20250605190121150.png]]
删除时有三种情况：
没有孩子－直接删除
只有左子树/只有右子树－直接代替
左右子树都有 － 直接后继(或前驱)代替值,然后删除(转换成前两种情况)
![[期末复习-20250605172353462.png]]
## 红黑树
### 红黑树的性质
![[期末复习-20250605165619130.png]]
最长路径绝不会超过最短路径的两倍
![[期末复习-20250605170539894.png]]
### 红黑树的插入
![[期末复习-20250605171300706.png]]

![[PixPin_2025-06-05_17-20-39.mp4]]
### 红黑树的删除

## 线段树
![[第12章-高级查询.pdf#page=8&selection=4,6,6,6|第12章-高级查询, 页面 8]]
## B树 B+树：索引

### B树的插入
![[2a50a0a8d4c802a3e323351eeb91479.png]]
### B树的删除
![[e9700b463ed5f35b56baf43762f83d7.png]]
### B+树的比较
![[075e3d7dc45db2c9aaf89d2c1ecbb77.png]]
## 哈希
![[期末复习-20250605183900858.png]]
![[期末复习-20250605184602842.png]]
### 冲突的解决
#### 开放定址法
##### 线性探测法
  - 冲突的解决![[期末复习-20250605184835554.png]]
 - 查找![[期末复习-20250605184951231.png]]
 - 查找的次数ASL![[期末复习-20250605185148646.png]]![[期末复习-20250605185342899.png]]
 - 删除标记![[期末复习-20250605185435239.png]]
##### 平方探测法
 ![[期末复习-20250605185602347.png]]![[期末复习-20250605185726490.png]]
#### 链表法
![[期末复习-20250605190027897.png]]
优点：删除可以直接删
